*** The birdwatch.ui.util namespace
    :PROPERTIES:
    :CUSTOM_ID: the-birdwatch.ui.util-namespace
    :END:

In the code for the Reagent components, we have used a couple of helpers
from the =birdwatch.ui.util=
*[[https://github.com/matthiasn/BirdWatch/blob/aae1a7313211f26946ae55278fb8d3c484060c70/Clojure-Websockets/MainApp/src/cljs/birdwatch/ui/util.cljs][namespace]]*,
all of which are pure functions:

#+BEGIN_EXAMPLE
    (ns birdwatch.ui.util
      (:require [clojure.string :as s]))

    (defn by-id
      "Helper function, gets DOM element by ID."
      [id]
      (.getElementById js/document id))

    (defn number-format
      "Formats a number for display, e.g. 1.7K, 122K or 1.5M followers."
      [number]
      (cond
       (< number 1000) (str number)
       (< number 100000) (str (/ (.round js/Math (/ number 100)) 10) "K")
       (< number 1000000) (str (.round js/Math (/ number 1000)) "K")
       :default (str (/ (.round js/Math (/ number 100000)) 10) "M")))

    (defn from-now
      "Formats a date using the external moment.js library."
      [date]
      (let [time-string (. (js/moment. date) (fromNow true))]
        (if (= time-string "a few seconds") "just now" time-string)))

    (def twitter-url "https://twitter.com/")

    (defn a-blank
      "Creates HTML string for a link that opens in a new tab in the browser."
      [url text]
      (str "<a href='" url "' target='_blank'>" text "</a>"))

    (defn- url-replacer
      "Replace URL occurences in tweet texts with HTML (including links)."
      [acc entity]
      (s/replace acc (:url entity) (a-blank (:url entity) (:display_url entity))))

    (defn- hashtags-replacer
      "Replaces hashtags in tweet text with HTML (including links)."
      [acc entity]
      (let [hashtag (:text entity)
            f-hashtag (str "#" hashtag)]
        (s/replace acc f-hashtag (a-blank (str twitter-url "search?q=%23" hashtag) f-hashtag))))

    (defn- mentions-replacer
      "Replaces user mentions in tweet text with HTML (including links)."
      [acc entity]
      (let [screen-name (:screen_name entity)
            f-screen-name (str "@" screen-name)]
        (s/replace acc f-screen-name (a-blank (str twitter-url screen-name) f-screen-name))))

    (defn- reducer
      "Generic reducer, allows calling specified function for each item in provided collection."
      [text coll fun]
      (reduce fun text coll))

    (defn format-tweet
      "Formats tweet text for display by running multiple reducers."
      [tweet]
      (let [{:keys [urls media user_mentions hashtags]} (:entities tweet)]
        (assoc tweet :html-text
          (-> (:text tweet)
              (reducer , urls url-replacer)
              (reducer , media url-replacer)
              (reducer , user_mentions mentions-replacer)
              (reducer , hashtags hashtags-replacer)
              (s/replace , "RT " "<strong>RT </strong>")))))

    (defn entity-count
      "Gets count of specified entity from either tweet, or, when exists, original (retweeted) tweet."
      [tweet state k s]
      (let [rt-id (if (contains? tweet :retweeted_status)
                    (:id_str (:retweeted_status tweet))
                    (:id_str tweet))
            count (k ((keyword rt-id) (:tweets-map state)))]
        (if count (str (number-format count) s) "")))

    (defn rt-count
      "Gets the formatted string for the :retweet_count if exists, otherwise yields empty string."
      [tweet state]
      (entity-count tweet state :retweet_count " RT | "))

    (defn fav-count
      "Gets the formatted string for the :favorite_count if exists, otherwise yields empty string."
      [tweet state]
      (entity-count tweet state :favorite_count " fav"))

    (defn rt-count-since-startup
      "Gets RT count since startup for tweet, if exists returns formatted string."
      [tweet state]
      (let [t (if (contains? tweet :retweeted_status)
                (:retweeted_status tweet)
                tweet)
            cnt ((keyword (:id_str t)) (:by-rt-since-startup state))
            reach ((keyword (:id_str t)) (:by-reach state))]
        (when (> cnt 0)
          (str "analyzed: " (number-format cnt) " retweets, reach " (number-format reach)))))

    (defn tweets-by-order
      "Finds top n tweets by specified order."
      [order state n skip]
      (map (fn [[k v]] (get (:tweets-map state) k {:id_str (name k)}))
           (->> (order state)
                (drop (* n skip) ,)
                (take n ,))))
#+END_EXAMPLE

I don't know, but for my taste this namespace is almost too long in
terms of the number of lines. What do you think? Anyway, let's go
through the code function by function. First, we have the =by-id=
function:

#+BEGIN_EXAMPLE
    (defn by-id
      "Helper function, gets DOM element by ID."
      [id]
      (.getElementById js/document id))
#+END_EXAMPLE

This function is very straightforward despite the interaction with the
JavaScript host platform. All it does is getting a DOM element by ID.
Next, we have the =number-format= function:

#+BEGIN_EXAMPLE
    (defn number-format
      "Formats a number for display, e.g. 1.7K, 122K or 1.5M followers."
      [number]
      (cond
       (< number 1000) (str number)
       (< number 100000) (str (/ (.round js/Math (/ number 100)) 10) "K")
       (< number 1000000) (str (.round js/Math (/ number 1000)) "K")
       :default (str (/ (.round js/Math (/ number 100000)) 10) "M")))
#+END_EXAMPLE

You know what this does if you've ever used Twitter. It reduces large
numbers to fewer significant figures. Take Justin Bieber, for example.
There's simply not enough space to display his number of followers,
which was *59,776,559* at the time of writing. It is so much easier to
squeeze in *59.8M* instead.

#+BEGIN_EXAMPLE
    (defn from-now
      "Formats a date using the external moment.js library."
      [date]
      (let [time-string (. (js/moment. date) (fromNow true))]
        (if (= time-string "a few seconds") "just now" time-string)))
#+END_EXAMPLE

The result of the =from-now= function should be equally familiar. It
shows "just now" when a timestamp was, well, just now. Or "30 min" or
"12 hours" or whatever. You get the idea. If you want to know more about
the behavior, the *[[http://momentjs.com][moment.js]]* documentation has
you covered. This function is just a thin wrapper over it.

#+BEGIN_EXAMPLE
    (def twitter-url "https://twitter.com/")

    (defn a-blank
      "Creates HTML string for a link that opens in a new tab in the browser."
      [url text]
      (str "<a href='" url "' target='_blank'>" text "</a>"))
#+END_EXAMPLE

The =a-blank= returns an HTML string for a link that opens in a new tab.
The tweet text is constructed as an HTML string as a whole and passed
into the =tweet-text= component's div. Remember from the last chapter?
Here's a reminder, it involved dangerously setting something:

#+BEGIN_EXAMPLE
    [:div {:dangerouslySetInnerHTML #js {:__html (:html-text tweet)}}]
#+END_EXAMPLE

It may be possible to implement this in pure Reagent without this
"dangerous" behavior. That's fine by me as injections of malicious code
don't seem to be an issue in this application. And it would be more
elegant. Anyone interested in solving this? Maybe that could be a task
to solve during a meetup or so. If you're interested, knock yourself
out.

The =a-blank= function we've seen a moment ago is then used by the
=url-replacer=, =hashtags-replacer=, and =mentions-replacer= functions:

#+BEGIN_EXAMPLE
    (defn- url-replacer
      "Replaces URL occurrences in tweet texts with HTML (including links)."
      [acc entity]
      (s/replace acc (:url entity) (a-blank (:url entity) (:display_url entity))))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    (defn- hashtags-replacer
      "Replaces hashtags in tweet text with HTML (including links)."
      [acc entity]
      (let [hashtag (:text entity)
            f-hashtag (str "#" hashtag)]
        (s/replace acc f-hashtag (a-blank (str twitter-url "search?q=%23" hashtag) f-hashtag))))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    (defn- mentions-replacer
      "Replaces user mentions in tweet text with HTML (including links)."
      [acc entity]
      (let [screen-name (:screen_name entity)
            f-screen-name (str "@" screen-name)]
        (s/replace acc f-screen-name (a-blank (str twitter-url screen-name) f-screen-name))))
#+END_EXAMPLE

The three /replacer/ functions we have just looked at obviously need to
be called from somewhere. I wanted to use the
*[[http://clojuredocs.org/clojure.core/-%3E][thread-first macro]]* and
pass the result from one =reduce= into the next =reduce= until all
replacements had been performed. However, the signature of =reduce= did
not match. Not to worry, I can just write a function for that:

#+BEGIN_EXAMPLE
    (defn- reducer
      "Generic reducer, allows calling specified function for each item in collection provided."
      [text coll fun]
      (reduce fun text coll))
#+END_EXAMPLE

In the =reducer= function above, reduce is called internally while
providing the signature I need, so to work with either the
=thread-first= or the =thread-last= macro. This =reducer= can now be
called from inside the function that formats the entire tweet text HTML
string:

#+BEGIN_EXAMPLE
    (defn format-tweet
      "Formats tweet text for display by running multiple reducers."
      [tweet]
      (let [{:keys [urls media user_mentions hashtags]} (:entities tweet)]
        (assoc tweet :html-text
          (-> (:text tweet)
              (reducer , urls url-replacer)
              (reducer , media url-replacer)
              (reducer , user_mentions mentions-replacer)
              (reducer , hashtags hashtags-replacer)
              (s/replace , "RT " "<strong>RT </strong>")))))
#+END_EXAMPLE

So much for the tweet text. But we have more to discuss. We need to get
the counts of multiple entities, such as the /followers/, /retweet/,
/favorites/, or the /retweets within the loaded tweets/:

#+BEGIN_EXAMPLE
    (defn entity-count
      "Gets count of specified entity from either tweet or, if exists, original (retweeted) tweet."
      [tweet state k s]
      (let [rt-id (if (contains? tweet :retweeted_status)
                    (:id_str (:retweeted_status tweet))
                    (:id_str tweet))
            count (k ((keyword rt-id) (:tweets-map state)))]
        (if count (str (number-format count) s) "")))
#+END_EXAMPLE

This =entity-count= function takes a =tweet=, the =state= snapshot, a
keyword =k= and a string =s=. It then checks if the =tweet= is a retweet
(contains a =:retweeted-status= ). If so, it uses the ID of the retweet,
otherwise it takes the ID of =tweet= as =rt-id=. Then, =count= is
determined by looking up the =rt-id= within the =state= snapshot, using
=k= as the lookup function. Finally, if =count= exists, it concatenates
the result from calling the =number-format= function with =count= and
the string =s=. This =entity-count= function can now be used more
specifically:

#+BEGIN_EXAMPLE
    (defn rt-count
      "Gets the formatted string for the :retweet_count if exists, otherwise yields empty string."
      [tweet state]
      (entity-count tweet state :retweet_count " RT | "))

    (defn fav-count
      "Gets the formatted string for the :favorite_count if exists, otherwise yields empty string."
      [tweet state]
      (entity-count tweet state :favorite_count " fav"))
#+END_EXAMPLE

Both =rt-count= and =fav-count= simply call =entity-count= with the
respective keywords and strings. The =rt-count-since-startup= is a
little more involved:

#+BEGIN_EXAMPLE
    (defn rt-count-since-startup
      "Gets RT count since startup for tweet, if exists returns formatted string."
      [tweet state]
      (let [t (if (contains? tweet :retweeted_status)
                (:retweeted_status tweet)
                tweet)
            cnt ((keyword (:id_str t)) (:by-rt-since-startup state))
            reach ((keyword (:id_str t)) (:by-reach state))]
        (when (> cnt 0)
          (str "analyzed: " (number-format cnt) " retweets, reach " (number-format reach)))))
#+END_EXAMPLE

Once again, we look if the tweet is a retweet. If so, further reasoning
is done on the retweet; if not, the tweet itself is used. Then, we can
look up the number of retweets within the loaded tweets and the reach
within the same dataset by looking up the count within the respective
sort orders, which we have derived and updated when ingesting tweets.

Finally, there is a function that returns a list of tweets for display
in the UI, paginated, with the correct number of items and in the right
sort order:

#+BEGIN_EXAMPLE
    (defn tweets-by-order
      "Finds top n tweets by specified order."
      [order state n skip]
      (map (fn [[k v]] (get (:tweets-map state) k {:id_str (name k)}))
           (->> (order state)
                (drop (* n skip) ,)
                (take n ,))))
#+END_EXAMPLE

The =tweets-by-order= function takes the desired =order=, the =state=
snapshot, the page size =n= and the number of items to =skip= (for
pagination). It then uses =map= to apply an anonymous function to every
item in a collection that is derived by taking the specified sort order
from the =state= snapshot, dropping =(* n skip)= items and taking =n=
items. Inside the anonymous function, each item is converted to a tweet
by looking it up in the =:tweets-map= key inside the =state= snapshot.
If the tweet is not found, the map ={:id_str (name k)}= is used instead.
This default value is used for the =missing-tweet= component we met when
we discussed the =tweets-view= component. The =:id-str= of the missing
tweet then allows the =missing-tweet= component to emit a request for
retrieval.

That's it for displaying the tweets. I like that the part of the
application handling the application state does not need to know
anything about how it's rendered or used. This, however, requires
knowledge of the data structure inside the UI layer. I think that's okay
though. For the UI layer, the application state change is an observable
fact that it can then transform into a visual representation. It's a
function that takes the state snapshot and derives the DOM, with no
write access to the application state. I like that more than having the
State component know about data structures required by the UI. However,
I'm curious about your thoughts on this.

By the way, for every thought that you have and you'd like to get
clarification on or discuss, please send me an email:
[[mailto:matthias.nehlsen@gmail.com][matthias.nehlsen@gmail.com]]
