# Why am I writing this book?

My first professional work experiences were in healthcare IT, where I was architecting workflows between healthcare systems. All that was based on pretty high-level HL7 messages. Take for example an order message, for an MRI scan. The order is sent by the Hospital Information system and received by the Radiology Information System. The patient data is then provided to PACS (Picture Archiving and Communication System) and the modality (MRI-scanner, CAT, Ultrasound, whatever) via a DICOM worklist. Once an examination begins, this status change (open, started, completed) is communicated back to RIS via MPPS (Modality Performed Procedure Step). Once the exam is complete, it is put into the radiologists’ worklist. The assigned radiologist then dictates her findings into speech recognition software (assigned to patient ID and procedure ID). The report together with selected key images is then routed to the EMR (Electronic Medical Record). In parallel, a billing message is sent to HIS/accounts receivable.

After doing that for a few years, I was bored and wanted to write software myself. While doing my Master’s, I did a 6-month internship with Microsoft at the Healthcare Innovation Lab, processing aforementioned HL7 messages in a C# application, while using Windows Workflow Foundation for orchestration. Once again, I was working with high-level concepts, which I like. I stayed at Microsoft for another year on a J1 visa and continued to work on high-level message orchestration and alerting. I can totally recommend doing an internship or working there. I’m just afraid it doesn’t exist in the same form any longer.

After the visa was up, I had to go back home to Germany as this was in the middle of the financial crisis, with a general hiring freeze. I started familiarizing myself with Play Framework and Scala at the time and thought that would be the way to go. After doing a freelance project with it, I applied for a job as a Scala developer in Amsterdam. I wanted to have something to show, as the previous project was an internal application that I was not at liberty to show as a reference. So I started working on the BirdWatch application, just to have something to use as a reference. I wanted to use real-time data source and visualize that data it in a browser. The Twitter Streaming API seemed like a good candidate, so I wrote an application that consumes that API and displays some visualizations in a browser.

Then, I got the job I was interviewing for, and I was miserable. I was expected to perform a minor version bump of the Spray library in the dependencies of that application. That thing blew up in over 60 places. The compilation output was basically a bloodbath in red error messages. That alone was a reason to run away. Listen to Rich Hickey or Brian Goetz and how they appreciate that what’s out can’t easily be changed because PEOPLE ARE USING IT. I have nothing to add, except that I agree whole-heartedly.

With Clojure, my experience has been that I find a library that’s three years old, but hey, I import it, and it works flawlessly. With Scala, the exact opposite has been the case. The experience with the minor version bump in Spray has been the norm rather than the exception.

But the was an entirely different reason why I wanted to run away, and that was the abstraction level that Spray was dealing with. I don’t know about you, but when I want a car, I get a car and not an assemble-yourself-kit that may or may not result in a car when assembled, depending on your car-making skill level. Everything I saw was so ridiculously low-level, coming from my background of building high-level message orchestration.

At the same time, and this did make things easier for me, I had discovered Clojure. I think I read Hackers & Painters and The Joy of Clojure in parallel. I realized that systems could be built in a way that is much easier to reason about, both because of a beautifully simple, LISP-y language and because of a higher level of abstraction that allows us to pass messages in the form of maps, process them and orchestrate their flow through a complex system.

I quit the job around 3.5 months later. At the time, a publisher had just recently approached me to write a book about AngularJS, so I decided to do the book rather than for the job I had just started.

After working on the book for two months, I began working as a freelance Scala developer on a server-side e-commerce application. This system was Play Framework and Akka. My experience there was much better than in the previous situation, and it was also much, much better paid. Yeah, you can actually build complex application in Scala, but I still didn’t quite like the level of abstraction, dealing with low-level actors. After doing that for eight months or so, I decided that it was time to finally give Clojure a real try, to see if my hunch was right that I could actually enjoy developing software once I made a switch. Scala wasn’t it for my happiness, but you can read more about that in my **[Farewell Letter to a Programming Language](http://t.co/6Bscwstjho)**.

I wanted to give Clojure a shot, so I started re-writing my BirdWatch application, which at the time was a Play Framework / Scala backend with either an AngularJS or ReactJS frontend. That worked well, and I regained the fun in programming. Seriously. Well, until subsequent client work showed me how not to do it, but that's an entirely different topic.

So this is the story how I got to write this book. I rewrote my application in Clojure, and I enjoyed it. I am thinking about systems in terms of rather high-level constructs (like channels, components, JVMs). In a way, this is comparable to globally operating logistics companies. They don’t need to know how to build a car or a plane, and neither should I have to worry about composing low-level actors, which, by the way, I find don’t compose all that well.

Now you know the overarching story. There are two additional threads to follow in this book. The first narrative here is how messages flow through the system, originating in the Twitter Streaming API and resulting in a real-time chart in a web client. Then, there’s also the narrative of how this book is written not after the fact but in real time. I will write the software for the performance- and verification-related chapters while writing the chapters themselves. This approach gives you, dear early reader, the unique opportunity to contribute to the process by commenting on and criticizing my ideas. Please make use of that.