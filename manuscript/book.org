* Introduction
  :PROPERTIES:
  :CUSTOM_ID: introduction
  :END:

Hamburg, June 2016

A year and a half ago I started working on this book. The initial
chapters just poured out of me, and then I realized that the kind of
application that I was trying to build would greatly benefit from a
library that makes composing a system out of individual components or
subsystems that communicate via message passing much simpler. Then I had
this gig that allowed me to explore the problem space further, and build
a commercial application on top of it.

For a long time, I had wanted to get back to the book. But two things
held me back:

1) I was waiting for inspiration to strike me once again, and then a few
   weeks later regain full conscience, noticing to my pleasant surprise
   that the book had completed itself in the meantime. Imagine my
   disappointment when I noticed that it doesn't work that way.

2) I was dreading having to write the documentation of the library
   without a mechanism in place that validates its usage, the messages
   passed around, and alterations to the managed component state. I had
   looked into *[[https://github.com/plumatic/schema][schema]]* a few
   times, but somehow did not feel compelled to adopt it. No validation
   wasn't viable either, as then everything depends on the wording of
   the documentation, and that's a source of ambiguity that's best
   avoided.

Then, along came *[[http://clojure.org/about/spec][clojure.spec]]*, and
I was stunned how well it fit the bill. Within days, I had adapted the
*[[https://github.com/matthiasn/systems-toolbox][systems-]]* libraries
and all of the sample applications, and I'm very excited how much more
sense the entire approach makes after THE source of errors I had dealt
with just fall by the wayside. The biggest problem had always been maps
not structured as expected, and me as the developer having to keep those
expectations in my head, rather than have the program do it for me. The
capacity of my brain is way too small to keep such stuff in working
memory.

In particular, I had those issues while working on my latest
application, *[[https://github.com/matthiasn/iWasWhere][iWasWhere]]*,
which is an application for helping me get more done while being
happier, in a geolocation-aware context. No worries, I'll get to that as
it'll be one of the sample applications of this book. Among other
things, *iWasWhere* is supposed to help me reach longer-term goals, such
as finishing this very book, and I write it using the *systems-toolbox*
libraries. Thus, I expect some cross-pollination between the book and
the project. Anyway, building this application luckily put me back in
the position of a user of the libraries, and that's a welcome change of
perspective for moving it forward. And now with *clojure.spec*, this has
become much more pleasant.

Now, this is going to be a *reboot* of the book project. For now, I will
move all the existing chapters into the appendix, for reference.
However, your time is probably better spent reading the new material,
and then joining a discussion about it. I want this book to *help you*
approach this beautiful language named Clojure, and I can do that best
when you *let me know* what you found unclear, or where you would like
additional explanations. To provide *feedback*, you can either contact
me directly under
[[mailto:matthias.nehlsen@gmail.com][matthias.nehlsen@gmail.com]] or
create an issue in this book's
*[[https://github.com/matthiasn/clojure-system-book][GitHub project]]*,
ideally with file and line number.

I imagine the *systems-toolbox* libraries to be helpful when you want to
build applications like the ones described in this book. For anything
that you find missing or where you want something improved, please also
consider opening an issue on
*[[https://github.com/matthiasn/systems-toolbox][GitHub]]*.

Now have fun playing around with the sample applications. I'm confident
you will *learn the most* when checking out the code, changing stuff
here and there, and build something different out of these applications.
All of them here are compatible with
*[[https://github.com/bhauman/lein-figwheel][FigWheel]]*, by the way.
It's instant feedback make coding all the more gratifying.

Okay, that's all, let me know how I can help!

Matthias

*P.S.* I'm curious about what you will build on top of these libraries.
If you have a project you would like me to look at, shoot me an email.
If it's an open source project, I'll be happy to do a code review for
free. All else can be discussed.

#+Latex:\pagebreak
* Example application: Counter
  :PROPERTIES:
  :CUSTOM_ID: example-application-counter
  :END:

In *Clojure* (and *ClojureScript*), we like to use
*[[https://en.wikipedia.org/wiki/Persistent_data_structure][persistent data structures]]* because they are *[[https://en.wikipedia.org/wiki/Immutable_object][immutable]]*.
Immutable data structures are great, because they make a program easier
to reason about, and they make an entire class of potential bugs
disappear: with immutable values, there is no possibility for
*accidentally mutating* something. If you haven't seen Rich Hickey's
talk *"The Value of Values"*, you should watch it now, or read the *[[https://github.com/matthiasn/talk-transcripts/blob/4f17b730a370cf454266c90525ea5ff0d1f38098/Hickey_Rich/ValueOfValues.md][transcript]]*,
and then continue with this chapter.

Okay, now you're familiar with Rich Hickey's thoughts on immutable data.
Hopefully, we're now on the same page about their value. Ideally, when
building a *UI*, we would want to create functions that take some
*immutable* data and return some *HTML*. On the server side, that's
exactly how you would have done it for years. With something like
*[[https://github.com/weavejester/hiccup][Hiccup]]*, you can build such
functions easily. However, this doesn't easily transfer to the
*ClojureScript* world. Server-side rendering means having to reload the
page when anything changes and long gone are the days in which that was
sufficient. We can no longer expect that users will happily refresh a
page and wait, wait, *wait*.

Rather, nowadays, we want to build highly *interactive* web applications
that feel like *desktop applications* or *mobile apps*, rather than the
typical thing of the early web, where you submit a form and wait for
some page to appear, seconds later.

Ideally, we should be able to do the same thing on the client as we do
on the server. Pass some data to a function, get some DOM subtree back,
and move on. But for a long time there was no decent solution for this
problem, which presumably has to do with the
*[[https://en.wikipedia.org/wiki/Document_Object_Model][DOM]]* being this highly mutable construct, which UI frameworks such as
*[[https://angularjs.org/][AngularJS 1.x]]* use directly for attaching
data and functionality. I tried to use AngularJS with *ClojureScript* a
long time ago, and it just doesn't seem to work properly, in a way I'd
call predictable.

Then, along came *[[https://facebook.github.io/react/][React]]*, which changed everything. 
It allows us to write pure functions that we can
feed immutable data, and that will build an entire DOM subtree out of
the data every single time. Then, when a change in the data is detected,
the render function is called again, generating the entire output.
*React* will then do some diffing between the previous version and the
latest version, in a virtual DOM, and deal with the messy DOM mutation
to enact the detected changes in the "real" DOM. This approach may sound
like a lot of work, but in reality, it's super fast, faster than
anything we'd have to worry about in most cases.

Then there are ClojureScript libraries that make React available to us
*Clojure(Script)* developers. The one that was available first was
*[[https://github.com/omcljs/om][Om]]*. I prefer writing user interfaces
in *Hiccup*, because I find this notation very terse and succinct, and
it also makes for something that's particularly easy to test, but more
about that another time. Luckily, there's
*[[https://reagent-project.github.io/][Reagent]]*, which provides just
that: a way to use *Hiccup* on the client, with React.

With Reagent, you can then start building applications, right from where
its tutorials leave you. The promise there is that all you need to do is
share a Reagent atom between the different parts of your application.
Hmm, sounds simple enough, but every time I tried to build an evolving
system around it, I ended up writing something that quickly became hard
to maintain. Like, repeatedly. And pull-my-hair-out hard.

It turns out that those problems have nothing to do with Reagent.
Rather, they were dealing with the same kinds of problems at *Facebook*,
where React originated (via Instagram), so they came up with the
*[[https://facebook.github.io/flux/][Flux pattern]]*.

*Flux* deals with structuring the application in a way that all state
mutation happens in a single place, rather than ad-hoc where UI
functions have write access to data. The latter is just terribly hard to
maintain and difficult to debug, and that's my experience when using
Reagent also - which, after all, is only a thin wrapper on top of React.

Flux is an approach, not a library. However, there's
*[[https://github.com/reactjs/redux][Redux]]*. Redux is called a
*predictable state container*. What's that? Well, basically a place
where your data lives, and also the only place where that data changes.
Every other part of the application only has read access. It's very
helpful when you want to reason about an application. Without a
structured approach to state management, I often find my mental
complexity budget stretched beyond the point of breaking. As in, pulling
my hair out because of not finding bugs that should not have existed in
the first place.

As it turns out, the *[[https://github.com/matthiasn/systems-toolbox][systems-toolbox library]]* allows for the same kind of 
approach suggested by Redux.
There's a predictable state container, which is interacted with via
*immutable messages* only, for example when clicking a button. Then,
there are other components that observe the state in that container and
get notified when it changes. These can for example then render an
updated user interface. I found this to a be a helpful way for
structuring applications, and I've written a handful in this pattern so
far, probably most notably the latest incarnation of
*[[https://github.com/matthiasn/BirdWatch][BirdWatch]]*.

That application wouldn't make for a gentle introduction so let's
instead start with something very simple. In the Redux tutorials,
there's an *example with a counter*, where clicks on increment and
decrement buttons change app state, which then again is re-rendered by
React. Let's do the same thing in ClojureScript, using the
*systems-toolbox* and
*[[https://github.com/matthiasn/systems-toolbox-ui][systems-toolbox-ui]]*
libraries.

#+CAPTION: Counter Example
[[file:images/redux-counter.png]]

We start with three counters, which each can be incremented or
decremented using a button, and we can also add or remove counters.
Simple, right? You could certainly do the same with just Reagent and an
atom, but in my experience, that doesn't scale when things get more
complex than this. Let's instead keep state and UI separate and see what
that looks like.

Let me briefly introduce the systems-toolbox model now. There's a
*component*. A component is an entity that has a lifecycle. It has some
state, and it reacts to messages. It then also has some *observable
state*, which other parts of the application can look at, read-only.

In this example, there's the store component, let's just look at the
code[fn:1]. in the
*[[https://github.com/matthiasn/systems-toolbox/blob/master/examples/redux-counter01/src/cljs/example/store.cljs][example.store namespace]]*:

#+BEGIN_SRC clojure
  (ns example.store
    "In this namespace, the app state is managed.
    One can only interact with the state by sending immutable messages.
    Each such message is then handled by a handler function.
    These handler functions here are pure functions, they receive message and
    previous state and return the new state.

    Both the messages passed around and the new state returned by the handlers
    are validated using clojure.spec. This eliminates an entire class of possible
    bugs, where failing to comply with data structure expectations might now
    immediately become obvious."
    (:require [cljs.spec :as s]))

  (defn inc-handler
    "Handler for incrementing specific counter"
    [{:keys [current-state msg-payload]}]
    {:new-state
     (update-in current-state [:counters (:counter msg-payload)] #(+ % 1))})

  (defn dec-handler
    "Handler for decrementing specific counter"
    [{:keys [current-state msg-payload]}]
    {:new-state
     (update-in
      current-state
      [:counters (:counter msg-payload)]
      dec)})

  (defn remove-handler
    "Handler for removing last counter"
    [{:keys [current-state]}]
    {:new-state (update-in current-state [:counters] #(into [] (butlast %)))})

  (defn add-handler
    "Handler for adding counter at the end"
    [{:keys [current-state]}]
    {:new-state (update-in current-state [:counters] conj 0)})

  (defn state-fn
    "Returns clean initial component state atom"
    [_put-fn]
    {:state (atom {:counters [2 0 1]})})

  ;; validate messages using clojure.spec
  (s/def :redux-ex1/counter #(and (integer? %) (>= % 0)))
  (s/def :cnt/inc (s/keys :req-un [:redux-ex1/counter]))
  (s/def :cnt/dec (s/keys :req-un [:redux-ex1/counter]))

  ;; validate component state using clojure.spec
  (s/def :redux-ex1/counters (s/coll-of integer? []))
  (s/def :redux-ex1/store-spec (s/keys :req-un [:redux-ex1/counters]))

  (defn cmp-map
    [cmp-id]
    {:cmp-id      cmp-id
     :state-fn    state-fn
     :state-spec  :redux-ex1/store-spec
     :handler-map {:cnt/inc    inc-handler
                   :cnt/dec    dec-handler
                   :cnt/remove remove-handler
                   :cnt/add    add-handler}})
#+END_SRC

Above, you can see that there are four handlers, for four different
message types: =:cnt/inc=, =:cnt/dec=, =:cnt/add= and =:cnt/remove=.

Then, there's application state. The initial state is returned by the
=state-fn=:

={:counters [2 0 1]}=

Each of these three counters has an initial value, which can be changed
by clicking the respective buttons. That's all there is to the app
state. Each handler takes the =current-state= argument and returns the
=:new-state= in the respective key in the returned *map*.

Then, as a recent addition to the library, there is also *validation*
provided by the excellent
*[[https://clojure.org/about/spec][clojure.spec]]*, which for me changes
everything in *Clojure* for the better. With it, we can specify
precisely how both messages passed around and returned state changes are
supposed to look like, and fail otherwise. This validation gives you the
best of both worlds. You get the sanity check from a typed world, only
better in some regards, and without all the clutter.

Next, let's have an eye on a UI component that makes use of this state
to render something, and finally, look at how messages get passed back
and forth between those components.

The UI functions are super simple. There are only three functions in the
*[[https://github.com/matthiasn/systems-toolbox/blob/master/examples/redux-counter01/src/cljs/example/counter_ui.cljs][example.counter-ui
namespace]]*, =counter-view=, =counters-view=, and =cmp-map=:

#+BEGIN_SRC clojure
  (ns example.counter-ui
    (:require [matthiasn.systems-toolbox-ui.reagent :as r]
              [matthiasn.systems-toolbox-ui.helpers :as h]))

  (defn counter-view
    "Renders individual counter view,
    with buttons for increasing or decreasing the value."
    [idx v put-fn]
    [:div
     [:h1 v]
     [:button {:on-click #(put-fn [:cnt/dec {:counter idx}])} "dec"]
     [:button {:on-click #(put-fn [:cnt/inc {:counter idx}])} "inc"]])

  (defn counters-view
    "Renders counters view, observes the state held by the state component.
    Contains two buttons for adding or removing counters, plus a counter-view
    for every element in the observed state."
    [{:keys [current-state put-fn]}]
    (let [indexed (map-indexed vector (:counters current-state))]
      [:div.counters
       [h/pp-div current-state]
       [:button {:on-click #(put-fn [:cnt/remove])} "remove"]
       [:button {:on-click #(put-fn [:cnt/add])} "add"]
       (for [[idx v] indexed]
              ^{:key idx} [counter-view idx v put-fn])]))

  (defn cmp-map
    [cmp-id]
    (r/cmp-map {:cmp-id  cmp-id
                :view-fn counters-view
                :dom-id  "counter"}))
#+END_SRC

The =cmp-map= function returns a configuration map that systems-toolbox
needs to start a component of this kind. In this case, that's a
component that renders a small piece of UI into the element with the
specified element ID in the DOM. There, it specifies that the
counters-view function should be called to turn data into a piece of
user interface.

This =counters-view= then gets passed the =current-state= and turns that
into a tree structure of DOM elements, with add and remove buttons once,
and then a =counter-view= for each indexed element in the counters in
the =current-state=. Then, note that there's the =put-fn=, which we can
call when the component is supposed to send something, so in this case
when the respective button is clicked. Note that the index is used to
identify which of the (initially three) counters to increment or
decrement.

That's all there is to the UI component. Now let's look at how those
components are wired together, in the =core= namespace. There's the
=switchboard=, which you can think of like this:

#+CAPTION: Telephony switchboard
[[file:images/JT_Switchboard_770x540.jpg]]

Someone connects a wire, and you can start talking. Only that here, the
wires are *uni-directional*. Under the hood, there are
*[[https://github.com/clojure/core.async][core.async]]* channels
connected to each other, but you don't need to worry about that for now.

Let's have a look at the
*[[https://github.com/matthiasn/systems-toolbox/blob/master/examples/redux-counter01/src/cljs/example/core.cljs][example.core namespace]]*:

#+BEGIN_SRC clojure
    (ns example.core
      (:require [example.store :as store]
                [example.counter-ui :as cnt]
                [matthiasn.systems-toolbox.switchboard :as sb]))

    (enable-console-print!)

    (defonce switchboard (sb/component :client/switchboard))

    (defn init
      []
      (sb/send-mult-cmd
        switchboard
        [[:cmd/init-comp (cnt/cmp-map :client/cnt-cmp)]
         [:cmd/init-comp (store/cmp-map :client/store-cmp)]
         [:cmd/route {:from :client/cnt-cmp :to :client/store-cmp}]
         [:cmd/observe-state {:from :client/store-cmp :to :client/cnt-cmp}]]))

    (init)
#+END_SRC

First, the *switchboard* is created. Then, we send a message to the
switchboard, with a vector containing multiple commands. We start with
initializing the =:client/cnt-cmp= and =:client/store-cmp= components,
which are responsible for UI and state management, respectively. The
order here is not relevant, as these components don't need to know about
each other anyway.

Then, we *route* messages from the UI component to the store component
by using =:cmd/route=. Routing means that a connection is made for all
messages for which there is a handler, so here =:cnt/inc=, =:cnt/dec=,
=:cnt/add= and =:cnt/remove=, as we've seen in the =:handler-map=
earlier. With this, whenever we use the =put-fn= inside the UI and send
a message of any of these types, the store will receive it.

So far so good. Next, we need the UI to observe the state of the store
component, which happens when sending the =:cmd/observe-state= message.
Whenever the state of the=:client/store-cmp= changes, the UI will now
have a copy of the change in it's =local= atom.

That's all there is to it. Now, this example has been quite simple.
However, you can build much more complex applications in the same style.
Very recently, this approach has become much more viable thanks to
*[[https://clojure.org/about/spec][clojure.spec]]*, which is a great
addition to my development toolbox. You should use it in your projects,
too. If you have not heard the latest
*[[http://blog.cognitect.com/cognicast/][Cognicast]]* where Rich Hickey
talks about it, you should do that right now.

Note that not only does *clojure.spec* allow us to validate our
app-specific data structures - it is also used dynamically in the
switchboard when wiring components, so that validation takes application
state into account. This dynamic validation is powerful, and would be
difficult to achieve with a type system. Whenever there's another
=cmp-id= that the switchboard has initialized, the set of possible
values is updated, so that once it comes to =route= and =observe-state=,
only valid component ids can be used. Try changing a component ID and
you'll see an error message that is surprisingly not terrible for
Clojure. Yeah, I don't like typical error messages in Clojure, and
anything that makes the situation better is much appreciated.

Oh, I should also note
*[[https://github.com/bhauman/lein-figwheel][Figwheel]]*. Applications
built with the *systems-toolbox* are compatible with figwheel, with a
page reload on every code change, while preserving application state.
The reload mechanism is very useful during development, especially when
you have some login. It's tedious without, where you have to recreate
the app state after reloading the page so that you can judge the little
change you made. Not so here, you make the change, and the page reloads
automatically, while retaining the application state.

#+CAPTION: Figwheel in Action
[[file:images/redux-counter.gif]]

Also, this is incredibly useful when doing *CSS* changes. Usually, you'd
probably do tiny changes in the developer tools until you have achieved
the desired effect. But with Figwheel, the page will also reload while
retaining app state, typically without any jumpiness.

Have a look and try it out for yourself. For that, I'd like you to clone
the repository and run the application as follows:

=lein run=

And in an additional terminal:

=lein figwheel=

And now go to the store and change what happens when clicking the =inc=
button. Where before, the value would be incremented by one, we could
now have it increment by 11, like this:

#+BEGIN_SRC clojure
  (defn inc-handler
    "Handler for incrementing specific counter"
    [{:keys [current-state msg-payload]}]
    {:new-state
     (update-in
      current-state
      [:counters (:counter msg-payload)]
      #(+ % 11))})
#+END_SRC

After saving =store.cljs=, you'll briefly notice the figwheel logo
overlayed on top of the page, and next, you click the button and
increment the previous counter value, only that now you'll add 11 or
whatever else you chose as the number there in your changed
=inc-handler= function.

You can probably imagine how useful that can be when you build anything
more complex. And over the next couple of chapters, I will show you
different examples of more complex applications using the same pattern,
only then composing more complex behavior out of the same predictable
handler functions. By the way, these handler functions are easily
testable because they are pure, acting on immutable data and returning
new values, rather than mutating some existing state. We'll get to that
in a later chapter.

Now check out the example application, play around with it, and let me
know what you think. The
*[[https://github.com/matthiasn/systems-toolbox][systems-toolbox]]* has
helped me build these applications so far:

- *[[https://github.com/matthiasn/BirdWatch][BirdWatch]]*
- *[[https://github.com/matthiasn/iWasWhere][iWasWhere]]*
- a client project
- *[[https://github.com/matthiasn/systems-toolbox/tree/master/examples/trailing-mouse-pointer][trailing mousepointer example]]*
- *redux counter example*

It may help you build your application, too.

*P.S.* I needed some integration test for the
*[[https://github.com/matthiasn/systems-toolbox-ui][systems-toolbox-ui]]*
library, something running in an actual browser. So I wrote some tests
running the example discussed above, clicking the buttons, and then
asserting that they change as expected. You can run those tests and see
for yourself, the instructions are
*[[https://github.com/matthiasn/systems-toolbox-ui][here]]*.

[fn:1] The links should always point to the latest version in the
       codebase and be in sync with the text in the book chapters. If
       you find that that is not the case, it means I messed up
       somewhere and need your help. Just send me an email to
       [[mailto:matthias.nehlsen@gmail.com][matthias.nehlsen@gmail.com]]
       and I will update the chapter text as quickly as possible.
       Thanks!


#+Latex:\pagebreak
* WebSocket Latency Visualization Example
  :PROPERTIES:
  :CUSTOM_ID: websocket-latency-visualization-example
  :END:

Communication between backend and web applications via
*[[https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API][WebSockets]]*
is an integral part of delivering a rich user experience. With that
addition, it is much easier to push new information to the user at any
given time, without having to resort to constant polling.

But how fast IS that communication? Let's find out. The next sample
application for the
*[[https://github.com/matthiasn/systems-toolbox][systems-toolbox]]*
deals with just that, visualizing the latency for messages sent from
client to server and back.

#+CAPTION: Screenshot
[[file:images/ws-lat-screenshot.png]]

Check out the live demo
*[[http://systems-toolbox.matthiasnehlsen.com/][here]]*; it'll give you
some additional information about the application. There was a previous
version of this example, but with
*[[https://clojure.org/about/spec][clojure.spec]]* released, it was a
good time to revisit this application and have it fully validated.

By the way, *[[https://clojure.org/about/spec][clojure.spec]]* came at a
*crucial time* for me. This kind of validation was missing in the
systems-toolbox (and more broadly in Clojure, too), and that made me
question the whole approach, especially after fighting with annoying
bugs in my latest application,
*[[https://github.com/matthiasn/iWasWhere][iWasWhere]]* (which I'll
introduce in a subsequent chapter). But now with clojure.spec, the
entire class of those annoying bugs is gone for good. In a matter of a
little over a week, I upgraded all my applications plus the
systems-toolbox libraries to use clojure.spec, and I'm now more
convinced about the approach than ever. You *can* build applications
this way, and *stay sane* at the same time.

We'll look into validation in this chapter, too. But let's get started
with the application itself. Here, we have a couple of different
components:

On the client:

- there's the =:client/mouse-cmp= component that shows the position of
  the mouse, both locally and for the message coming back from the
  server
- there's the =:client/store-cmp=, which holds the client-side state
- there's the =:client/histogram-cmp= UI component for visualizing the
  round trip times as histograms
- there's =:client/info-cmp= UI component that shows some information
  about the app
- also, there are components for visualizing message flow, and for
  showing some JVM stats: =:client/observer-cmp= and
  =:client/jvmstats-cmp=

On the server:

- there's the =:server/ptr-cmp= component, which keeps a counter of all
  messages passed through since application startup, and returns each
  mouse position message to the client where it originated, plus, upon
  request, a history of mouse positions from all connected clients
- then, there's also the =:server/metrics-cmp= component for gathering
  some stats about the JVM, which get broadcast to all connected clients

On both sides, there are
*[[https://github.com/ptaoussanis/sente][Sente]]* components for
establishing *bi-directional communication* between client and server.
These ready-to-use components are provided by the
*[[https://github.com/matthiasn/systems-toolbox-sente][systems-toolbox-sente]]*
library, and you can use them in your projects, too, with a simple
import and no more than a handful of lines of code.

The store component on the client, which holds the client-side state, is
then observed by the histogram, the mouse moves, and the info
components; these three render something based on what's in the state
that they observe.

The communication between these components is comparable to what was
introduced in the previous chapter. What's new here is the =sente-cmp=.
Let's have a brief look what
*[[https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API][WebSockets]]*
are. They give us a way to establish a very low latency *bi-directional*
connection between client and server. It's not HTTP but instead its own
protocol. WebSockets are well supported from IE 10 on, and in all other
recent browsers. Some critics say that they may be problematic because
firewalls and reverse proxies might have to be reconfigured. Well, that
might indeed problematic if (and only if) your OPS people are
incompetent. But most likely they are not, so it's only a matter of
communication (and some upfront planning) to get this potential hurdle
out of the way.

Other than that potential issue with your firewall, there appears to be
no downside to using *WebSockets*, and plenty of upsides. You absolutely
need to be able to send messages from server to client at any time if
you want to build a modern, responsive UI. Sure, you could also use
*[[https://en.wikipedia.org/wiki/Server-sent_events][Server-sent Events
(SSE)]]* for the server -> client direction, and send messages from
client to server the way you'd normally do: via REST calls, for each
message. That may work; it may also be too expensive if you want to send
messages often. For the use case in this very example, with the mouse
positions, the user experience would likely be quite poor.

WebSockets are also nice because you get an ordering guarantee, which
would be much harder with REST calls. Another aspect not to
underestimate is that with REST calls, you need to think about
authentication on every single request, where you do it once for a
WebSockets connection.

** :client/mouse-cmp
   :PROPERTIES:
   :CUSTOM_ID: clientmouse-cmp
   :END:

Anyway, let's look at some code, starting with where the messages
originate in our example, the =:client/mouse-cmp= component, and its
respective
*[[https://github.com/matthiasn/systems-toolbox/blob/master/examples/trailing-mouse-pointer/src/cljs/example/ui_mouse_moves.cljs][namespace]]*:

#+BEGIN_SRC clojure
  (ns example.ui-mouse-moves
    (:require [matthiasn.systems-toolbox-ui.reagent :as r]
              [matthiasn.systems-toolbox-ui.helpers :refer [by-id]]))

  ;; some SVG defaults
  (def circle-defaults {:fill "rgba(255,0,0,0.1)
  " :stroke "rgba(0,0,0,0.5)"
                        :stroke-width 2 :r 15})
  (def text-default
    {:stroke "none" :fill "black" :style {:font-size 12}})
  (def text-bold
    (merge text-default {:style {:font-weight :bold :font-size 12}}))

  (defn mouse-hist-view
    "Render SVG group with filled circles from a vector of mouse positions in state."
    [state state-key stroke fill]
    (let [positions (map-indexed vector (state-key state))]
      (when (seq positions)
        [:g {:opacity 0.5}
         (for [[idx pos] positions]
           ^{:key (str "circle" state-key idx)}
           [:circle {:stroke       stroke
                     :stroke-width 2
                     :r            15
                     :cx           (:x pos)
                     :cy           (:y pos)
                     :fill         fill}])])))

  (defn trailing-circles
    "Displays two transparent circles. The position of the circles comes from
     the most recent messages, one sent locally and the other with a roundtrip to
     the server in between. This makes it easier to visually detect any delays."
    [state]
    (let [local-pos (:local state)
          from-server (:from-server state)]
      [:g
       [:circle (merge circle-defaults {:cx (:x local-pos)
                                        :cy (:y local-pos)})]
       [:circle (merge circle-defaults {:cx (:x from-server)
                                        :cy (:y from-server)
                                        :fill "rgba(0,0,255,0.1)"})]]))

  (defn mouse-view
    "Renders SVG with both local mouse position and the last one returned from the
     server, in an area that covers the entire visible page."
    [{:keys [observed local]}]
    (let [state-snapshot @observed
          mouse-div (by-id "mouse")
          update-dim
          #(do (swap! local assoc :width (- (.-offsetWidth mouse-div) 2))
               (swap! local assoc :height (aget js/document "body" "scrollHeight")))]
      (update-dim)
      (aset js/window "onresize" update-dim)
      [:div
       [:svg {:width  (:width @local)
              :height (:height @local)}
        (trailing-circles state-snapshot)
        (when (-> state-snapshot :show-all :local)
          [mouse-hist-view state-snapshot :local-hist
           "rgba(0,0,0,0.06)" "rgba(0,255,0,0.05)"])
        (when (-> state-snapshot :show-all :server)
          [mouse-hist-view state-snapshot :server-hist
           "rgba(0,0,0,0.06)" "rgba(0,0,128,0.05)"])]]))

  (defn init-fn
    "Listen to onmousemove events for entire page, emit message when fired.
    These events are then sent to the server for measuring the round-trip time,
    and also recorded in the local application state for showing the local mouse
    position."
    [{:keys [put-fn]}]
    (aset js/window "onmousemove"
          #(put-fn [:mouse/pos {:x (.-pageX %) :y (.-pageY %)}]))
    (aset js/window "ontouchmove"
          (fn [ev]
            (let [t (aget (.-targetTouches ev) 0)]
              (put-fn [:mouse/pos {:x (.-pageX t) :y (.-pageY t)}])
              #_(.preventDefault ev)))))

  (defn cmp-map
    "Configuration map for systems-toolbox-ui component."
    [cmp-id]
    (r/cmp-map {:cmp-id  cmp-id
                :view-fn mouse-view
                :dom-id  "mouse"
                :init-fn init-fn
                :cfg     {:msgs-on-firehose true}}))
#+END_SRC

Here, we have a UI component that covers the entire page. This is
facilitated by the following *CSS*:

#+BEGIN_SRC css
    #mouse {
        position: absolute;
        top: 0;
        width: 100%;
        pointer-events: none;
        z-index: 10;
        margin-left: -12.5%;
    }
#+END_SRC

Note that we want this transparent element on top, covering the rest of
the page, which is what the =z-index= does. Also, we want
=pointer-events= to reach the elements below, for example for clicking
links or buttons, so we set them to =none=.

Then, in the =init-fn=, we set =ontouchmove= and =ontouchmove= event
handlers, which get called when these events are fired anywhere on the
page. We could also more specifically handle these events in the
component's div, but then the =pointer-events= would not be available
for elements below the =mouse-view= element, such as for clicking a
button. Then, whenever an event is fired, a messaged is sent with the
mouse position. This message will be received by the client side store
directly, and also via the server side, where it'll be enriched with
some additional data.

Then, the rendering of the *[[https://www.w3.org/Graphics/SVG/][SVG]]*
covering the entire page is done in the =mouse-view= function, which
adapts the size of the element when =onresize= element fires. Here, the
=trailing-circles= function is called, which renders the two circles.
This SVG rendering is trivial to achieve with Reagent. You can see that
we just create a group with two circles, each with a distinct position
based on the last known message. Fast movements will then reveal
latency, as you'll see how the messages coming back from the server are
lagging behind. Then, there are two calls to the =mouse-hist-view=
function, which renders either a local history or the last moves of all
clients, as you hopefully have seen when playing around with the live
demo of the application. If not, here's what that looks like:

#+CAPTION: Screenshot
[[file:images/ws-lat-screenshot2.png]]

In the screenshot above, you can see green circles for the mouse moves
captured locally, and charcoal ones for those from all clients.

Let's go through the
*[[https://github.com/matthiasn/systems-toolbox/blob/master/examples/trailing-mouse-pointer/src/cljs/example/ui_mouse_moves.cljs][namespace]]*,
function by function, starting from the bottom:

#+BEGIN_SRC clojure
    (defn cmp-map
      "Configuration map for systems-toolbox-ui component."
      [cmp-id]
      (r/cmp-map {:cmp-id  cmp-id
                  :view-fn mouse-view
                  :dom-id  "mouse"
                  :init-fn init-fn
                  :cfg     {:msgs-on-firehose true}}))      
#+END_SRC

The =cmp-map= function creates the component map, which is like a
blueprint that tells the switchboard how to fire up the component. The
*UI* part is done by calling =r/cmp-map=, which is the main function in
the *systems-toolbox-ui* library. Once the returned map is sent to the
switchboard, a component will be initialized that renders the
=mouse-view= function into the *DOM element* with the ="mouse"= ID.

Then, there's the =init-fn=:

#+BEGIN_SRC clojure
    (defn init-fn
      "Listen to onmousemove events for entire page, emit message when fired.
      These events are then sent to the server for measuring the round-trip time,
      and also recorded in the local application state for showing the local mouse
      position."
      [{:keys [put-fn]}]
      (aset js/window "onmousemove"
            #(put-fn [:mouse/pos {:x (.-pageX %) :y (.-pageY %)}]))
      (aset js/window "ontouchmove"
            (fn [ev]
              (let [t (aget (.-targetTouches ev) 0)]
                (put-fn [:mouse/pos {:x (.-pageX t) :y (.-pageY t)}])
                #_(.preventDefault ev)))))
#+END_SRC

This function takes care of registering handler functions for all mouse
movements (and also touch movement, for that matter) for the entire
window. By doing that here, for the entire window, we can get away with
the =mouse-view= element not getting any mouse movement events, which is
required for still reacting to clicks in elements that are in fact
covered by it, since it spans the entire page. When such an event is
encountered, a =:mouse/pos= message is sent, which then happens to be
received by both the =:client/store-cmp= and the =:server/pos-cmp=. Not
that this component needs to be concerned with that in any way, though -
there's proper decoupling between them.

You can see how those messages are supposed to look like in the
respective *specs*:

#+BEGIN_SRC clojure
    (s/def :ex/x pos-int?)
    (s/def :ex/y pos-int?)

    (s/def :mouse/pos
      (s/keys :req-un [:ex/x :ex/y]))
#+END_SRC

If you still haven't heard Rich Hickey talk about
*[[http://clojure.org/about/spec][clojure.spec]]* on the
*[[http://blog.cognitect.com/cognicast/103][Cognicast]]*, you seriously
need to do that now. *clojure.spec* has many useful properties. Among
them is that you'll immediately know if you've broken your application
with some recent change, as the system would throw an error immediately,
rather than drag that problem along and blow up in your face somewhere
else, where you'll have a hard time figuring out where it originated.
What's also very useful is that when you come back to some code you
wrote some time ago and wanted to know what a message is supposed to
look like, you don't have to print it out and infer what the rules may
be. No, instead you just look at the piece of code that's run when
validating the message, it'll tell you all nitty-gritty details of what
the expectations are. Much nicer.

Next, let's have a look at the =mouse-view= function, which is
responsible for rendering the UI component:

#+BEGIN_SRC clojure
    (defn mouse-view
      "Renders SVG with both local mouse position and the last one returned from the
       server, in an area that covers the entire visible page."
      [{:keys [observed local]}]
      (let [state-snapshot @observed
            mouse-div (by-id "mouse")
            update-dim
            #(do (swap! local assoc :width (- (.-offsetWidth mouse-div) 2))
                 (swap! local assoc :height (aget js/document "body" "scrollHeight")))]
        (update-dim)
        (aset js/window "onresize" update-dim)
        [:div
         [:svg {:width  (:width @local)
                :height (:height @local)}
          (trailing-circles state-snapshot)
          (when (-> state-snapshot :show-all :local)
            [mouse-hist-view state-snapshot :local-hist
             "rgba(0,0,0,0.06)" "rgba(0,255,0,0.05)"])
          (when (-> state-snapshot :show-all :server)
            [mouse-hist-view state-snapshot :server-hist
             "rgba(0,0,0,0.06)" "rgba(0,0,128,0.05)"])]]))
#+END_SRC

Note that this component gets passed a map with the =observed= and
=local= keys. The =observed= key is an atom which holds the state of the
component it observes. Here, this is always the latest snapshot of the
=store-cmp=. The =local= atom contains some local state, such as the
width of the SVG for resizing. Note that we're detecting the width on
every call to the function, and also in the =onresize= callback of
=js/window=. This ensures that the mouse div fills the entire page,
while working with the correct pixel coordinate system. One could
instead also use a viewBox, like this:
={:width "100%" :viewBox "0 0 1000 1000"}=. However, that would not work
correctly in this case as the mouse position would not be aligned with
the circles here.

Next, we have the =trailing-circles= function:

#+BEGIN_SRC clojure
    (defn trailing-circles
      "Displays two transparent circles. The position of the circles comes from
       the most recent messages, one sent locally and the other with a roundtrip to
       the server in between. This makes it easier to visually detect any delays."
      [state]
      (let [local-pos (:local state)
            from-server (:from-server state)]
        [:g
         [:circle (merge circle-defaults {:cx (:x local-pos)
                                          :cy (:y local-pos)})]
         [:circle (merge circle-defaults {:cx (:x from-server)
                                          :cy (:y from-server)
                                          :fill "rgba(0,0,255,0.1)"})]]))
#+END_SRC

This one renders an SVG group with the two circles inside. Then, there
are some defaults for the different elements, which can be merged with
more specific maps as desired:

#+BEGIN_SRC clojure
    (def circle-defaults {:fill "rgba(255,0,0,0.1)" :stroke "black" :stroke-width 2 :r 15})
    (def text-default {:stroke "none" :fill "black" :style {:font-size 12}})
    (def text-bold (merge text-default {:style {:font-weight :bold :font-size 12}}))
#+END_SRC

Finally, there's the =mouse-hist-view= function:

#+BEGIN_SRC clojure
    (defn mouse-hist-view
      "Render SVG group with filled circles from a vector of mouse positions in state."
      [state state-key stroke fill]
      (let [positions (map-indexed vector (state-key state))]
        (when (seq positions)
          [:g {:opacity 0.5}
           (for [[idx pos] positions]
             ^{:key (str "circle" state-key idx)}
             [:circle {:stroke       stroke
                       :stroke-width 2
                       :r            15
                       :cx           (:x pos)
                       :cy           (:y pos)
                       :fill         fill}])])))
#+END_SRC

Here, the history of mouse movements is rendered, either for your local
mouse movements, or the last 1000 from all users. You've seen how that
looks like in the screenshot above.

** :server/ptr-cmp
   :PROPERTIES:
   :CUSTOM_ID: serverptr-cmp
   :END:

That's it for the rendering of the mouse element. The messages emitted
there then get sent both to the client-side and the server-side store
components. Let's discuss the server side first, before looking into the
wiring of the components. It's really short; this is the entire
*[[https://github.com/matthiasn/systems-toolbox/blob/master/examples/trailing-mouse-pointer/src/cljc/example/pointer.cljc][example.pointer]]*
namespace:

#+BEGIN_SRC clojure
    (ns example.pointer
      "This component receives messages, keeps a counter, decorates them with the
       state of the counter, and sends them back. Here, this provides a way to
       measure roundtrip time from the UI, as timestamps are recorded as the message
       flows through the system.
       Also records a recent history of mouse positions for all clients, which the
       component provides to clients upon request.")

    (defn process-mouse-pos
      "Handler function for received mouse positions, increments counter and returns
       mouse position to sender."
      [{:keys [current-state msg-meta msg-payload]}]
      (let [new-state (-> current-state
                          (update-in [:count] inc)
                          (update-in [:mouse-moves]
                                     #(vec (take-last 1000 (conj % msg-payload)))))]
        {:new-state new-state
         :emit-msg (with-meta
                     [:mouse/pos (assoc msg-payload :count (:count new-state))]
                     msg-meta)}))

    (defn get-mouse-hist
      "Gets the recent mouse position history from server."
      [{:keys [current-state msg-meta]}]
      {:emit-msg (with-meta [:mouse/hist (:mouse-moves current-state)] msg-meta)})

    (defn cmp-map
      [cmp-id]
      {:cmp-id      cmp-id
       :state-fn    (fn [_] {:state (atom {:count 0 :mouse-moves []})})
       :handler-map {:mouse/pos      process-mouse-pos
                     :mouse/get-hist get-mouse-hist}
       :opts        {:msgs-on-firehose      true
                     :snapshots-on-firehose true}})
#+END_SRC

At the bottom, you see the =cmp-map=, which again is the map specifying
the component that the switchboard will then instantiate. Inside,
there's the =:state-fn=, which does nothing but create the initial state
inside an atom. Then, there's the =:handler-map=, which here handles the
two message types =:cmd/mouse-pos= and =:mouse/get-hist=.

The =process-mouse-pos= handler function then gets the =current-state=,
the =msg-payload=, and the =msg-meta= inside the map it gets passed as a
single argument, and returns both the =:new-state= and a message to
emit, which is the same message it received, only now enriched by the
=:count= from this component's state. Note that we are reusing the
=msg-meta= from the original message, as this metadata also contains the
=:sente-uid= of the client, which is required to route the message back
to where it originated. There's more information on the metadata; we'll
get to that later. Also, this function maintains the last 1001 positions
from all connected client by taking the last 1000 and conjoining the
received position.

The =get-mouse-hist= handler function returns the history of mouse moves
that's maintained in the =:server/ptr-cmp= back to the client. Once
again, the =:sente-uid= on the metadata contains the requester's ID, so
we pass on the =msg-meta= in the response.

Next, the messages need to get from the UI component to the server, and
back to the client. Here's how that looks like:

[message flow drawing]

** example.core on client side
   :PROPERTIES:
   :CUSTOM_ID: example.core-on-client-side
   :END:

For establishing these connections, let's have a look at the =core=
namespaces on both server and client, starting with the
*[[https://github.com/matthiasn/systems-toolbox/blob/master/examples/trailing-mouse-pointer/src/cljs/example/core.cljs][client]]*:

#+BEGIN_SRC clojure
    (ns example.core
      (:require [example.spec]
                [example.store :as store]
                [example.ui-histograms :as hist]
                [example.ui-mouse-moves :as mouse]
                [example.ui-info :as info]
                [example.metrics :as metrics]
                [example.observer :as observer]
                [matthiasn.systems-toolbox.switchboard :as sb]
                [matthiasn.systems-toolbox-sente.client :as sente]))

    (enable-console-print!)

    (defonce switchboard (sb/component :client/switchboard))

    ; TODO: maybe firehose messages should implicitly be relayed?
    (defn init! []
      (sb/send-mult-cmd
        switchboard
        [[:cmd/init-comp
          #{(sente/cmp-map :client/ws-cmp
                           {:relay-types      #{:mouse/pos
                                                :mouse/get-hist
                                                :firehose/cmp-put
                                                :firehose/cmp-recv
                                                :firehose/cmp-publish-state
                                                :firehose/cmp-recv-state}
                            :msgs-on-firehose true})
            (mouse/cmp-map :client/mouse-cmp)
            (info/cmp-map :client/info-cmp)
            (store/cmp-map :client/store-cmp)
            (hist/cmp-map :client/histogram-cmp)}]
         [:cmd/route {:from :client/mouse-cmp
                      :to   #{:client/store-cmp :client/ws-cmp}}]
         [:cmd/route {:from :client/ws-cmp
                      :to   :client/store-cmp}]
         [:cmd/route {:from :client/info-cmp
                      :to   #{:client/store-cmp :client/ws-cmp}}]
         [:cmd/observe-state {:from :client/store-cmp
                              :to   #{:client/mouse-cmp
                                      :client/histogram-cmp
                                      :client/info-cmp}}]])
      (metrics/init! switchboard)
      (observer/init! switchboard))

    (init!)
#+END_SRC

First, as usual, we create a switchboard. Then, we send messages to the
switchboard, with the blueprints for the components we want the
switchboard to initialize. For the core functionality discussed so far,
only three of them are important: =:client/ws-cmp=, =:client/mouse-cmp=,
and =:client/store-cmp=. We'll look at the other components later.

Note that the switchboard is kept in a =defonce=, which means that it
can't be redefined later on. This is necessary for working with
*[[https://github.com/bhauman/lein-figwheel][Figwheel]]*, as it allows
the switchboard to shut down existing components and fire them up again
after reload, while retaining the previous component state. Otherwise,
without the =defonce=, the old state of each component would be lost as
there would be an entirely new switchboard.

Then, inside the component init block, the =:client/ws-cmp= is fired up
first. This is the WebSockets component provided by the
*[[https://github.com/matthiasn/systems-toolbox-sente][systems-toolbox-sente]]*
library. Here, we specify that only messages of the types =:mouse/pos=
and =:mouse/get-hist= should be relayed to the server.

Next, we wire the components together:

- messages from =:client/mouse-cmp= are sent to both =:client/store-cmp=
  and =:client/ws-cmp=
- messages from =:client/ws-cmp= are sent to both =:client/store-cmp=
  and =:client/jvmstats-cmp=
- messages from =:client/info-cmp= are sent to both =:client/store-cmp=
  and =:client/ws-cmp=
- =:client/mouse-cmp=, =:client/histogram-cmp= and =:client/info-cmp=
  all observe the state of the =:client/store-cmp=
- finally, the =:client/observer-cmp= is attached to the firehose, but
  more about that later when we look at =:client/observer-cmp=.

At the bottom of the namespace, we also fire up the observer and metrics
components. We'll look at that when covering the respective components.

** example.core on server side
   :PROPERTIES:
   :CUSTOM_ID: example.core-on-server-side
   :END:

With the client-side wiring in place, let's look at the server-side
wiring in
*[[https://github.com/matthiasn/systems-toolbox/blob/master/examples/trailing-mouse-pointer/src/clj/example/core.clj][core.clj]]*:

#+BEGIN_SRC clojure
    (ns example.core
      (:require [example.spec]
                [matthiasn.systems-toolbox.switchboard :as sb]
                [matthiasn.systems-toolbox-sente.server :as sente]
                [example.metrics :as metrics]
                [matthiasn.systems-toolbox-observer.probe :as probe]
                [example.index :as index]
                [clojure.tools.logging :as log]
                [clj-pid.core :as pid]
                [example.pointer :as ptr]))

    (defonce switchboard (sb/component :server/switchboard))

    (defn restart!
      "Starts or restarts system by asking switchboard to fire up the provided
       ws-cmp and the ptr component, which handles and counts messages about mouse
       moves."
      []
      (sb/send-mult-cmd
        switchboard
        [[:cmd/init-comp #{(sente/cmp-map :server/ws-cmp index/sente-map)
                           (ptr/cmp-map :server/ptr-cmp)}]
         [:cmd/route {:from :server/ptr-cmp :to :server/ws-cmp}]
         [:cmd/route {:from :server/ws-cmp :to :server/ptr-cmp}]])
      (metrics/start! switchboard)
      #_
      (probe/start! switchboard))

    (defn -main
      "Starts the application from command line, saves and logs process ID. The
       system that is fired up when restart! is called proceeds in core.async's
       thread pool. Since we don't want the application to exit when just because
       the current thread is out of work, we just put it to sleep."
      [& args]
      (pid/save "example.pid")
      (pid/delete-on-shutdown! "example.pid")
      (log/info "Application started, PID" (pid/current))
      (restart!)
      (Thread/sleep Long/MAX_VALUE))
#+END_SRC

Here, just like on the client side, a switchboard is kept in a
=defonce=. Then, we ask the switchboard to instantiate two components
for us, the =:server/ws-cmp= and the =:server/ptr-cmp=, and then wire a
simple message flow together.

We've already discussed the =:server/ptr-cmp= above. The
=:server/ws-cmp= is the server side of the Sente-WebSockets component,
and it takes a configuration map, which you can find in the
*[[https://github.com/matthiasn/systems-toolbox/blob/master/examples/trailing-mouse-pointer/src/clj/example/index.clj][example.index]]*
namespace:

#+BEGIN_SRC clojure
    (def sente-map
      "Configuration map for sente-cmp."
      {:index-page-fn index-page
       :relay-types   #{:mouse/pos :stats/jvm :mouse/hist}})
#+END_SRC

In this configuration map, we tell the component to relay three message
types, =:mouse/pos=, =:stats/jvm=, and =:mouse/hist=. Also, we provide a
function that renders the static HTML that is served to the clients.
Have a look at the namespace to learn more. In particular, watch out for
elements with an ID, such as =[:div#mouse]=,
=[:figure#histograms.fullwidth]=, =[:div#info]=, or =[:div#observer]=.
The client-side application will render dynamic content into these DOM
elements.

Then, also in the server-side =example.core= namespace, there is the
=-main= function, which is the entry point into the application. Here,
we save a PID file, which will contain the process ID, also log the PID,
and =start!= the application. We also start the server-side portion of
the metrics gathering and display, but more about that later.

Finally, we let the main thread sleep until roughly the end of time, or
until the application gets killed, whatever happens first. Well,
=Long/MAX_VALUE= in milliseconds is only until roughly 292 million years
from now, but hey, that should be enough.

** Application Reload from the REPL
   :PROPERTIES:
   :CUSTOM_ID: application-reload-from-the-repl
   :END:

Oh, before I forget, you can also reload the server side on the JVM from
the *[[http://clojure.org/reference/repl_and_main][REPL]]*, without long
startup times, and while retaining application state. Try this:

#+BEGIN_SRC
    $ lein repl

    example.core=> (restart!)
#+END_SRC

This starts the server side application. Now change something, let's say
in the =example.pointer= namespace, for example to print the message
payload in =process-mouse-pos=:

#+BEGIN_SRC clojure
    (defn process-mouse-pos
      "Handler function for received mouse positions, increments counter and returns
       mouse position to sender."
      [{:keys [current-state msg-meta msg-payload]}]
      (let [new-state (-> current-state
                          (update-in [:count] inc)
                          (update-in [:mouse-moves]
                                     #(vec (take-last 1000 (conj % msg-payload)))))]
        {:new-state new-state
         :emit-msg (with-meta
                     [:mouse/pos (assoc msg-payload :count (:count new-state))]
                     msg-meta)}))
#+END_SRC

With this change, all you need to do now is reload the modified
namespace, and then call =restart!= again:

#+BEGIN_SRC
    example.core=> (require '[example.pointer :as ptr] :reload)
    example.core=> (restart!)
#+END_SRC

You will see that the application keeps functioning, while maintaining
component state, with the only difference that now the message payloads
get printed. Magic. Almost as cool as Figwheel, and much better than
having to wait ten seconds for the JVM to start up after every change.
Note that the sente components don't get reloaded by default because of
the =:reload-cmp false= in their config. You can do the same in any of
your components where required.

** :client/store-cmp
   :PROPERTIES:
   :CUSTOM_ID: clientstore-cmp
   :END:

Okay, now we have the message flow from capturing the mouse events to
the server and back. Next, let's look at what happens to those events
when they are back at the client. Processing of the returned data
happens in the
*[[https://github.com/matthiasn/systems-toolbox/blob/master/examples/trailing-mouse-pointer/src/cljs/example/store.cljs][example.store
namespace]]*:

#+BEGIN_SRC clojure
    (ns example.store)

    (defn mouse-pos-handler
      "Handler function for mouse position messages. When message from server:
        - determine the round trip time (RTT) by subtracting the message creation
          timestamp from the timestamp when the message is finally received by the
          store component.
        - determine server side processing time is determined. For this, we can use
          the timestamps from when the ws-cmp on the server side emits a message
          coming from the client and when the processed message is received back for
          delivery to the client.
        - update component state with the new mouse location under :from-server.
       When message received locally, only update position in :local."
      [{:keys [current-state msg-payload msg-meta]}]
      (let [new-state
            (if (:count msg-payload)
              (let [mouse-out-ts (:out-ts (:client/mouse-cmp msg-meta))
                    store-in-ts (:in-ts (:client/store-cmp msg-meta))
                    rt-time (- store-in-ts mouse-out-ts)
                    srv-ws-meta (:server/ws-cmp msg-meta)
                    srv-proc-time (- (:in-ts srv-ws-meta) (:out-ts srv-ws-meta))]
                (-> current-state
                    (assoc-in [:from-server] (assoc msg-payload :rt-time rt-time))
                    (update-in [:count] inc)
                    (update-in [:rtt-times] conj rt-time)
                    (update-in [:server-proc-times] conj srv-proc-time)
                    (update-in [:network-times] conj (- rt-time srv-proc-time))))
              (-> current-state
                  (assoc-in [:local] msg-payload)
                  (update-in [:local-hist] conj msg-payload)))]
        {:new-state new-state}))

    (defn show-all-handler
      "Toggles boolean value in component state for provided key."
      [{:keys [current-state msg-payload]}]
      {:new-state (update-in current-state [:show-all msg-payload] not)})

    (defn mouse-hist-handler
      "Saves the received vector with mouse positions in component state."
      [{:keys [current-state msg-payload]}]
      {:new-state (assoc-in current-state [:server-hist] msg-payload)})

    (defn state-fn
      "Return clean initial component state atom."
      [_put-fn]
      {:state (atom {:count             0
                     :rtt-times         []
                     :network-times     []
                     :server-proc-times []
                     :local             {:x 0 :y 0}
                     :show-all          {:local  false
                                         :remote false}})})

    (defn cmp-map
      "Configuration map that specifies how to instantiate component."
      [cmp-id]
      {:cmp-id      cmp-id
       :state-fn    state-fn
       :handler-map {:mouse/pos    mouse-pos-handler
                     :cmd/show-all show-all-handler
                     :mouse/hist   mouse-hist-handler}
       :opts        {:msgs-on-firehose      true
                     :snapshots-on-firehose true}})
#+END_SRC

The =cmp-map= function once again generates the blueprint for how to
instantiate this component. We specify that the initial component state
is generated by calling the =state-fn=, which is a map with some keys as
you can see above. Then, there are handler functions for three message
types =:mouse/pos=, =:cmd/show-all=, and =:mouse/hist=, which we'll look
at in detail. Finally, there is some configuration in =:opts=, which
specifies that both messages and state snapshots should go on the
firehose. We'll discuss the firehose when looking into the
=:client/observer= component.

The most important handler function in this application is the
=mouse-pos-handler= function. This function receives all =:mouse/pos=
messages, which in this application can come either directly from the
=:client/mouse-cmp= or from the =:server/ptr-cmp=. Where an individual
message comes from is determined by the predicate =(:count msg-payload)=
in the if statement. If that key exists, the message comes from the
server, otherwise it's directly from =:client/mouse-cmp=.

In case the message is local, we do return new-state altered like this:

#+BEGIN_SRC clojure
    (-> current-state
        (assoc-in [:local] msg-payload)
        (update-in [:local-hist] conj msg-payload))
#+END_SRC

First, we set the =:local= key to contain the latest mouse position;
then we add it to the local history.

The branch when the message comes from the server is slightly more
involved:

#+BEGIN_SRC clojure
    (let [mouse-out-ts (:out-ts (:client/mouse-cmp msg-meta))
          store-in-ts (:in-ts (:client/store-cmp msg-meta))
          rt-time (- store-in-ts mouse-out-ts)
          srv-ws-meta (:server/ws-cmp msg-meta)
          srv-proc-time (- (:in-ts srv-ws-meta) (:out-ts srv-ws-meta))]
      (-> current-state
          (assoc-in [:from-server] (assoc msg-payload :rt-time rt-time))
          (update-in [:count] inc)
          (update-in [:rtt-times] conj rt-time)
          (update-in [:server-proc-times] conj srv-proc-time)
          (update-in [:network-times] conj (- rt-time srv-proc-time))))
#+END_SRC

Here, we calculate a few durations, the =rt-time=, which is the entire
roundtrip time, and the =srv-proc-time=, which the duration between the
=:server/ws-cmp= passing the message from the client on, and the same
component encountering the response. For fully understanding this, you
need to know that the *systems-toolbox* automatically timestamps
messages when they are received or sent by any component, and saves that
on the message metadata.

Here's how the metadata looks like when the =:client/store-cmp= receives
a =:mouse/pos= message from the server:

#+BEGIN_SRC clojure
    {:server/ws-cmp    {:out-ts 1467046063466
                        :in-ts  1467046063467}
     :sente-uid        "25450474-0887-4612-b5ad-07d1ca1f4885"
     :server/ptr-cmp   {:in-ts  1467046063467
                        :out-ts 1467046063467}
     :cmp-seq          [:client/mouse-cmp
                        :client/ws-cmp
                        :server/ptr-cmp
                        :server/ws-cmp
                        :client/store-cmp]
     :client/mouse-cmp {:out-ts 1467046063454}
     :client/store-cmp {:in-ts 1467046063506}
     :client/ws-cmp    {:in-ts  1467046063465
                        :out-ts 1467046063488}
     :tag              "61f2f357-3d12-40ff-9827-8a481cf36f75"
     :corr-id          "a31f12e7-33fb-48a8-833b-3d764c2c14bc"}
#+END_SRC

In contrast, this is how it looks like when the message comes directly
from =:client/mouse-cmp=:

#+BEGIN_SRC clojure
    {:cmp-seq          [:client/mouse-cmp :client/store-cmp]
     :client/mouse-cmp {:out-ts 1467046063476}
     :corr-id          "2d32de55-cf1e-4646-8709-0c02c66d260f"
     :tag              "a7ebdac0-ce78-4e47-adbc-0b955efef5b4"
     :client/store-cmp {:in-ts 1467046063478}}
#+END_SRC

Of course, we could have also looked for the existence of the
=:server/ptr-cmp= key on the metadata, rather than looking for the
=:count= key on the payload in the branching logic when determining if a
message comes from the server, it does not matter.

Okay, back to the =:client/store-cmp=. We do a little bit more there:

#+BEGIN_SRC clojure
    (update-in [:network-times] conj (- rt-time srv-proc-time)
#+END_SRC

Here, the RTT times are collected in a sequence so we can use the
individual values as input to the histograms.

Next, there's the =show-all-handler= function to look at:

#+BEGIN_SRC clojure
    (defn show-all-handler
      "Toggles boolean value in component state for provided key."
      [{:keys [current-state msg-payload]}]
      {:new-state (update-in current-state [:show-all msg-payload] not)})
#+END_SRC

This handler toggles the value in the view configuration for showing
either =:local= or the =:remote= history of mouse positions. These are
then used as switches in the =:client/mouse-cmp=, as we've seen above.
Finally, there's the =mouse-hist-handler= function:

#+BEGIN_SRC clojure
    (defn mouse-hist-handler
      "Saves the received vector with mouse positions in component state."
      [{:keys [current-state msg-payload]}]
      {:new-state (assoc-in current-state [:server-hist] msg-payload)})
#+END_SRC

This handler takes care of a sequence of mouse positions received from
the server and stores them in the component state, which is returned
under the =:new-state= key in the returned map. If these are shown is
then dependent on the =:remote= key in the =:show-all= map inside the
component state. Typically, when the =:mouse/hist= is received, this
switch will be set to true, as the request for these values and
switching this key on will have been sent by the =:client/info-cmp= at
the same time. The beauty of the UI component watching the state of
another component which holds the application state is that we don't
have to do anything else. Once the data is back from the server, the
mouse component will just know that it needs to re-render itself, now
with the new data available. This was all to the =:client/store-cmp=, so
let's look into the next component, where the histograms are rendered.
But actually, now might be a good time to take a break and go for a
walk.

** :client/histogram-cmp
   :PROPERTIES:
   :CUSTOM_ID: clienthistogram-cmp
   :END:

Okay, ready? Let's move on. We've got some ground to cover. The
=:client/histogram-cmp= in the
*[[https://github.com/matthiasn/systems-toolbox/blob/master/examples/trailing-mouse-pointer/src/cljs/example/ui_histograms.cljs][example.ui-histograms
namespace]]* makes use of the data we just collected:

#+BEGIN_SRC clojure
    (ns example.ui-histograms
      (:require [matthiasn.systems-toolbox-ui.reagent :as r]
                [matthiasn.systems-toolbox-ui.charts.histogram :as h]
                [matthiasn.systems-toolbox-ui.charts.math :as m]))

    (defn histograms-view
      "Renders histograms with different data sets, labels and colors."
      [{:keys [observed]}]
      (let [state @observed
            rtt-times (:rtt-times state)
            server-proc-times (:server-proc-times state)
            network-times (:network-times state)]
        [:div
         [:div
          [h/histogram-view rtt-times "Roundtrip t/ms" "#D94B61"]
          [h/histogram-view (m/percentile-range rtt-times 99)
           "Roundtrip t/ms (within 99th percentile)" "#D94B61"]
          [h/histogram-view (m/percentile-range rtt-times 95)
           "Roundtrip t/ms (within 95th percentile)" "#D94B61"]]
         [:div
          [h/histogram-view network-times
           "Network time t/ms (within 99th percentile)" "#66A9A5"]
          [h/histogram-view
           (m/percentile-range network-times 95)
           "Network time t/ms (within 95th percentile)" "#66A9A5"]
          [h/histogram-view server-proc-times
           "Server processing time t/ms" "#F1684D"]]]))

    (defn cmp-map
      [cmp-id]
      (r/cmp-map {:cmp-id  cmp-id
                  :view-fn histograms-view
                  :dom-id  "histograms"
                  :cfg     {:throttle-ms           100
                            :msgs-on-firehose      true
                            :snapshots-on-firehose true}}))
#+END_SRC

The most exciting stuff here happens in the histogram namespace of the
*systems-toolbox-ui* library, but we'll get there. There are some things
of interest here anyway. Did you notice the =:throttle-ms= key in the
=:cfg= of the =cmp-map=? This tells the systems-toolbox to deliver new
state snapshots only every 100 milliseconds. This throttling is done
because it is expensive enough to calculate the histograms for us not to
want to do it on every frame. Ten times a second appears to be a good
compromise between feeling alive and saving some CPU cycles.

The rest of this namespace is probably not terribly surprising by now.
The =histograms-view= function, which is the =:view-fn= of this
*systems-toolbox-ui* component, renders a =:div= with six different
=histogram-view=s, which each renders into an SVG with the chart itself.
In some cases, we do some data manipulation first, such as the
=hist/percentile-range= from the library namespace. Notice that there
are two =:div=s inside the parent, each with three elements inside?
That's for the
*[[https://www.w3.org/TR/2016/CR-css-flexbox-1-20160526/][Flexible
Box]]* layout, also known as *flexbox*. The rest of the layout is then
done in
*[[https://github.com/matthiasn/systems-toolbox/blob/master/examples/trailing-mouse-pointer/resources/public/css/example.css][CSS]]*:

#+BEGIN_SRC css
    #histograms {
        margin-bottom: 1em;
    }

    #histograms div div{
        display: flex;
        flex-flow: row;
    }
#+END_SRC

So what happens here is that we have two =flex= elements, each with
=flex-flow: row;= so that each triplet will cover a row inside the
available space.

Okay, that's it in this namespace.
** matthiasn.systems-toolbox-ui.charts.histogram
   :PROPERTIES:
   :CUSTOM_ID: matthiasn.systems-toolbox-ui.charts.histogram
   :END:

The most interesting stuff for rendering the histograms happens in the
*[[https://github.com/matthiasn/systems-toolbox-ui/blob/master/src/cljs/matthiasn/systems_toolbox_ui/charts/histogram.cljs][matthiasn.systems-toolbox-ui.charts.histogram]]*
namespace. Feel free to skip it if you don't particularly care about
constructing
*[[https://en.wikipedia.org/wiki/Scalable_Vector_Graphics][Scalable
Vector Graphics]]*. Also, this is not an introduction to SVG, as that's
not the focus of this book, so I will only describe the construction of
SVGs with *Reagent*, not what an *SVG* is. If you've never worked with
Scalable Vector Graphics, maybe this
*[[https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Introduction][tutorial]]*
will give you a gentler introduction.

Okay, with that being said, let's dive into the code:

#+BEGIN_SRC clojure
    (ns matthiasn.systems-toolbox-ui.charts.histogram
      "Functions for building a histogram, rendered as SVG using Reagent and React."
      (:require [matthiasn.systems-toolbox-ui.charts.math :as m]))

    (def text-default {:stroke "none" :fill "black" :style {:font-size 12}})
    (def text-bold (merge text-default {:style {:font-weight :bold :font-size 12}}))
    (def x-axis-label (merge text-default {:text-anchor :middle}))
    (def y-axis-label (merge text-default {:text-anchor :end}))

    (defn path
      "Renders path with the given path description attribute."
      [d]
      [:path {:fill         :black
              :stroke       :black
              :stroke-width 1
              :d            d}])

    (defn histogram-y-axis
      "Draws y-axis for histogram."
      [x y h mx y-label]
      (let [incr (m/default-increment-fn mx)
            rng (range 0 (inc (m/round-up mx incr)) incr)
            scale (/ h (dec (count rng)))]
        [:g
         [path (str "M" x " " y "l 0 " (* h -1) " z")]
         (for [n rng]
           ^{:key (str "yt" n)}
           [path (str "M" x " " (- y (* (/ n incr) scale)) "l -" 6 " 0")])
         (for [n rng]
           ^{:key (str "yl" n)}
           [:text (merge y-axis-label {:x (- x 10)
                                       :y (- y (* (/ n incr) scale) -4)}) n])
         [:text (let [x-coord (- x 45)
                      y-coord (- y (/ h 3))
                      rotate (str "rotate(270 " x-coord " " y-coord ")")]
                  (merge x-axis-label text-bold {:x         x-coord
                                                 :y         y-coord
                                                 :transform rotate})) y-label]]))

    (defn histogram-x-axis
      "Draws x-axis for histogram."
      [x y mn mx w scale increment x-label]
      (let [rng (range mn (inc mx) increment)]
        [:g
         [path (str "M" x " " y "l" w " 0 z")]
         (for [n rng]
           ^{:key (str "xt" n)}
           [path (str "M" (+ x (* (- n mn) scale)) " " y "l 0 " 6)])
         (for [n rng]
           ^{:key (str "xl" n)}
           [:text (merge x-axis-label {:x (+ x (* (- n mn) scale))
                                       :y (+ y 20)}) n])
         [:text (merge x-axis-label text-bold {:x (+ x (/ w 2))
                                               :y (+ y 48)}) x-label]]))

    (defn insufficient-data
      "Renders warning when data insufficient."
      [x y w text]
      [:text {:x           (+ x (/ w 2))
              :y           (- y 50)
              :stroke      "none"
              :fill        "#DDD"
              :text-anchor :middle
              :style       {:font-weight :bold :font-size 24}} text])

    (defn histogram-view-fn
      "Renders a histogram. Only takes care of the presentational aspects, the
       calculations are done in the histogram-calc function in
       matthiasn.systems-toolbox-ui.charts.math."
      [{:keys [x y w h x-label y-label color min-bins warning] :as args}]
      (let [{:keys [mn mn2 mx2 rng increment bins binned-freq binned-freq-mx]}
            (m/histogram-calc args)
            x-scale (/ w (- mx2 mn2))
            y-scale (/ (- h 20) binned-freq-mx)
            bar-width (/ (* rng x-scale) bins)]
        [:g
         (if (>= bins min-bins)
           (for [[v f] binned-freq]
             ^{:key (str "bf" x "-" y "-" v "-" f)}
             [:rect {:x      (+ x (* (- mn mn2) x-scale) (* v bar-width))
                     :y      (- y (* f y-scale))
                     :fill   color :stroke "black"
                     :width  bar-width
                     :height (* f y-scale)}])
           [insufficient-data x y w warning])
         [histogram-x-axis x (+ y 7) mn2 mx2 w x-scale increment x-label]
         [histogram-y-axis (- x 7) y h (or binned-freq-mx 5) y-label]]))

    (defn histogram-view
      "Renders an individual histogram for the given data, dimension, label and
       color, with a reasonable size inside a viewBox, which will then scale
       smoothly into any div you put it in."
      [data label color]
      [:svg {:width   "100%"
             :viewBox "0 0 400 250"}
       (histogram-view-fn {:data     data
                           :x        80
                           :y        180
                           :w        300
                           :h        160
                           :x-label  label
                           :y-label  "Frequencies"
                           :warning  "insufficient data"
                           :color    color
                           :bin-cf   0.8
                           :min-bins 5
                           :max-bins 25})])
#+END_SRC

Okay, that was a bit involved. But hey, to use a histogram in your
project, all you need is to import this namespace, and then use a
one-liner to plot your histogram (and more chart types to come - feel
free to contribute).

After skim reading the namespace, are you still interested in
constructing charts? Good, then let's go through function by function:

#+BEGIN_SRC clojure
    (defn histogram-view
      "Renders an individual histogram for the given data, dimension, label and
       color, with a reasonable size inside a viewBox, which will then scale
       smoothly into any div you put it in."
      [data label color]
      [:svg {:width   "100%"
             :viewBox "0 0 400 250"}
       (histogram-view-fn {:data     data
                           :x        80
                           :y        180
                           :w        300
                           :h        160
                           :x-label  label
                           :y-label  "Frequencies"
                           :warning  "insufficient data"
                           :color    color
                           :bin-cf   0.8
                           :min-bins 5
                           :max-bins 25})])
#+END_SRC

The =histogram-view= function simply creates a container =:svg= element,
which scales into its parent element through the =:width "100%"=
setting. Also note the =:viewBox "0 0 400 250"=, which allows us to work
with a useful coordinate system that's independent of the size of the
rendered element. Finally, we pass some data to the =histogram-view-fn=,
which we'll look into next.

#+BEGIN_SRC clojure
    (defn histogram-view-fn
      "Renders a histogram. Only takes care of the presentational aspects, the
       calculations are done in the histogram-calc function in
       matthiasn.systems-toolbox-ui.charts.math."
      [{:keys [x y w h x-label y-label color min-bins warning] :as args}]
      (let [{:keys [mn mn2 mx2 rng increment bins binned-freq binned-freq-mx]}
            (m/histogram-calc args)
            x-scale (/ w (- mx2 mn2))
            y-scale (/ (- h 20) binned-freq-mx)
            bar-width (/ (* rng x-scale) bins)]
        [:g
         (if (>= bins min-bins)
           (for [[v f] binned-freq]
             ^{:key (str "bf" x "-" y "-" v "-" f)}
             [:rect {:x      (+ x (* (- mn mn2) x-scale) (* v bar-width))
                     :y      (- y (* f y-scale))
                     :fill   color :stroke "black"
                     :width  bar-width
                     :height (* f y-scale)}])
           [insufficient-data x y w warning])
         [histogram-x-axis x (+ y 7) mn2 mx2 w x-scale increment x-label]
         [histogram-y-axis (- x 7) y h (or binned-freq-mx 5) y-label]]))
#+END_SRC

Above, we render an
*[[https://developer.mozilla.org/en/docs/Web/SVG/Element/g][SVG g
element]]*, which contains the histogram. Before we can render the bars
of the histogram, we need to calculate a few things from the provided
data, which happens in the first line in the =let= binding:

={:keys [mn mn2 mx2 rng increment bins binned-freq binned-freq-mx]} (m/histogram-calc args)=

We will look into the calculations in the next section. For the
dicussion here, we only need to know what each one does. =mn= is the
minimum value in the data. =m2= is the minimum rounded down to the next
increment, as it's not always useful to start the x-axis from zero. Let
me show you an example:

#+CAPTION: 1000 ms delay
[[file:images/histogram1000ms.png]]

Here, all our values are between 1000 and 1050 milliseconds. The
histogram would be fairly useless if the x-axis started at zero because
the bars would be so thin that we probably couldn't even see them, let
alone tell apart.

I> We will look at creating the delay of 1000ms for each message in a
subsequent chapter when discussing the *systems-toolbox* messaging
model.

Next, we have =rng=, which is the distance between the minimum and the
maximum value. Then, there's the =increment=. This is the distance
between the ticks on the x-axis, such as =10=, =25=, or also =500=,
depending on the range of the provided =data=. =bins= is the number of
bins in the histogram, each of which will be represented as a bar.
=binned-freq= is contains the frequencies per bin. Finally,
=binned-freq-mx= is the maximum frequency in any of the bins, which is
used to determine the scale on the y-axis.

With those values, we can calculate the =x-scale= and =y-scale=, which
will be used to translate positions into the given coordinate system.
Finally, we can determine the width of each bar, by dividing the product
of =rng= and =x-scale= through the number of =bins=.

With those calculations completed, we can render the histogram into a
=:g= element. Here, the bars are only displayed if there are enough
bins. Otherwise, we display ="insufficient data"=. The number of bins is
configured in the =:min-bins= key of the argument map. When called from
the =histogram-view=, I've chosen a minimum of five bins. This value is
entirely arbitrary but seems to work fairly well. Less than five bins
look stupid and don't provide much meaningful information either.

If the data is deemed sufficient, we render a vertical bar as a =:rect=
for each bin. This rendering happens in a
*[[https://clojuredocs.org/clojure.core/for][for-comprehension]]*, as
you've already seen in the previous chapter. Of importance here is the
=:key= on each elements' metadata. While we would get by without,
*React* needs this key to work more efficiently by reusing elements in
the next render cycle. Without assigning the keys, the browser needs to
do more work and React prints long and ugly warnings in the browser's
console.

Then, we render the *x-axis* by calling =histogram-x-axis=, and the
*y-axis* in =histogram-y-axis=.

The functions for rendering the axes are fairly straightforward. Here's
the =histogram-x-axis= function:

#+BEGIN_SRC clojure
    (defn histogram-x-axis
      "Draws x-axis for histogram."
      [x y mn mx w scale increment x-label]
      (let [rng (range mn (inc mx) increment)]
        [:g
         [path (str "M" x " " y "l" w " 0 z")]
         (for [n rng]
           ^{:key (str "xt" n)}
           [path (str "M" (+ x (* (- n mn) scale)) " " y "l 0 " 6)])
         (for [n rng]
           ^{:key (str "xl" n)}
           [:text (merge x-axis-label {:x (+ x (* (- n mn) scale))
                                       :y (+ y 20)}) n])
         [:text (merge x-axis-label text-bold {:x (+ x (/ w 2))
                                               :y (+ y 48)}) x-label]]))
#+END_SRC

The mechanism here will probably look fairly familiar by now:

- there's a group inside the =:g= element
- next, there's the axis itself, rendered by the =path= function
- there's a =for=-comprehension for the ticks on the axis, which also
  use the =path= function
- there's another =for=-comprehension for the axis labels (the numbers
  associated with a tick)
- finally, there's a label, which in our example application here would,
  for example, be ="Roundtrip t/ms"=

Both =for=-comprehensions make use of the range =rng=, which is a
sequence from =mn= to one larger than =mx=, with the step size
=increment=. All these values depend on the data and are computed
individually, as we will see in the next section.

Here's the aforementioned =path= function, which is only a thin wrapper
over =:path=, with a few defaults, so we save some typing later on:

#+BEGIN_SRC clojure
    (defn path
      "Renders path with the given path description attribute."
      [d]
      [:path {:fill         :black
              :stroke       :black
              :stroke-width 1
              :d            d}])
#+END_SRC

The =histogram-y-axis= is somewhat similar, only that here we can
calculate more in the function, as we don't need =scale= or =rng= in the
calculation of the bins:

#+BEGIN_SRC clojure
    (defn histogram-y-axis
      "Draws y-axis for histogram."
      [x y h mx y-label]
      (let [incr (m/default-increment-fn mx)
            rng (range 0 (inc (m/round-up mx incr)) incr)
            scale (/ h (dec (count rng)))]
        [:g
         [path (str "M" x " " y "l 0 " (* h -1) " z")]
         (for [n rng]
           ^{:key (str "yt" n)}
           [path (str "M" x " " (- y (* (/ n incr) scale)) "l -" 6 " 0")])
         (for [n rng]
           ^{:key (str "yl" n)}
           [:text (merge y-axis-label {:x (- x 10)
                                       :y (- y (* (/ n incr) scale) -4)}) n])
         [:text (let [x-coord (- x 45)
                      y-coord (- y (/ h 3))
                      rotate (str "rotate(270 " x-coord " " y-coord ")")]
                  (merge x-axis-label text-bold {:x         x-coord
                                                 :y         y-coord
                                                 :transform rotate})) y-label]]))
#+END_SRC

Other than calculating the =rng= and =scale= locally inside the
=let=-binding, the function is pretty much the same as the
=histogram-y-axis= function, with the other difference that the paths
and labels are rotated, as obviously, the y-axis is vertical. If you
want to learn more about *SVG* paths, I'd recommend either one of the
tutorials out there, or to just modify the values and see how that
affects the histogram. For that, I would copy the code over into the
sample app and use *Figwheel* for immediate feedback. Otherwise, you'd
have to publish the library locally after each change, and then
recompile the sample application, which takes away all the fun. Tight
feedback loops are important.

This is all for the rendering of the histogram. In the next chapter,
I'll guide you through the math behind the calculations used here.

If you want to use a histogram in your application and are happy with
the defaults, you can simply call the =histogram-view= function. Or, if
you want more fine-grained control, you can copy this function and use
the values you desire. Or, you can, of course, use this whole thing as
an inspiration and come up with your own chart. In that case, please
consider submitting a PR, others might benefit from that, too.

Questions? Send me an email; I'm happy to help.
[[mailto:matthias.nehlsen@gmail.com][matthias.nehlsen@gmail.com]]
** matthiasn.systems-toolbox-ui.charts.math
   :PROPERTIES:
   :CUSTOM_ID: matthiasn.systems-toolbox-ui.charts.math
   :END:

In the =matthiasn.systems-toolbox-ui.charts.histogram= namespace, we
used a handful of mathematical helper functions. These live in the
*[[https://github.com/matthiasn/systems-toolbox-ui/blob/master/src/cljc/matthiasn/systems_toolbox_ui/charts/math.cljc][matthiasn.systems-toolbox-ui.charts.math]]*
namespace. This is actually a
*[[https://github.com/clojure/clojurescript/wiki/Using-cljc][cljc]]*
file, which allows us to target both *Clojure* and *ClojureScript*. This
is very useful for *testing* the functions on the *JVM*, which I much
prefer over testing in the browser. Here's the entire namespace:

#+BEGIN_SRC clojure
    (ns matthiasn.systems-toolbox-ui.charts.math)

    (defn mean
      "From: https://github.com/clojure-cookbook/"
      [coll]
      (let [sum (apply + coll)
            count (count coll)]
        (if (pos? count)
          (/ sum count)
          0)))

    (defn median
      "Modified from: https://github.com/clojure-cookbook/
       Adapted to return nil when collection empty."
      [coll]
      (let [sorted (sort coll)
            cnt (count sorted)
            halfway (quot cnt 2)]
        (if (empty? coll)
          nil
          (if (odd? cnt)
            (nth sorted halfway)
            (let [bottom (dec halfway)
                  bottom-val (nth sorted bottom)
                  top-val (nth sorted halfway)]
              (mean [bottom-val top-val]))))))

    (defn interquartile-range
      "Determines the interquartile range of values in a sequence of numbers.
       Returns nil when sequence empty or only contains a single entry."
      [sample]
      (let [sorted (sort sample)
            cnt (count sorted)
            half-cnt (quot cnt 2)
            q1 (median (take half-cnt sorted))
            q3 (median (take-last half-cnt sorted))]
        (when (and q3 q1) (- q3 q1))))

    (defn percentile-range
      "Returns only the values within the given percentile range."
      [sample percentile]
      (let [sorted (sort sample)
            cnt (count sorted)
            keep-n (Math/ceil (* cnt (/ percentile 100)))]
        (take keep-n sorted)))

    (defn freedman-diaconis-rule
      "Implements approximation of the Freedman-Diaconis rule for determing bin size
       in histograms: bin size = 2 IQR(x) n^-1/3 where IQR(x) is the interquartile
       range of the data and n is the number of observations in sample x. Argument
       is expected to be a sequence of numbers."
      [sample]
      (let [n (count sample)]
        (when (pos? n)
          (* 2 (interquartile-range sample) (Math/pow n (/ -1 3))))))

    (defn round-up [n increment] (* (Math/ceil (/ n increment)) increment))
    (defn round-down [n increment] (* (Math/floor (/ n increment)) increment))

    (defn best-increment-fn
      "Takes a seq of increments, a desired number of intervals in histogram axis,
       and the range of the values in the histogram. Sorts the values in increments
       by dividing the range by each to determine number of intervals with this
       value, subtracting the desired number of intervals, and then returning the
       increment with the smallest delta."
      [increments desired-n rng]
      (first (sort-by #(Math/abs (- (/ rng %) desired-n)) increments)))

    (defn default-increment-fn
      "Determines the increment between intervals in histogram axis.
       Defaults to increments in a range between 1 and 5,000,000."
      [rng]
      (if rng
        (let [multipliers (map #(Math/pow 10 %) (range 0 6))
              increments (flatten (map (fn [i] (map #(* i %) multipliers))
                                       [1 2.5 5]))
              best-increment (best-increment-fn increments 5 rng)]
          (if (zero? (mod best-increment 1))
            (int best-increment)
            best-increment))
        1))

    (defn histogram-calc
      "Calculations for histogram."
      [{:keys [data bin-cf max-bins increment-fn]}]
      (let [mx (apply max data)
            mn (apply min data)
            rng (- mx mn)
            increment-fn (or increment-fn default-increment-fn)
            increment (increment-fn rng)
            bin-size (max (/ rng max-bins) (* (freedman-diaconis-rule data) bin-cf))
            binned-freq (frequencies (map (fn [n] (Math/floor (/ (- n mn) bin-size)))
                                          data))]
        {:mn             mn
         :mn2            (round-down (or mn 0) increment)
         :mx2            (round-up (or mx 10) increment)
         :rng            rng
         :increment      increment
         :binned-freq    binned-freq
         :binned-freq-mx (apply max (map (fn [[_ f]] f) binned-freq))
         :bins           (inc (apply max (map (fn [[v _]] v) binned-freq)))}))
#+END_SRC

The first two functions here, =mean= and =median=, are borrowed from the
*[[https://github.com/clojure-cookbook/%22][Clojure Cookbook]]*. I've
adapted =median= to return =nil= when the collection is empty, as that's
useful further on. I've taken those two functions because they are
useful in my implementation of the
*[[https://en.wikipedia.org/wiki/Interquartile_range][interquartile
range]]*:

#+BEGIN_SRC clojure
    (defn interquartile-range
      "Determines the interquartile range of values in a sequence of numbers.
       Returns nil when sequence empty or only contains a single entry."
      [sample]
      (let [sorted (sort sample)
            cnt (count sorted)
            half-cnt (quot cnt 2)
            q1 (median (take half-cnt sorted))
            q3 (median (take-last half-cnt sorted))]
        (when (and q3 q1) (- q3 q1))))
#+END_SRC

The =interquartile-range= function takes a sample, which is a sequence
of numbers. If this sequence is empty, =nil= is returned. Otherwise, we
=sort= the sequence, =count= it, and then take the =half-cnt=, which is
the =floor= of dividing the =cnt= by two. This is the number of items in
half the data, minus the halfway point if there is one (when =cnt= is
odd). Then the values =q1= and =q3= are defined as the =median= of the
first or last half of the values, respectively. Finally, the IQR is
returned, which is the difference between =q1= and =q3=, and thus the
range of half the data. The interquartile range is something we need to
determine when computing the bin size via the
*[[https://en.wikipedia.org/wiki/Freedman%E2%80%93Diaconis_rule][Freedman-Diaconis
Rule]]*:

#+BEGIN_SRC clojure
    (defn freedman-diaconis-rule
      "Implements approximation of the Freedman-Diaconis rule for determing bin size
       in histograms: bin size = 2 IQR(x) n^-1/3 where IQR(x) is the interquartile
       range of the data and n is the number of observations in sample x. Argument
       is expected to be a sequence of numbers."
      [sample]
      (let [n (count sample)]
        (when (pos? n)
          (* 2 (interquartile-range sample) (Math/pow n (/ -1 3))))))
#+END_SRC

The
*[[https://en.wikipedia.org/wiki/Freedman%E2%80%93Diaconis_rule][Freedman-Diaconis
rule]]* is fairly simply, once we have implemented the IQR:

- determine the IQR
- multiply it by 2
- multiply it by the cube root of n, the count of items

Following these steps gives us a suggested size of the bins in a
histogram, which can then be used to determine the number of bins and
thus the number of bars to display in our histogram.

Then, there's also the =percentile-range= function:

#+BEGIN_SRC clojure
    (defn percentile-range
      "Returns only the values within the given percentile range."
      [sample percentile]
      (let [sorted (sort sample)
            cnt (count sorted)
            keep-n (Math/ceil (* cnt (/ percentile 100)))]
        (take keep-n sorted)))
#+END_SRC

This function helps when trying to get rid of outliers, which may or may
not be helpful in your data. Here, it sometimes helps, for example when
all values are in the low hundreds, and there's a single outlier in the
thousands, as that outlier would otherwise lead to bins that are too
large, with many empty bins. As with all visualization, it depends on
the data and requires some experimentation.

Next, there are helpers for determining the intervals at which to put
the ticks in the histogram axes:

#+BEGIN_SRC clojure
  (defn best-increment-fn
    "Takes a seq of increments, a desired number of intervals in histogram
    axis, and the range of the values in the histogram. Sorts the values
    in increments by dividing the range by each to determine number of
    intervals with this value, subtracting the desired number of
    intervals, and then returning the increment with the smallest delta."
    [increments desired-n rng]
    (first (sort-by #(Math/abs (- (/ rng %) desired-n)) increments)))

  (defn default-increment-fn
    "Determines the increment between intervals in histogram axis.
    Defaults to increments in a range between 1 and 5,000,000."
    [rng]
    (if rng
      (let [multipliers (map #(Math/pow 10 %) (range 0 6))
            increments (flatten (map (fn [i] (map #(* i %) multipliers))
                                     [1 2.5 5]))
            best-increment (best-increment-fn increments 5 rng)]
        (if (zero? (mod best-increment 1))
          (int best-increment)
          best-increment))
      1))
#+END_SRC

This is an interesting problem. Of course, we could hardwire the
increments between the ticks, but then the histogram would hardly be
reusable. My initial approach was something this:

#+BEGIN_SRC clojure
    (defn default-increment-fn
      [rng]
      (cond (> rng 20000) 5000
            (> rng 8000) 2000
            (> rng 3000) 1000
            (> rng 1500) 500
            (> rng 900) 200
            (> rng 400) 100
            (> rng 200) 50
            (> rng 90) 20
            :else 10))
#+END_SRC

Depending on the range =rng=, I would select different spacing between
the ticks on an axis. But that's not general enough. So what I came up
with instead is this:

- generate some multipliers, such as
  =(1.0 10.0 100.0 1000.0 10000.0 100000.0)=
- multiply each with =1=, =2.5= and =5=, then flatten those result
  vectors
- then, with this sequence of possible increments, and a target value of
  five ticks (which look good in a histogram IMHO), call the
  =best-increment= function
- there, the candidate increments are sorted by the delta between the
  desired number of ticks and the number of ticks we'd get with the
  respective increment
- the first of these sorted values is returned, which is the one with
  the smallest delta

This approach is much more generic and seems to work well.

D> I'm always amazed that we can do all these calculations whenever
there's a change in the data. The browser has become a powerful
environment these days indeed.

Finally in this namespace, there's the =histogram-calc= function:

#+BEGIN_SRC clojure
  (defn histogram-calc
    "Calculations for histogram."
    [{:keys [data bin-cf max-bins increment-fn]}]
    (let [mx (apply max data)
          mn (apply min data)
          rng (- mx mn)
          increment-fn (or increment-fn default-increment-fn)
          increment (increment-fn rng)
          bin-size (max (/ rng max-bins)
                        (* (freedman-diaconis-rule data) bin-cf))
          binned-freq
          (frequencies (map (fn [n] (Math/floor (/ (- n mn) bin-size)))
                            data))]
      {:mn             mn
       :mn2            (round-down (or mn 0) increment)
       :mx2            (round-up (or mx 10) increment)
       :rng            rng
       :increment      increment
       :binned-freq    binned-freq
       :binned-freq-mx (apply max (map (fn [[_ f]] f) binned-freq))
       :bins           (inc (apply max (map (fn [[v _]] v) binned-freq)))}))
#+END_SRC

This function does all the required calculations to get the data into
the shape that's required for the actual rendering of the histogram:

- find min value =mn=, max value =mx=, and range of the data =rng=
- calculate =increment= between ticks on the x-axis (note that you can
  specify your own function for finding the increments here)
- determine size of the bins =bin-size=
- put values into bins in =binned-freq=
- find max frequency in bins (for scaling)
- find number of bins (including empty ones)

I> Okay, that's all in this namespace. While the material convered here
is not strictly related to the rest of the book, I hope you found it
interesting nonetheless. Also, we will use the histograms later in the
book when looking into observability of systems, and it never hurts to
understand your tools a little better.

#+Latex:\pagebreak
* Introduction
  :PROPERTIES:
  :CUSTOM_ID: introduction
  :END:

Back in 2014, I had this cute little side project on GitHub called
*[[https://github.com/matthiasn/BirdWatch][BirdWatch]]* for observing a
live stream of Tweets. I had started writing it in
*[[http://www.scala-lang.org/][Scala]]* on the server side and using
*[[https://angularjs.org/][AngularJS]]* on the client side. The project
had gained a fair amount interest on GitHub -- however, at that point, I
had unfortunately fallen out of love with both. At the same time, I had
developed a curiosity for *[[https://clojure.org/][Clojure]]* and LISP.
So I thought, I might as well rewrite the project using Clojure and
ClojureScript and see where that would take me.

What I had found was a beautiful language but not a lot of shared
knowledge on how to build complex systems with it. Some time ago, I had
read books about
*[[https://en.wikipedia.org/wiki/Communicating_sequential_processes][Communicating
Sequential Processes (CSP)]]* so
*[[https://github.com/clojure/core.async][core.async]]* was a natural
candidate for building decoupled systems. A first version of the
rewritten application relied only on
*[[https://github.com/clojure/core.async][core.async]]* for moving
messages around, but I was missing enough structure for building an
application with it. I found Stuart Sierra's
*[[https://github.com/stuartsierra/component][component library]]* and
refactored the server-side application using components. However, I
found it rather tedious to build applications that way, especially when
core.async was involved. I'm not saying that the component library is a
bad approach, but I was interested in building a different kind of
system, and this library did not fit the bill.

I wanted less boilerplate than was required when using the component
library together with core.async. I also wanted to build systems that
are observable by default. While I find CSP to be an excellent
conceptual underpinning for creating distributed systems, I found that
core.async was lacking in observability, which I consider crucial to
being able to reason about a system. I found myself writing logging
statements for every component to gain any insight. But how awful is
logging for following asynchronous messages through a system? Do you
like inserting log statements everywhere when writing software, and then
removing them when you clean up the code? Sure, you could have all these
only log in DEBUG mode for a particular component. But then when trying
to find an issue in production, do you have the luxury to restart the
application every time you reconsider what you want to be logged, always
considering performance and your sanity? I think that's not right. We're
dealing with immutable data structures here. Once they exist, they are
cheap to pass around, including to some runtime-configurable way of
following messages through the system you're building and hopefully
running. For that purpose, I built the inspect library, which you can
find on GitHub. That seemed like a good idea for a moment, but it was
still lacking. First of all, I still had to insert the inspect
statements manually, just like I had to with log statements. But why?
Observing component in- and output is such a mundane thing to do that
any component I built should automatically have it, with zero extra
lines. Also, messages alone don't suffice when trying to observe any
running systems. Let's say such a system consists of components that
take messages from conveyor belts, process them and potentially output
other messages on yet other conveyor belts. Then there are four distinct
things I want to know when observing such subsystems:

1) what does input look like,
2) how does the component state look like before and after receiving the
   message,
3) what's the output from a component, and
4) what's the structure of the running system.

I would find it very helpful to be able to answer these questions for
any given component in the system at a glance. It should not matter if
it's the production system or a local development version of the same.
That would be useful when revisiting code written a long time ago, like
say a couple of weeks, and also when coming into a new project and
mentally mapping the system for the first time.

The *[[https://github.com/matthiasn/inspect][inspect**]]* library only
addressed a) and c), and I realized that more drastic steps were
necessary for solving b) and d). For that, I am working on *Inspect V2*,
which makes use of the underlying assumptions of this library, and which
I will introduce as the book progresses.

Without further ado, I now invite you to have a look at my initial
component and core.async approach. You may find the code tedious and
repetitive, but that's okay, I feel the same way. On a tech radar, I
would place this approach on hold.

Following the chapters on my initial approach, which you may read in
detail or skim read as you like, I will introduce the systems-toolbox
library, which we're using for building a commercial application.
Hopefully, you will also find this library useful for your projects. And
if not, you may still find the approach of building tools as the first
step to application-building interesting.

So far, I'm happy with how things have developed, but there's still a
lot to do to get closer to the vision of a system that's observable in a
meaningful way during runtime. After all, I firmly believe that the map
is not the territory and that the behavior of any complex system is not
predictable from looking at a blueprint alone. The code is just that, a
blueprint. Issues with any construction will come out when using it;
tests only help so much as they can only reveal what we already know to
look for in the first place. My thinking there has been influenced by a
*Systems Thinking* approach, which keeps informing many decisions in the
development of the systems-toolbox library. You'll find the concepts
throughout the book, and there's also a gentle introduction to Systems
Thinking the opening part of the book.

#+Latex:\pagebreak
* What's in this book?
  :PROPERTIES:
  :CUSTOM_ID: whats-in-this-book
  :END:

This book is a book about Clojure and it is also a book about systems.
What is a system? Let's ask an expert in the discipline of *systems
thinking*:

#+BEGIN_QUOTE
  A system isn't just any old collection of things. A system is an
  interconnected set of elements that is coherently organized in a way
  that achieves something. If you look at that definition closely for a
  minute, you can see that a system must consist of three kinds of
  things: elements, interconnections, and a function or purpose.
  /Donatella Meadows (2008)/[fn:1]
#+END_QUOTE

In this book, we will discuss multiple systems that together form other
systems or that somehow interact with each other. For example, the
BirdWatch application that we will discuss is a system as a whole. This
system is then made up of other (sub-)systems that communicate with each
other. Twitter is another system, where the purpose of BirdWatch is to
observe the system that is Twitter, and that manipulates observed events
in some (potentially useful) way. In order to obtain a better knowledge
of the BirdWatch system, we will have to observe it, and we will have to
stress test it; otherwise, our knowledge of this system will remain
shallow. For that, we will create yet another systems for monitoring and
also for load testing, each again with observable properties.

The discussion of systems in the context of software is likely relevant
no matter what language you are using. The actual code in this book will
be in Clojure, but please do not be discouraged if you don't know
Clojure just yet. Clojure is a beautifully simple language, and I have
been fascinated from the first moment I laid eyes on it. However, what
remained a mystery to me for most of the time was how to build more
complex systems. I started researching the options that would allow me
to structure an arbitrarily complex application in a way that is *easy
to understand and maintain*. Here is what I found.

In this book, we will build a system in Clojure that processes streaming
data and visualizes different insights into the data in a browser. All
visualizations of data display information in (near) real-time.

The sample implementation that we will use is the
*[[https://github.com/matthiasn/BirdWatch][BirdWatch]]* application -- a
project I have started in Scala with AngularJS on the client side, but
that I then switched over to an all-Clojure/ClojureScript
implementation.

#+CAPTION: Screenshot
[[file:images/screenshot.png]]

This application subscribes to the
*[[https://dev.twitter.com/docs/streaming-apis][Twitter Streaming API]]*
for all tweets that contain one or more terms out of a set of terms and
makes the tweets searchable through storing them in ElasticSearch. All
search results are updated in the browser when new matching tweets come
in through the streaming data source.

A live version of the Clojure version of this application is available
*[[http://birdwatch2.matthiasnehlsen.com/#*][here]]*.

Over the course of this book, we will follow the data and explore parts
of the system in the same order that the streaming data flows through
the system.

There has been a
*[[http://matthiasnehlsen.com/blog/2014/09/24/Building-Systems-in-Clojure-1/][series
of articles]]* that attempted to explain different aspects of the
system, but I think that a book is a much better artifact to work on
when trying to explain this application than a series of blog articles.

Please join me on this journey as I explore the problem further and at
the same time write a book about it. The book will begin with a
description of the current architecture, both on the server and the
client side. Later on, we will put the design to the test, come up with
a load testing strategy and look at ways of improving performance. Most
likely, we will also go through some refactoring of the current
architecture and add some functionality.

I am looking forward to a fun project and a lively discussion about all
aspects of building a system in Clojure.

Cheers, Matthias

[fn:1] Meadows, Donatella H. (2008) /Thinking in Systems: A Primer/ -
       Page 11

#+Latex:\pagebreak
* Why am I writing this book?
  :PROPERTIES:
  :CUSTOM_ID: why-am-i-writing-this-book
  :END:

My first professional work experiences were in healthcare IT, where I
was architecting workflows between healthcare systems. All that was
based on pretty high-level HL7 messages. Take for example an order
message, for an MRI scan. The order is sent by the Hospital Information
system and received by the Radiology Information System. The patient
data is then provided to PACS (Picture Archiving and Communication
System) and the modality (MRI-scanner, CAT, Ultrasound, whatever) via a
DICOM worklist. Once an examination begins, this status change (open,
started, completed) is communicated back to RIS via MPPS (Modality
Performed Procedure Step). Once the exam is complete, it is put into the
radiologists' worklist. The assigned radiologist then dictates her
findings into speech recognition software (assigned to patient ID and
procedure ID). The report together with selected key images is then
routed to the EMR (Electronic Medical Record). In parallel, a billing
message is sent to HIS/accounts receivable.

After doing that for a few years, I was bored and wanted to write
software myself. While doing my Master's, I did a 6-month internship
with Microsoft at the Healthcare Innovation Lab, processing
aforementioned HL7 messages in a C# application, while using Windows
Workflow Foundation for orchestration. Once again, I was working with
high-level concepts, which I like. I stayed at Microsoft for another
year on a J1 visa and continued to work on high-level message
orchestration and alerting. I can totally recommend doing an internship
or working there. I'm just afraid it doesn't exist in the same form any
longer.

After the visa was up, I had to go back home to Germany as this was in
the middle of the financial crisis, with a general hiring freeze. I
started familiarizing myself with Play Framework and Scala at the time
and thought that would be the way to go. After doing a freelance project
with it, I applied for a job as a Scala developer in Amsterdam. I wanted
to have something to show, as the previous project was an internal
application that I was not at liberty to show as a reference. So I
started working on the BirdWatch application, just to have something to
use as a reference. I wanted to use real-time data source and visualize
that data it in a browser. The Twitter Streaming API seemed like a good
candidate, so I wrote an application that consumes that API and displays
some visualizations in a browser.

Then, I got the job I was interviewing for, and I was miserable. I was
expected to perform a minor version bump of the Spray library in the
dependencies of that application. That thing blew up in over 60 places.
The compilation output was basically a bloodbath in red error messages.
That alone was a reason to run away. Listen to Rich Hickey or Brian
Goetz and how they appreciate that what's out can't easily be changed
because PEOPLE ARE USING IT. I have nothing to add, except that I agree
whole-heartedly.

With Clojure, my experience has been that I find a library that's three
years old, but hey, I import it, and it works flawlessly. With Scala,
the exact opposite has been the case. The experience with the minor
version bump in Spray has been the norm rather than the exception.

But the was an entirely different reason why I wanted to run away, and
that was the abstraction level that Spray was dealing with. I don't know
about you, but when I want a car, I get a car and not an
assemble-yourself-kit that may or may not result in a car when
assembled, depending on your car-making skill level. Everything I saw
was so ridiculously low-level, coming from my background of building
high-level message orchestration.

At the same time, and this did make things easier for me, I had
discovered Clojure. I think I read Hackers & Painters and The Joy of
Clojure in parallel. I realized that systems could be built in a way
that is much easier to reason about, both because of a beautifully
simple, LISP-y language and because of a higher level of abstraction
that allows us to pass messages in the form of maps, process them and
orchestrate their flow through a complex system.

I quit the job around 3.5 months later. At the time, a publisher had
just recently approached me to write a book about AngularJS, so I
decided to do the book rather than for the job I had just started.

After working on the book for two months, I began working as a freelance
Scala developer on a server-side e-commerce application. This system was
Play Framework and Akka. My experience there was much better than in the
previous situation, and it was also much, much better paid. Yeah, you
can actually build complex application in Scala, but I still didn't
quite like the level of abstraction, dealing with low-level actors.
After doing that for eight months or so, I decided that it was time to
finally give Clojure a real try, to see if my hunch was right that I
could actually enjoy developing software once I made a switch. Scala
wasn't it for my happiness, but you can read more about that in my
*[[http://t.co/6Bscwstjho][Farewell Letter to a Programming Language]]*.

I wanted to give Clojure a shot, so I started re-writing my BirdWatch
application, which at the time was a Play Framework / Scala backend with
either an AngularJS or ReactJS frontend. That worked well, and I
regained the fun in programming. Seriously. Well, until subsequent
client work showed me how not to do it, but that's an entirely different
topic.

So this is the story how I got to write this book. I rewrote my
application in Clojure, and I enjoyed it. I am thinking about systems in
terms of rather high-level constructs (like channels, components, JVMs).
In a way, this is comparable to globally operating logistics companies.
They don't need to know how to build a car or a plane, and neither
should I have to worry about composing low-level actors, which, by the
way, I find don't compose all that well.

Now you know the overarching story. There are two additional threads to
follow in this book. The first narrative here is how messages flow
through the system, originating in the Twitter Streaming API and
resulting in a real-time chart in a web client. Then, there's also the
narrative of how this book is written not after the fact but in real
time. I will write the software for the performance- and
verification-related chapters while writing the chapters themselves.
This approach gives you, dear early reader, the unique opportunity to
contribute to the process by commenting on and criticizing my ideas.
Please make use of that.

#+Latex:\pagebreak
* How to use this Book -- Update February 2016
  :PROPERTIES:
  :CUSTOM_ID: how-to-use-this-book-update-february-2016
  :END:

It's been a while that I was last able to put some creative thought into
this book, and there are some reasons for that. Probably the most
important one being the lack of a "traditional" publisher. When I first
heard about LeanPub, I thought, what a great idea to let the readers
provide feedback and thus replace the editor. But I haven't found that
to work very well, especially not while doing rather demanding
consulting work at the same time. It seems to be an unfortunate reality
of life that usually the loudest voice gets heard and served first, and
with little feedback from you, dear readers, I didn't get around to
doing much on this front at all.

So please, if you want new content more often, please do provide some
feedback and don't think, hey, someone else will do it. Also, while
occasional praise may be kind, I'm more looking for constructive
criticism. It's sweet that I have received some positive feedback, but
of the aforementioned constructive criticism, I so far have received
exactly zero. So, please, save time on messages that are only
compliments, they aren't actionable in any way and instead tell me where
there's room for improvement. I'll also be happy to set up a call with
you if you need clarifications on any topic. Please send me an email to
[[mailto:matthias.nehlsen@gmail.com][matthias.nehlsen@gmail.com]] and we
can take it from there. Even if you have nothing particular to say other
than that you're reading the book, I will still be happy to hear from
you.

As an additional incentive for getting in touch with me, I will write
little teasers for future chapters. When you find any of those
particularly interesting, you can get that chapter earlier by letting me
know. I *need* and appreciate your feedback.

That's all.

*Have fun.*

[[file:images/have-fun.jpg]]

Cheers, Matthias

#+Latex:\pagebreak
* Systems Thinking
  :PROPERTIES:
  :CUSTOM_ID: systems-thinking
  :END:

When I started writing this book in December 2014, I did not have a
clear idea about what the overarching idea would be, or why I had even
mentioned the word *System* in the title. But at some point it dawned on
me. Maybe four years ago or so, I had read
*[[http://www.amazon.com/Thinking-Systems-Donella-H-Meadows/dp/1603580557/ref=sr_1_1?ie=UTF8&qid=1424720251&sr=8-1&keywords=thinking+in+systems][Thinking
in Systems by Donella Meadows]]* [fn:1] and remembered that I found the
book enjoyable to read and the ideas presented useful. So I re-read it,
which surprised me in terms of just how applicable *systems thinking* is
to building a software system.

But don't take my word for it. Instead, I have assembled a few quotes so
you can see for yourself. First, let's see how Donatella Meadows defines
a system:

#+BEGIN_QUOTE
  "A system isn't just any old collection of things. A system is an
  interconnected set of elements that is coherently organized in a way
  that achieves something. If you look at that definition closely for a
  minute, you can see that a system must consist of three kinds of
  things: elements, interconnections, and a function or purpose."

  Meadows, Donella H. (2008) Thinking in Systems: A Primer - Page 11
#+END_QUOTE

What can I add? The definition applies not only to an entire
application, but also to individual parts or components of a system. But
just the same way, the definition applies to separate applications that
interact with each other. No matter at which level, we always deal with
systems and these systems, no matter at which level, share certain
properties.

Also quite important is the notion that a system expresses behavior and
that that behavior changes over time:

#+BEGIN_QUOTE
  "The behavior of a system is its performance over time--its growth,
  stagnation, decline, oscillation, randomness, or evolution."

  Meadows, Donella H. (2008) Thinking in Systems: A Primer - Page 88
#+END_QUOTE

What good is any software if it's not run? The code that we write is a
blueprint for a system, not a system itself. Code becomes a system when
we breathe life into it running it. Only then will we be able to observe
its performance. Code that can't be observed while running is
meaningless.

Now that we've established that a system becomes valuable only when it
runs, we should be able to see that keeping the system alive is a
valuable thing and that we should put thought into the ability of the
system to stay up and alive. This is resilience:

#+BEGIN_QUOTE
  "Awareness of resilience enables one to see many ways to preserve or
  enhance a system's own restorative powers."

  Meadows, Donella H. (2008) Thinking in Systems: A Primer - Page 78
#+END_QUOTE

An interesting part of resilient systems is the existence of feedback
loops that allow the system to adapt to the circumstances:

#+BEGIN_QUOTE
  "The structure of a system is its interlocking stocks, flows, and
  feedback loops."

  Meadows, Donella H. (2008) Thinking in Systems: A Primer - Page 88
#+END_QUOTE

Then, there are those system that don't behave nicely:

#+BEGIN_QUOTE
  "But some systems are more than surprising. They are perverse. These
  are the systems that are structured in ways that produce truly
  problematic behavior; they cause us great trouble."

  Meadows, Donella H. (2008) Thinking in Systems: A Primer - Page 111
#+END_QUOTE

Does that remind you of one or more projects you've worked on in the
past? I definitely had that feeling when I read this. This could be said
about multiple systems I've had the dubious pleasure to work on in the
past. How can these problems be dealt with?

#+BEGIN_QUOTE
  "Understanding archetypal problem-generating structures is not enough.
  Putting up with them is impossible. They need to be changed. The
  destruction they cause is often blamed on particular actors or events,
  although it is actually a consequence of system structure. Blaming,
  disciplining, firing, twisting policy levers harder, hoping for a more
  favorable sequence of driving events, tinkering at the margins-these
  standard responses will not fix structural problems. That is why I
  call these archetypes 'traps'."

  "But system traps can be escaped-by recognizing them in advance and
  not getting caught in them, or by altering the structure-by
  reformulating goals, by weakening, strenghtening, or altering feedback
  loops, by adding new feedback loops. That is why I call these
  archetypes not just traps, but opportunities."

  Meadows, Donella H. (2008) Thinking in Systems: A Primer - Page 111
#+END_QUOTE

One interesting thing I learned is that apparently in the Netherlands,
some houses have visible electricity meters and some don't. Who knew
that this actually makes a difference?

#+BEGIN_QUOTE
  "With no other differences in the houses, electricity consumption was
  30 percent lower in the houses where the meter was in the highly
  visible location in the front hall."

  Meadows, Donella H. (2008) Thinking in Systems: A Primer - Page 156
#+END_QUOTE

I think this also applies to developing software in teams. /Hey, why is
your code hogging resources like there's no tomorrow?/ Do you really
want to be the guy who has a hunch that the code that someone elses
wrote burns substantially more CPU cycles than would be reasonable and
then have to prove that? I didn't think so. How about if the *Definition
of Done* included the implementation of metrics so that instead of
guessing, we could see right away where the application spends its time.

How do we get better at dealing with systems?

#+BEGIN_QUOTE
  "Magical leverage points are not easily accessible, even if we know
  where they are and which direction to push on them. There are no cheap
  tickets to mastery. You have to work hard at it, whether that means
  rigorously analyzing a system or rigorously casting off your own
  paradigms and throwing yourself into the humility of not-knowing. In
  the end, it seems that mastery has less to do with pushing leverage
  points than it does with strategically, profoundly, madly, letting go
  and dancing with the system."

  Meadows, Donella H. (2008) Thinking in Systems: A Primer - Page 165
#+END_QUOTE

Lovely, really. I like that picture of dancing with the system. Have you
ever felt that when making changes for the better in a piece of
software? I certainly have.

Another valuable insight is where control lies. We really can't control
everything:

#+BEGIN_QUOTE
  "Systems can't be controlled, but they can be designed and redesigned.
  We can't surge forward with certainty into a world of no surprises,
  but we can expect surprises and learn from them and even profit from
  them. We can't impose our will on a system. We can listen to what the
  system tells us, and discover how its properties and our values can
  work together to bring forth something much better than could ever be
  produced by our will alone."

  Meadows, Donella H. (2008) Thinking in Systems: A Primer - Page 169
#+END_QUOTE

I think that the quote above is a rather strong argument against type
systems. This may sound far-fetched, but let me explain. I've
experienced this over and over and over again when working with a
strongly typed language that the initial assumptions on, for example,
how best to structure an application turned out to be just plain wrong.
Hooray, at least we have strong types... And then, you find yourself
refactoring ten different places and realize that you've really dug
yourself in a hole because you've added a massive extra layer of
complexity that really only gets in the way when you realize that your
initial assumptions were less than genius.

When I work with Clojure, I find that I dread changes much less than in
a language like Scala. Change happens and it always will. Let's embrace
that instead of trying to cement a structure that is hard to code
yourself out of.

How do we find out that we need to change stuff? One way is by properly
observing the system. I really like this quote here:

#+BEGIN_QUOTE
  "Before you disturb the system in any way, watch how it behaves."

  Meadows, Donella H. (2008) Thinking in Systems: A Primer - Page 170
#+END_QUOTE

I couldn't justify monitoring the system any better than this. The code
is just code, it is not the system. We will never be able to fully
understand a system by reading code alone; we will need to understand
how it behaves under different circumstances. And then, we will need to
be open to let go when we find that something does not behave as
intended:

#+BEGIN_QUOTE
  "Getting models out into the light of day, making them as rigorous as
  possible, testing them against the evidence, and being willing to
  scuttle them if they are no longer supported is nothing more than
  practicing the scientific method-something that is done too seldom
  even in science, and is done hardly at all in social science or
  management or government or everyday life."

  Meadows, Donella H. (2008) Thinking in Systems: A Primer - Page 172
#+END_QUOTE

In Clojure, the process above feels a lot more natural when working with
a few built-in abstractions for data such as maps, vectors, lists, and
sets than when you have to engineer classes for every possible data
represention you may encounter in your system. Once again, I think that
type systems inevitably slow you down and hamper your ability to adapt
to change. At least that's my experience from working in Scala for two
years before deciding to go with Clojure instead.

#+BEGIN_QUOTE
  "What's appropriate when you're learning is small steps, constant
  monitoring, and a willingness to change course as you find out more
  about where it's leading."

  Meadows, Donella H. (2008) Thinking in Systems: A Primer - Page 180
#+END_QUOTE

Fully agreed. Have you ever worked on a system over a period of months
where all the initial assumptions have proven correct? The only way that
I could imagine this to happen is if the system never goes live.

Obviously, systems thinking is not a panacea:

#+BEGIN_QUOTE
  "Systems thinking can only tell us to do that. It can't do it. We're
  back to the gap between understanding and implementation. Systems
  thinking by itself cannot bridge that gap, but it can lead us to the
  edge of what analysis can do and then point beyond-to what can and
  must be done by the human spirit."

  Meadows, Donella H. (2008) Thinking in Systems: A Primer - Page 185
#+END_QUOTE

So far for the systems thinking book. I would recommend reading it.
While it's not at all about software, a lot of things still apply
because at the end of the day, software is also about systems on
different levels.

** Intervention points
   :PROPERTIES:
   :CUSTOM_ID: intervention-points
   :END:

What's the most interesting thing to monitor for? In a given system
where the individual processing units can become a bottleneck and wait,
I want to know how long each processing step takes. Wait times should be
listed individually. In the case of core.async, I want to know the
overall amount of time it takes to iterate through a go-loop and also,
if blocking puts are used and how long the wait time is (indicating
congestion down the line).

Could parallelity be used as an intervention point? Yeah, quite likely.
If an individual step takes too long, we could fire up more parallel
instances of the processing loop while reducing the parallelity in other
parts of the system. This way, the system becomes adaptive within
reasonable boundaries.

Buffer sizes are equally important. We could just sunset a go-loop with
an attached buffer by letting it run out while at the same time creating
a new one for further processing with a different buffer size and have
that new one process incoming messages henceforth. Or block until the
old one has run out in order to avoid compromises in potential ordering
guarantees we may rely on. Hopefully, we don't rely on them, though, as
they would preclude parallelity, which is pretty incompatible with such
guarantees.

In the systems thinking book, buffers aren't high on the list but mostly
to them being inflexible in the real world, such as a dam. In a dynamic
software system, they consist merely of thought, so they can be changed
at will.

When automating, introduce delays. No fast decision in order to avoid
oscillating behavior. Maybe even introduce an amount of randomness in
the strategies involved within reasonable boundaries. That should make
oscillating behavior even less likely. Or vary the duration between
decision points about corrective action. That should at least dampen any
tendency of the system to oscillate between extremes.

According to the definition in the systems thinking book these parts of
the system adapting to change balance feedback loops.

How about associating costs to parallelity factors and buffer sizes?
These are costly to the system as a whole (more threads or memory
bound). Each agent can then earn cash by providing system services and
burn it for requesting resouces. And then have itself optimize for
profitability, while trying to meet SLAs as closely as possible.

[fn:1] I've also found a draft of the book as a
       *[[http://www.natcapsolutions.org/Presidio/Articles/WholeSystems/ThinkingInSystems_MEADOWS_TiS%20v13.2_DRAFT.pdf][pdf]]*
       but I don't know if it's actually legal to download it from
       there.

#+Latex:\pagebreak
* Old Server-side Architecture
  :PROPERTIES:
  :CUSTOM_ID: old-server-side-architecture
  :END:

** Architectural Overview
   :PROPERTIES:
   :CUSTOM_ID: architectural-overview
   :END:

In the following chapters, we will look at an earlier version of my
*[[https://github.com/matthiasn/BirdWatch][BirdWatch]]* application. The
approach outlined here is not my recommended approach any longer, as
there were a lot of functionalities that were common to each and all the
components in the system. Instead, I have moved this common
functionality into a separate library called
*[[https://github.com/matthiasn/systems-toolbox][systems-toolbox]]*.
However, by going through the initial approach, you will have a good
reference for why I wanted to have the library. In particular, please
look out for repetitiveness and try to think how you may get rid of it.
Then later on in this book, we can compare notes as I will present what
I did. Please also email me (the address is on my
*[[https://github.com/matthiasn][GitHub]]* page) and discuss what you
would do differently.

Now let's start with the basic architecture of the server side. Here's
an overview:

#+CAPTION: channels overview
[[file:images/bw-channels.png]]

You can see an animated version of this drawing in the
*[[http://matthiasnehlsen.com/blog/2014/09/24/Building-Systems-in-Clojure-1/][original
blog post]]* that demonstrates how components in the system get wired up
when the application initializes.

In the initial version that I wrote, where everything depended on
everything, things were very different. Some people would call that
"spaghetti code", but I think that is not doing justice to spaghetti.
Unlike bad code, I don't mind touching spaghetti. I would rather liken
bad code to hairballs, of the worst kind that is. Have you ever
experienced the following: you are standing in the shower and the water
doesn't drain. You notice something in the sink, so you squat down to
pull it out only to start screaming, "Oh my god, it's a dead rat" a
second later. I am referring to that kind of entangled hairball mess.

This is where dependency injection comes in. Can we agree that we don't
like hairballs? Good. Usually, what we are trying to achieve is a
so-called inversion of control, in which a component of the application
knows that it will be injected something which implements a known
interface at runtime. Then, no matter what the actual implementation is,
it knows what methods it can call on that something because of the
implemented interface.

Here, unlike in object-oriented dependency injection, things are a
little different because we don't really have objects. The components
play the role of objects, but as a further way of decoupling, I wanted
them to only communicate via *core.async* channels. Channels are a great
abstraction. Rich Hickey likens them to conveyor belts onto which you
put something without having to know at all what happens on the other
side. We will have a more detailed look at the channels in the next
article. For now, as an abstraction, we can think about the channel
components (the flat ones connecting the components with the
switchboard) as *wiring harnesses*, like the one that connects the
electronics of your car to your engine. The only way to interface with a
modern engine (that doesn't have separate mechanical controls) is by
connecting to this wiring harness and either send or receive
information, depending on the channel / cable that you interface with.

** Scaling out
   :PROPERTIES:
   :CUSTOM_ID: scaling-out
   :END:

I recently did a lot of transcript proofreading concerning enlightening
talk for my
*[[https://github.com/matthiasn/talk-transcripts][talk-transcripts
project]]*. The most recent one was
*[[https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/DesignCompositionPerformance.md][Design,
Composition and Performance]]*, the tenth transcript of a talk by *Rich
Hickey*. That one in particular got me thinking that there are quite a
few ideas I want to adopt, so it was time to make up my mind what
exactly it is that I am trying to solve with this application.

So here's the idea:

- We have a stream of information and we are interested in a subset of
  that information, which we can match on via *full-text search* and
  *ranges*. The searches are anything that
  *[[http://www.elasticsearch.com][ElasticSearch]]* /
  *[[http://lucene.apache.org][Lucene]]* can match on.
- Furthermore, we are interested in *live results* plus a certain period
  of time back into the *recent* past. For now, we are using tweets from
  the *[[https://dev.twitter.com/streaming/overview][Twitter Streaming
  API]]*, but the source could be anything, such as other social media
  data. Sensor data could also be really interesting. Live means new
  matches are added to the displayed results within about a second.
- The results are supposed to be shown in a browser, including on
  *mobile devices*. The number of items reasoned about should *not be
  limited by* the available *memory* of the browser[fn:1].
- My next goal is to be able to reason about the *last one million
  tweets* for a certain topic. Also, it should be possible to serve
  *many concurrent ad-hoc queries*, like hundreds or more different
  ones.

What comes to mind immediately when regurgitating the requirements above
is *[[https://storm.apache.org][Storm]]* and the
*[[http://lambda-architecture.net][Lambda Architecture]]*. First I
thought, great, such a search could be realized as a *bolt* in Storm.
But then I realized, and please correct me if I'm wrong, that topologies
are fixed once they are running. This limits the flexibility to add and
tear down additional live searches. I am afraid that keeping a few
stand-by bolts to assign to queries dynamically would not be flexible
enough.

So instead I suggest doing the *final aggregation* (the reduce phase) on
the browser side in a *ClojureScript* application. On the server side,
partial results are aggregated for shorter time periods. These partial
results can be generated in a cluster of nodes whilst the client is fed
with live data immediately. Let's have a look at a drawing before I walk
you through the individual steps:

#+CAPTION: Redesigned Architecture
[[file:images/redesign.png]]

Initially, this application was designed to run in a single JVM but
after some redesign, I split the server side into two different
components. The architecture you saw in the drawing above turned out to
be a great preparation for separating parts of the application into
separate JVMs for scaling out the application. My idea was that there
should be one *TwitterClient* application (as Twitter only allows one
connection to the capped Streaming API) but multiple web client facing
applications so that the number of connections the system could handle
would not be limited by whatever a single machine could handle. Let's
call that the *MainApp* application. The separation of components and
limiting their interaction to passing messages on channels made it
extremely simple to scale the application by fanning out the streaming
data to multiple client-facing JVMs. All that was needed in addition was
a component for interoperability. None of the existing components needed
to be changed except for the switchboard where the data flow gets wired
together.

Let's walk through the interactions of the entire system step by step:

1.  Tweets are received from the Twitter Streaming API in chunks of
    (oftentimes incomplete) JSON. A *stateful transducer* is used to
    reassemble the JSON and parse chunks into Clojure maps.

2.  Tweets are stored in
    *[[http://www.elasticsearch.com][ElasticSearch]]* in their
    respective index. If the received tweet contains a retweet, the
    retweet status will be used to update an existing item (e.g. the RT
    count).

3.  The newly received tweet is presented to ElasticSearch's
    *[[http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-percolate.html][percolation
    index]]* in order to find clients interested in this tweet. It is
    kind of a reverse matching where the new item is matched against
    *existing searches*. We will cover percolation in more detail when
    we look at the percolation component.

4.  Together with information on matched queries the tweet is published
    using *[[http://redis.io/topics/pubsub][Redis's Pub/Sub]]* feature.
    Potentially, the search ID of the matches could be used to publish
    to different topics[fn:2]. This constitutes the border of the first
    Clojure application.

5.  The second Clojure application, which serves the client-side
    ClojureScript application as well, receives a new search via a
    *WebSocket* connection.

6.  It then *registers* the query in ElasticSearch's *percolation*
    index.

7.  Next, the socket connection *subscribes* to the search ID's topic in
    Redis's *Pub/Sub* feature.

8.  From now on matches to the client's search will be delivered
    immediately to the client-side ClojureScript application.

9.  The idea is to *aggregate data on the server side* and only deliver
    the aggregated data structures back to the client side. For example,
    this could be a few hundred aggregates over increments of five
    minutes each. These increments can easily be made addressable (and
    cacheable): let's say it is 1:17pm. Then, we have a last and
    incomplete increment from 1:15pm that will be added on in the
    browser whereas all previous ones are complete and fixed. By
    treating the complete ones as *immutable*, we can cache them and
    forego unnecessary and expensive requests to ElasticSearch. Since
    these immutable previous chunks can be addressed individually, it
    may make sense to deliver them through REST endpoints instead of via
    the WebSocket connection (the dashed line)[fn:3]. This is not
    implemented yet; instead, the client requests chunks of previous
    tweets and all reasoning about them happens in the browser.

10. We've already established that previous chunks can be cached.
    *[[http://redis.io][Redis]]* seems like a great match utilizing the
    *[[http://redis.io/commands/expire][EXPIRE feature]]*. So Redis
    would be queried for the presence of a certain chunk first. If it
    exists, it will be delivered right away. If not, ElasticSearch will
    be queried and the result will be delivered and stored in Redis for
    the next couple of hours or so to avoid unnecessary load on the
    ElasticSearch cluster. Currently, here we only query ElasticSearch
    without caching.

11. Finally, the aggregate will be delivered to the client. This could
    either be through the WebSocket connection or through
    *[[http://en.wikipedia.org/wiki/Representational_state_transfer][REST]]*
    (the dashed line). Currently, a (larger) chunk with 500 tweets each
    is delivered to the client instead of an aggregate.

So far, these changes have only been partially implemented. *Decoupling*
the processes between a Twitter client and the client-serving part is
done and allows restarting the latter *without disconnecting* from the
Streaming API and also allows horizontal scaling where multiple
client-serving applications can connect to the Pub/Sub:

#+CAPTION: Redesigned Architecture
[[file:images/overview.png]]

The server-side aggregation has not been implemented yet, that part will
follow soon.

[fn:1] Right now with all tweets loaded onto the client, the maximum for
       a desktop browser is somewhere in the range of a *few tens of
       thousands* of tweets before the application slows down
       noticeably.

[fn:2] I'm undecided about this one. On one hand, it is strikingly
       simple to have a topic per search ID, which is a hash of the
       query itself. But on the other hand, this likely involves
       *book-keeping* of the subscriptions on the consuming side, where
       the subscription would have to be removed once the client
       disconnects. Maybe it is simpler to just serialize a set of IDs
       with the tweet and publish that on a single topic.

[fn:3] Using REST makes communication somewhat more complex, but I still
       think it would make sense to move this aspect of the application
       into separate JVMs. The *GC characteristics* of aggregating large
       amounts of data in spikes are vastly different from the (near-)
       real-time aspects of the WebSocket delivery of new tweets. For
       the aggregation, it would not affect user experience much if
       there was a *stop-the-world* garbage collection pause of even a
       few seconds, but I don't want that to happen for the streaming
       data.
** Application Initialization
   :PROPERTIES:
   :CUSTOM_ID: application-initialization
   :END:

Let's have a look at how the initialization of the application looks
like in
*[[https://github.com/matthiasn/BirdWatch/blob/a26c201d2cc2c89f4b3d2ecb8e6adb403e6f89c7/Clojure-Websockets/src/clj/birdwatch/main.clj][code]]*:

#+BEGIN_SRC clojure
  (ns birdwatch.main
    (:gen-class)
    (:require
     [birdwatch.twitter-client :as tc]
     [birdwatch.communicator :as comm]
     [birdwatch.persistence :as p]
     [birdwatch.percolator :as perc]
     [birdwatch.http :as http]
     [birdwatch.switchboard :as sw]
     [clojure.edn :as edn]
     [clojure.tools.logging :as log]
     [clj-pid.core :as pid]
     [com.stuartsierra.component :as component]))

  (def conf (edn/read-string (slurp "twitterconf.edn")))

  (defn get-system
    "Create system by wiring individual components so that component/start
    will bring up the individual components in the correct order."
    [conf]
    (component/system-map
     :communicator-channels (comm/new-communicator-channels)
     :communicator  (component/using (comm/new-communicator)
                                     {:channels :communicator-channels})
     :twitterclient-channels (tc/new-twitterclient-channels)
     :twitterclient (component/using (tc/new-twitterclient conf)
                                     {:channels :twitterclient-channels})
     :persistence-channels (p/new-persistence-channels)
     :persistence   (component/using (p/new-persistence conf)
                                     {:channels :persistence-channels})
     :percolation-channels (perc/new-percolation-channels)
     :percolator    (component/using (perc/new-percolator conf)
                                     {:channels :percolation-channels})
     :http          (component/using (http/new-http-server conf)
                                     {:communicator :communicator})
     :switchboard   (component/using (sw/new-switchboard)
                                     {:comm-chans :communicator-channels
                                      :tc-chans :twitterclient-channels
                                      :pers-chans :persistence-channels
                                      :perc-chans :percolation-channels})))
  (def system (get-system conf))

  (defn -main [& args]
    (pid/save (:pidfile-name conf))
    (pid/delete-on-shutdown! (:pidfile-name conf))
    (log/info "Application started, PID" (pid/current))
    (alter-var-root #'system component/start))
#+END_SRC

I personally think this *reads really well*, even if you have never seen
Clojure before in your life. Roughly the first half is concerned with
imports and reading the configuration file. Next, we have the
=get-system= function which declares what components depend on what
other components. The system is finally started in the =-main= function
(plus the process ID logged and saved to a file). This is all there is
to know about the application entry point.

Now, when we start the application, all the dependencies will be started
in an order that the component library determines so that all
dependencies are met. Here's the output of that startup process:

#+BEGIN_SRC
    mn:Clojure-Websockets mn$ lein run
    16:46:30.925 [main] INFO  birdwatch.main - Application started, PID 6682
    16:46:30.937 [main] INFO  birdwatch.twitter-client - Starting Twitterclient Channels Component
    16:46:30.939 [main] INFO  birdwatch.twitter-client - Starting Twitterclient Component
    16:46:30.940 [main] INFO  birdwatch.twitter-client - Starting Twitter client.
    16:46:31.323 [main] INFO  birdwatch.persistence - Starting Persistence Channels Component
    16:46:31.324 [main] INFO  birdwatch.persistence - Starting Persistence Component
    16:46:31.415 [main] INFO  org.elasticsearch.plugins - [Chameleon] loaded [], sites []
    16:46:32.339 [main] INFO  birdwatch.communicator - Starting Communicator Channels Component
    16:46:32.340 [main] INFO  birdwatch.communicator - Starting Communicator Component
    16:46:32.355 [main] INFO  birdwatch.http - Starting HTTP Component
    16:46:32.375 [main] INFO  birdwatch.http - Http-kit server is running at http://localhost:8888/
    16:46:32.376 [main] INFO  birdwatch.percolator - Starting Percolation Channels Component
    16:46:32.377 [main] INFO  birdwatch.percolator - Starting Percolator Component
    16:46:32.380 [main] INFO  birdwatch.switchboard - Starting Switchboard Component
#+END_SRC

Note that in the code above, we are looking at a previous version of the
application in which the entire application used to live inside a single
JVM. The reason is that the corresponding animation in the
*[[http://matthiasnehlsen.com/blog/2014/09/24/Building-Systems-in-Clojure-1/][original
blog post]]* also deals with this single-JVM architecture.

However, the mechanism remains the same in both applications after
splitting the server side into multiple processes, so we only handle
this once for now.

#+Latex:\pagebreak
* Server-side: TwitterClient
  :PROPERTIES:
  :CUSTOM_ID: server-side-twitterclient
  :END:

** Architectural Overview
   :PROPERTIES:
   :CUSTOM_ID: architectural-overview
   :END:

Here's an overview of the TwitterClient application. No worries if it's
too small to read everything, we will look at different parts of it in
detail later.

#+CAPTION: TwitterClient Application
[[file:images/twitterclient_architecture.png]]

The purpose of the *TwitterClient* application is to maintain a
streaming connection with the
*[[https://dev.twitter.com/streaming/overview][Twitter Streaming API]]*,
restart this connection if necessary, persist received tweets and make
tweets available on a *[[http://redis.io/topics/pubsub][Redis
Pub/Sub]]*. There can only be one instance of this application at any
one time because Twitter does not allow you to start multiple clients at
the same time.

Let's start in *[[https://www.youtube.com/watch?v=f84n5oFoZBc][hammock
mode]]*, without code. What is the problem we are trying to solve? It
all starts with the tweet stream from the Twitter API. Very briefly, the
*[[https://dev.twitter.com/docs/streaming-apis][Twitter Streaming API]]*
allows us to subscribe to a (near) real time stream of tweets that
contain one or more terms out of a set of terms. In the live instance
under
*[[http://birdwatch2.matthiasnehlsen.com/#*][http://birdwatch2.matthiasnehlsen.com]]*
these terms at the moment happen to be "Ferguson", "ISIS", and "Ebola" -
I am interested in all these topics. As long as that subscription does
not hit a hard ceiling of *1%* of all the tweets flowing through
twitter's system, we can be sure that we will retrieve all of them.
Otherwise the stream will be throttled to a maximum of *1%* of what is
tweeted at any moment in time. [\^tc-numbers]

Here is how that stream looks like when each chunk is simply printed to
the console:

#+CAPTION: streaming API output
[[file:images/streaming-api.gif]]

For reasons unbeknownst to me, tweets stopped respecting the chunk
borders for the last half year. Instead, tweets occasionally span two or
three chunks. This makes processing the tweets a little more complicated
than we might wish for. One tweet per chunk is straightforward:

#+BEGIN_SRC
    Receive chunk -> parse JSON into map -> put on conveyor belt (channel)
#+END_SRC

That looks like functional programming, right? No state to be kept
anywhere, just functions producing results that are passed into other
functions. But as desirable as that sounds, it does not align with
reality. Instead, we need logical reasoning and state. What is the
instruction we would give a sentient being? Imagine an intelligent agent
standing between two conveyor belts. Imagine that agent being you. Here
we go:

"On your left side, there's a conveyor belt that keeps delivering
hundred dollar bills. Put all of them on the other conveyor belt. Some
of them come out cut into multiple pieces. These fragments are in
correct order. Scotch tape is over there."

I think we would all know what to do. There is a space where you park
fragments of not-yet-complete bills / tweets. Then, with every new
fragment, you inspect if the bill is complete and if so, put it back
together and pass it on. Let's try that in code. First, we will need to
introduce *transducers* though.

*** Transducers
    :PROPERTIES:
    :CUSTOM_ID: transducers
    :END:

#+BEGIN_QUOTE
  Transducers are a powerful and composable way to build algorithmic
  transformations that you can reuse in many contexts, and they're
  coming to Clojure core and core.async.
  *[[http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming][Rich
  Hickey, August 2014]]*
#+END_QUOTE

In a way, a transducer is the *essence* of a computation over data,
without being bound to any kind of collection or data structure. Above,
before we had to concern ourselves with the incomplete fragments, there
was one step of the computation that we could *model as a transducer*:
the part where we wanted to parse JSON into a map data structure.

Imagine we wanted to transform a vector of JSON strings into a vector of
such parsed maps. We could simply do this:

#+BEGIN_SRC clojure
    (map json/read-json ["{\"foo\":1}" "{\"bar\":42}"])
#+END_SRC

However, the above is bound to the data structure, in this case a
vector. That should not have to be the case, though. Rich Hickey
provides a good example in his
*[[https://www.youtube.com/watch?v=6mTbuzafcII][transducers talk]]*,
likening the above to having to tell the guys processing luggage at the
airport the same instructions twice, once for trolleys and again for
conveyor belts, where in reality that should not matter.

We could, for example, not only run the mapping function over every item
in a vector but also reuse the same function on every item in a channel,
stream or whatever.

With Clojure 1.7, we can now create such a transducing function by
simply leaving out the data structure:

#+BEGIN_SRC clojure
    (def xform (map json/read-json))
#+END_SRC

Now, we can apply this transducing function to different kinds of data
structures that are transducible processes. For example, we could
transform all entries from a vector into another vector, like so:

#+BEGIN_SRC clojure
    (into [] xform ["{\"foo\":1}" "{\"bar\":42}"])
#+END_SRC

Or into a sequence, like this:

#+BEGIN_SRC clojure
    (sequence xform ["{\"foo\":1}" "{\"bar\":42}"])
#+END_SRC

It may not look terribly useful so far. But this can also be applied to
a channel. Say, we want to create a channel that accepts JSON strings
and transforms each message into a Clojure map. Simple:

#+BEGIN_SRC clojure
    (chan 1 xform)
#+END_SRC

The above creates a channel with a buffer size of one that applies the
transducer to every element.
** TwitterClient Component
   :PROPERTIES:
   :CUSTOM_ID: twitterclient-component
   :END:

But these simple, per-item transducers do not help in our case, where we
know that some of the chunks are not complete but instead have to be
glued together with the next one or two pieces. For that, we will need
some kind of *state*. In the example above, that would be the space
where we place fragments of a hundred dollar bill. But what if we want
to see this aggregation process as a *black box*? Then, the aggregation
cannot really have outside state. Also, as Rich Hickey mentioned in his
StrangeLoop talk, there is no space in the machinery to keep state. What
if one such transducer could have local state even if that is contained
and not accessible from the outside? It turns out this is where stateful
transducers can help.

Here's how this stateful transducer looks like in
*[[https://github.com/matthiasn/BirdWatch/blob/f39a5692e4733784124d0f0930202d4270762d77/Clojure-Websockets/src/clj/birdwatch/twitterclient/processing.clj][code]]*:

#+BEGIN_SRC clojure
    (defn- streaming-buffer []
      (fn [step]
        (let [buff (atom "")]
          (fn
            ([r] (step r))
            ([r x]
             (let [json-lines (-> (str @buff x) (insert-newline) (str/split-lines))
                   to-process (butlast json-lines)]
               (reset! buff (last json-lines))
               (if to-process (reduce step r to-process) r)))))))
#+END_SRC

Let's go through this line by line. We have a (private) function named
*streaming-buffer* that does not take any arguments. It returns a
function that accepts the step function. This step function is the
function that will be applied to every step from then on. This function
then first creates the local state as an atom[fn:1] which we will use as
a buffer to store incomplete tweet fragments. It is worth noting that we
don't have to use *atoms* here if we want to squeeze out the last bit of
performance, but I find it easier not to introduce yet another concept
unless absoletely necessary[fn:2]. Next, this function returns another
function which accepts two parameters, r for result and x for the
current data item (in this case the - potentially incomplete - chunk).

In the first line of the let binding, we use the =->=
*[[http://clojuredocs.org/clojure.core/-%3E][(thread-first)]]* macro.
This macro makes the code more legible by simply passing the result of
each function call as the first argument of the next function. Here,
specifically, we *1)* concatenate the buffer with the new chunk, *2)*
add newlines where missing[fn:3], and *3)* split the string into a
sequence on the line breaks.

Now, we cannot immediately process all those items in the resulting
sequence. We know that all are complete except for the last one as
otherwise there would not have been a subsequent tweet. But the last one
may not be complete. Accordingly, we derive

#+BEGIN_SRC clojure
    (butlast json-lines)
#+END_SRC

under the name *to-process*. Then, we reset the buffer to whatever is in
that last string:

#+BEGIN_SRC clojure
    (reset! buff (last json-lines))
#+END_SRC

Finally, we have *reduce* call the *step* function for every item in
*to-process*:

#+BEGIN_SRC clojure
    (if to-process (reduce step r to-process) r)
#+END_SRC

That way, only complete JSON strings are pushed down to the next
operation, whereas intermediate JSON string fragments are kept locally
and not passed on until certainly complete. That's all that was needed
to make the tweets whole again. Next, we compose this with the JSON
parsing transducer we have already met above so that this
*streaming-buffer* transducer runs first and passes its result to the
*JSON parser*.

Let's create a vector of JSON fragments and try it out. We have already
established that transducers can be used on different data structures,
it therefore should work equally well on a vector. Here's the vector for
the test:

#+BEGIN_SRC clojure
    ["{\"foo\"" ":1}\n{\"bar\":" "42}" "{\"baz\":42}" "{\"bla\":42}"]
#+END_SRC

Now we can check on the REPL if this will produce three complete JSON
strings. It is expected here that the last one is lost because we would
only check its completeness once there is a following tweet[fn:4]. Once
the collection to process is empty, the *arity-1* (single argument)
function is called one last time, which really only returns the
aggregate at that point:

#+BEGIN_SRC clojure
    => (in-ns 'birdwatch.twitterclient.processing)
    #<Namespace birdwatch.twitterclient.processing>

    => (def chunks ["{\"foo\"" ":1}\n{\"bar\":" "42}" "{\"baz\":42}" "{\"bla\":42}"])
    #'birdwatch.twitterclient.processing/chunks

    => (into [] (streaming-buffer) chunks)
    ["{\"foo\":1}" "{\"bar\":42}" "{\"baz\":42}"]
#+END_SRC

What somewhat confused me at first is what the step function actually
was. Let's find out by printing it when the arity-1 function is called.
We can modify the fourth line of *stream-buffer* like this:

#+BEGIN_SRC clojure
    ([r] (println step) (step r))
#+END_SRC

Now when we run the same as above on the REPL, we can see what the step
function actually is:

#+BEGIN_SRC clojure
    => (into [] (streaming-buffer) chunks)
    #<core$conj_BANG_ clojure.core$conj_BANG_@5fd837a>
    ["{\"foo\":1}" "{\"bar\":42}" "{\"baz\":42}"]
#+END_SRC

Interestingly, the step function is *conj!* which according to the
*[[https://github.com/clojure/clojure/blob/clojure-1.7.0-alpha2/src/clj/clojure/core.clj#L3208][source]]*
adds *x* to a *transient collection*[fn:5].

The step function is different when we use the transducer on a channel,
but more about that when we use it in that scenario.

There's more to do before we can *compose all transducers* and attach
them to the appropriate channel. Specifically, we can receive valid JSON
from Twitter, which is not a tweet. This happens, for example, when we
get a notification that we lag behind in consuming the stream. In that
case we only want to pass on the parsed map if it is likely that it was
a tweet and otherwise log it as an error. There is one *key* that all
tweets have in common, which does not seem to appear in any status
messages from Twitter: *:text*. We can thus use that key as the
*predicate* for recognizing a tweet. Here's the
*[[https://github.com/matthiasn/BirdWatch/blob/f39a5692e4733784124d0f0930202d4270762d77/Clojure-Websockets/src/clj/birdwatch/twitterclient/processing.clj][code]]*:

#+BEGIN_SRC clojure
  (defn- tweet?
    "Checks if data is a tweet. If so, pass on, otherwise log error."
    [data]
    (let [text (:text data)]
      (when-not text (log/error "error-msg" data))
      text))
#+END_SRC

Next, we also want to log the count of tweets received since the
application started. Let's do this only for full thousands. We will need
some kind of counter to keep track of the count. Let's create another
*stateful transducer*:

#+BEGIN_SRC clojure
  (defn- log-count
    "Stateful transducer, counts processed items and updating last-received atom.
    Logs progress every 1000 items."
    [last-received]
    (fn [step]
      (let [cnt (atom 0)]
        (fn
          ([r] (step r))
          ([r x]
           (swap! cnt inc)
           (when (zero? (mod @cnt 1000))
             (log/info "processed" @cnt "since startup"))
           (reset! last-received (t/now))
           (step r x))))))
#+END_SRC

This transducer is comparable to the one we saw earlier, except that the
local atom now holds the count. Initially, the counter is incremented
and then, when the counter is divisible by 1000, the count is logged. In
addition, this function also resets the *last-received* timestamp. Of
course, this could be factored out into a separate function, but I think
this will do.

Now, we can compose all these steps:

#+BEGIN_SRC clojure
  (defn process-chunk
    "Creates composite transducer for processing tweet chunks. Last-received atom
    passed in for updates."
    [last-received]
    (comp
     (streaming-buffer)
     (map json/read-json)
     (filter tweet?)
     (log-count last-received)))
#+END_SRC

The above creates a composed function that takes the timestamp atom
provided by the TwitterClient component as an argument. The entires
namespace can be found
*[[https://github.com/matthiasn/BirdWatch/blob/f39a5692e4733784124d0f0930202d4270762d77/Clojure-Websockets/src/clj/birdwatch/twitterclient/processing.clj][here]]*.
We can now use this *transducing function* and apply it to different
data structures. Here, we use it to create a channel that takes tweet
chunk fragments and delivers parsed tweets on the other side of the
conveyor belt.

Let's try the composed transducer on a vector to see what's happening.
For that, we create a vector with two JSON strings that contain the
*:text* property and two that don't.

#+BEGIN_SRC clojure
["{\"text\"" ":\"foo\"}\n{\"text\":" "\"bar\"}" "{\"baz\":42}" "{\"bla\":42}"]
#+END_SRC

Then we should see that the invalid one is logged and the other two are
returned (the final one at that point still being in the buffer):

#+BEGIN_SRC clojure
  (in-ns 'birdwatch.twitterclient.processing)
  (def chunks
    ["{\"text\"" ":\"foo\"}\n{\"text\":" "\"bar\"}" "{\"baz\":42}" "{\"bla\":42}"])
  (into [] (process-chunk (atom (t/epoch))) chunks)
  ERROR birdwatch.twitterclient.processing - error-msg {:baz 42}
  [{:text "foo"} {:text "bar"}]
#+END_SRC

Great, we have a composed transducer that works on vectors as expected.
According to Rich Hickey this should work equally well on channels. But
let's not take his word for it and instead try it out. First, here's my
attempt to visualize the usage of a transducer in a channel. To make
things easier, no errors occur.

#+CAPTION: TwitterClient Component with channels
[[file:images/twitterclient.png]]

You can also see the illustration above as an animation in the original
*[[http://matthiasnehlsen.com/blog/2014/10/06/Building-Systems-in-Clojure-2/][blog
post]]*.

Now for a simple example in the REPL:

#+BEGIN_SRC clojure
    => (in-ns 'birdwatch.twitterclient.processing)
    #<Namespace birdwatch.twitterclient.processing>

    => (def chunks ["{\"text\"" ":\"foo\"}\r\n{\"text\":" "\"bar\"}" "{\"baz\":42}" "{\"bla\":42}"])
    #'birdwatch.twitterclient.processing/chunks

    => (require '[clojure.core.async :as async :refer [chan go-loop <! put!]])
    => (def c (chan 1 (process-chunk (atom (t/now)))))
    #'birdwatch.twitterclient.processing/c

    => (go-loop [] (println (<! c)) (recur))
    #<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@2f924b3f>

    => (put! c (chunks 0))
    => (put! c (chunks 1))
    {:text foo}

    => (put! c (chunks 2))
    => (put! c (chunks 3))
    {:text bar}

    => (put! c (chunks 4))
    ERROR birdwatch.twitterclient.processing - error-msg {:baz 42}
#+END_SRC

Excellent, same output. In case you're not familiar with *core.async
channels* yet: above we created a channel with the same transducer
attached as in the previous example, then we created a =go-loop= to
consume the channel and finally, we =put!= the individual chunks on the
channel. No worries if this seems a little much right now. We'll cover
this topic in much more detail in later chapters.

[fn:1] After initial experimentation with a
       *[[http://dev.clojure.org/jira/browse/CLJ-1512][local volatile
       reference]]*, I decided in favor of a good old atom. The
       *volatile!* local reference trades off potential race conditions
       with speed. But there's no performance issue when we process
       tweet chunks a few hundred times a second utmost, so why bother
       and introduce a new concept? Worth to keep in mind, though, when
       performance is an issue.

[fn:2] *Atoms* are essential to Clojure's *state model*. Essentially,
       you have this managed reference that is thread-safe. Whenever we
       dereference such an atom, we get the state of the world this very
       second. Then, when you pass the dereferenced value to other parts
       of the application, it still represents the immutable state of
       the world at that point in time. It cannot change. Next time I
       dereference that atom, I will get the new state of the world.
       Updates to atoms can only happen in transactions, meaning that no
       two can run at the same time. Thus, we won't have to chase crazy
       concurrency issues.

[fn:3] For whatever reason, the changed behavior of the streaming API
       also entails that not all tweets are followed by line breaks,
       only most of them. A tiny helper function inserts those missing
       linebreaks where they are missing between two tweets:
       =(str/replace s #"\}\{" "}\r\n{"))=.

[fn:4] One could probably check if the buffer contains a valid and
       complete JSON string when the arity-1 function is called, and if
       so, pass it on. Considering though that in this application we
       are interested in a stream that does not have an end, I omitted
       this step.

[fn:5] I assume the *transient* collection is used for performance
       reasons.
** TwitterClient - SwitchBoard Component
   :PROPERTIES:
   :CUSTOM_ID: twitterclient---switchboard-component
   :END:

This component takes care of distributing data in the TwitterClient
application by connecting *core.async* channels together, comparable to
an operator in the early days of telephony[fn:1]:

#+CAPTION: telephony switchboard
[[file:images/JT_Switchboard_770x540.jpg]]

In the conceptual drawing we can see that in this component the channels
from different components are wired for the requirements of the
application. Here, it would be very simple to attach additional
components and send messages to those as well, without other parts of
the application having to know anything about it.

#+CAPTION: Switchboard Component
[[file:images/tc_switchboard.png]]

Let's have a look at the
*[[https://github.com/matthiasn/BirdWatch/blob/43a9c09493257b9c9b5e9e5644df5f67085feb84/Clojure-Websockets/TwitterClient/src/clj/birdwatch_tc/switchboard.clj][code]]*:

#+BEGIN_SRC clojure
  (ns birdwatch-tc.switchboard
    (:gen-class)
    (:require
     [clojure.tools.logging :as log]
     [com.stuartsierra.component :as component]
     [clojure.core.async :as async :refer [chan mult tap pipe]]))

  ;;;; This component is the central switchboard for information flow in
  ;;;; this application. The individual channel components come together
  ;;;; like wiring harnesses in a car.

  (defrecord Switchboard [tc-chans pers-chans perc-chans iop-chans]
    component/Lifecycle
    (start [component] (log/info "Starting Switchboard Component")
           (let [tweets-mult (mult (:tweets tc-chans))]
             ;; Tweets are distributed to multiple channels
             (tap tweets-mult (:percolation perc-chans))
             ;; through tapping the mult created above
             (tap tweets-mult (:persistence pers-chans))
             ;; Connect channels 1 on 1. Here, it would be easy to add
             ;; message logging.
             (pipe (:percolation-matches perc-chans) (:send iop-chans))
             (assoc component :tweets-mult tweets-mult)))

    (stop [component] (log/info "Stop Switchboard Component")
          (assoc component :tweets-mult nil)))

  (defn new-switchboard [] (map->Switchboard {}))
#+END_SRC

Here, the only thing that really happens is that we create a =mult= from
the =:tweets= channel, which is a multiplier that allows us to connect
multiple channels that each consume all elements on the =mult=. Then, we
=tap= into the =mult= and connect both the =:percolation= and the
=:persistence= channels.

[fn:1] Photo by Joseph A. Carr, 1975, from
       *[[http://commons.wikimedia.org/wiki/File:JT_Switchboard_770x540.jpg][Wikimedia]]*
** TwitterClient - Percolation Component
   :PROPERTIES:
   :CUSTOM_ID: twitterclient---percolation-component
   :END:

The Percolation Component is responsible for matching new tweets with
existing queries. Remember, in this application, we update the search
results shown in the client in (near-)real time when new matches are
available. In order to do that, we need some kind of matching mechanism
between searches and new items.

This is where ElasticSearch's
*[[http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-percolate.html][Percolator
feature]]* helps. Percolation queries are kind of reverse searches that
allow the registration of an observing real-time search in the
percolation index. Each new tweet is then presented to the percolation
index in ElasticSearch to determine which of the registered searches
match on the new item.

The registration of queries in the percolation index and the delivery
happens in the percolation component of the *client-facing application*
and will be covered in more detail there. Here, you just need to know
that upon registering a search, a hash of the query is used as the ID so
that any possible query is only ever registered once.

#+CAPTION: Percolator Component with Channels
[[file:images/tc_percolation.png]]

In this component, new tweets are matched against existing searches,
which returns a sequence of matching query IDs. New tweets are received
on the =:percolation= channel and results (tweet with set of matches)
are put on the =:percolation-matches= channel from the
Percolation-Channels component. Here's the
*[[https://github.com/matthiasn/BirdWatch/blob/5fe69fbfaa956039e1f89a26811d0c86775dd594/Clojure-Websockets/TwitterClient/src/clj/birdwatch_tc/percolator/component.clj][component
itself]]*:

#+BEGIN_SRC clojure
  (ns birdwatch-tc.percolator.component
    (:gen-class)
    (:require
     [birdwatch-tc.percolator.elastic :as es]
     [clojure.tools.logging :as log]
     [pandect.core :refer [sha1]]
     [clojure.pprint :as pp]
     [clojurewerkz.elastisch.rest :as esr]
     [com.stuartsierra.component :as component]
     [clojure.core.async :as async :refer [chan tap pipeline-blocking]]))

  (defrecord Percolator [conf channels]
    component/Lifecycle
    (start [component] (log/info "Starting Percolator Component")
           (let [conn (esr/connect (:es-address conf))
                 perc-matches-chan (:percolation-matches channels)
                 perc-chan (:percolation channels)]
             (pipeline-blocking
              2 perc-matches-chan (es/percolation-xf conn) perc-chan)
             (assoc component :conn conn)))
    ;; TODO: proper teardown of resources
    (stop [component] (log/info "Stopping Percolator Component")
          (assoc component :conn nil)))

  (defn new-percolator [conf] (map->Percolator {:conf conf}))

  (defrecord Percolation-Channels []
    component/Lifecycle
    (start [component] (log/info "Starting Percolation Channels Component")
           (assoc component :percolation (chan) :percolation-matches (chan)))
    (stop [component] (log/info "Stop Percolation Channels Component")
          (assoc component :percolation nil :percolation-matches nil)))

  (defn new-percolation-channels [] (map->Percolation-Channels {}))
#+END_SRC

The component follows the pattern of creating =defrecord=s for the
component itself plus an associated channels component in the same way
that we've seen already. You may not have seen *pipeline-blocking* yet,
so let me explain. A
*[[https://clojure.github.io/core.async/#clojure.core.async/pipeline][pipeline]]*
is a *core.async* construct that we can use when we want to take
something off a channel, process it and put the result onto another
channel, all potentially in parallel. In this case, we use two parallel
blocking pipelines since querying ElasticSearch here is a blocking
operation and we want to be able to run two in parallel at any moment.

All we need to supply to the pipeline is a
*[[https://github.com/matthiasn/BirdWatch/blob/5fe69fbfaa956039e1f89a26811d0c86775dd594/Clojure-Websockets/TwitterClient/src/clj/birdwatch_tc/percolator/elastic.clj][transducing
function]]*, which we look at next:

#+BEGIN_SRC clojure
  (ns birdwatch-tc.percolator.elastic
    (:gen-class)
    (:require
     [clojure.tools.logging :as log]
     [pandect.core :refer [sha1]]
     [clojure.pprint :as pp]
     [clojurewerkz.elastisch.rest.percolation :as perc]
     [clojurewerkz.elastisch.rest.response :as esrsp]))

  (defn percolation-xf
    "create transducer for performing percolation"
    [conn]
    (map (fn [t]
           (let [response (perc/percolate conn "percolator" "tweet" :doc t)
                 ;; set with SHAs
                 matches (set (map :_id (esrsp/matches-from response)))]
             [t matches]))))
#+END_SRC

So here's what this function does. For every element (which we know is a
tweet) that the pipeline construct processes by using the transducing
function, we pass the item to the percolator, which first gives us a
response. We then use =esrsp/matches-from= to retrieve the actual
matches, use =map= to only get the =:_id= from each match and create a
=set= from these matches.

Finally, we create a =vector= that contains the set and the actual
tweet: =[t matches]=. This result vector is what we finally put on the
=:percolation-matches= channel.

Note that this component knows nothing about any other part of the
program. The transducer does not even know the target channel; it is
only concerned with the actual processing step.
** TwitterClient - Persistence Component
   :PROPERTIES:
   :CUSTOM_ID: twitterclient---persistence-component
   :END:

This component takes care of persisting tweets to an index in
ElasticSearch. Once again we have a component with the typical lifecycle
functions and an associated =Persistence-Channels= component. Here, this
component only has a single channel, =:persistence=.

#+CAPTION: Persistence Component with Channels
[[file:images/tc_persistence.png]]

Because there is only a channel to take from but no other channel to put
a result onto, we will not use a =pipeline= but instead run a good old
=go-loop=. Inside the
*[[https://github.com/matthiasn/BirdWatch/blob/5fe69fbfaa956039e1f89a26811d0c86775dd594/Clojure-Websockets/TwitterClient/src/clj/birdwatch_tc/persistence/component.clj][component]]*,
there aren't any surprises:

#+BEGIN_SRC clojure
    (ns birdwatch-tc.persistence.component
      (:gen-class)
      (:require
       [birdwatch-tc.persistence.tools :as pt]
       [birdwatch-tc.persistence.elastic :as es]
       [clojure.tools.logging :as log]
       [clojure.pprint :as pp]
       [clojurewerkz.elastisch.rest :as esr]
       [com.stuartsierra.component :as component]
       [clojure.core.async :as async :refer [<! chan go-loop tap]]))

    (defrecord Persistence [conf channels]
      component/Lifecycle
      (start [component]
             (log/info "Starting Persistence Component")
             (let [conn (esr/connect (:es-address conf))]
               (es/run-persistence-loop (:persistence channels) conf conn)
               (assoc component :conn conn)))
      (stop [component] ;; TODO: proper teardown of resources
            (log/info "Stopping Persistence Component")
            (assoc component :conn nil)))

    (defn new-persistence [conf] (map->Persistence {:conf conf}))

    (defrecord Persistence-Channels []
      component/Lifecycle
      (start [component] (log/info "Starting Persistence Channels Component")
             (assoc component :persistence (chan)))
      (stop [component] (log/info "Stop Persistence Channels Component")
            (assoc component :persistence nil)))

    (defn new-persistence-channels [] (map->Persistence-Channels {}))
#+END_SRC

All we see above is yet another component that really only has the
single channel =:persistence= inside the =Persistence-Channels=
component and that
*[[https://github.com/matthiasn/BirdWatch/blob/43a9c09493257b9c9b5e9e5644df5f67085feb84/Clojure-Websockets/TwitterClient/src/clj/birdwatch_tc/percolator/elastic.clj][starts]]*
said =go-loop= and passes the channel plus some configuration and the
connection object.

#+BEGIN_SRC clojure
    (ns birdwatch-tc.persistence.elastic
      (:gen-class)
      (:require
       [clojure.tools.logging :as log]
       [clojure.pprint :as pp]
       [clojurewerkz.elastisch.rest :as esr]
       [clojurewerkz.elastisch.rest.document :as esd]
       [clojure.core.async :as async :refer [<! chan put! timeout go-loop]]))

    (defn run-persistence-loop
      "run loop for persisting tweets"
      [persistence-chan conf conn]
      (go-loop [] (let [t (<! persistence-chan)]
                    (try
                      (esd/put conn (:es-index conf) "tweet" (:id_str t) t)
                      (catch Exception ex (log/error ex "esd/put error"))))
               (recur)))
#+END_SRC

The =go-loop= above is pretty straightforward. Whatever we encounter on
this channel, we try to persist in ElasticSearch, inside the index as
specified in =(:es-index conf)=, for type =tweet=, with =(:id_str t)=as
the *document id* and finally with the tweet =t= itself.

This makes me think that I've been wanting to implement
*[[https://github.com/Prismatic/schema][schema]]* for a while now. I
don't mind using a plain old map to represent a tweet, but coming from
strongly typed languages, I would at least like something to blow up
when the item does not conform to an expected schema as opposed to
storing something completely different while still calling its type in
ElasticSearch =tweet=. Certainly an improvement to make soon.

Have you noticed a pattern? Once again, nothing in this component (and
the associated namespace) knows anything about any other part of the
application. The only thing I'd be okay with sharing in this context
would be a schema for the tweet as mentioned above. The schema should
then be maintained in one place for the entire system.
** TwitterClient - InterOp Component
   :PROPERTIES:
   :CUSTOM_ID: twitterclient---interop-component
   :END:

In the "Scaling Out" section of the architectural overview, I drew a
picture of how I wanted to break apart the initial monolithic
application and instead run different parts of the application in
separate processes / separate JVMs. The idea was to have a single client
for the connection to the
*[[https://dev.twitter.com/streaming/overview][Twitter Streaming API]]*
and the persistence of the received tweets in
*[[http://www.elasticsearch.com][ElasticSearch]]*, plus multiple
machines to serve WebSocket connections to the client. For the
communication between the processes, I picked
*[[http://redis.io/topics/pubsub][Redis Pub/Sub]]* because its model of
communication suits the requirements really well.

#+CAPTION: Redesigned Architecture - InterOp
[[file:images/redesign2.png]]

*** Redis Pub/Sub with Carmine
    :PROPERTIES:
    :CUSTOM_ID: redis-pubsub-with-carmine
    :END:

I chose *Pub/Sub* over a queue because I wanted to
*[[http://en.wikipedia.org/wiki/Fan-out][fan-out]]* messages to multiple
clients. Any connected processes are only supposed to be fed with data
during their uptime, with no need to store anything for when they aren't
connected. For interfacing with *Redis* from Clojure, I then chose
*[[https://twitter.com/ptaoussanis][Peter Taoussanis]]*'s
*[[https://github.com/ptaoussanis/carmine][carmine]]* client and it
turned out to be a great choice.

Let's look at some code. First of all, I am using a *component* that
provides a *send channel* and a *receive channel*. It can be reused on
either side of the Pub/Sub connection (or for bidirectional
communication, of course). Here's the
*[[https://github.com/matthiasn/BirdWatch/blob/4ce6d8ff70359df9f98421c12984d24d0f311f6f/Clojure-Websockets/TwitterClient/src/clj/birdwatch_tc/interop/component.clj][code]]*.

#+BEGIN_SRC clojure
  (ns birdwatch-tc.interop.component
    (:gen-class)
    (:require
     [birdwatch-tc.interop.redis :as red]
     [clojure.tools.logging :as log]
     [clojure.pprint :as pp]
     [com.stuartsierra.component :as component]
     [clojure.core.async :as async :refer [chan]]))

  ;;; The interop component allows sending and receiving messages via
  ;;; Redis Pub/Sub. It has both a :send and a :receive channel and can be
  ;;; used on both sides of the Pub/Sub.
  (defrecord Interop [conf channels]
    component/Lifecycle
    (start [component] (log/info "Starting Interop Component")
           (let [conn {:pool {} :spec {:host (:redis-host conf) :port (:redis-port conf)}}]
             (red/run-send-loop (:send channels) conn "matches")
             (assoc component :conn conn)))
    ;; TODO: proper teardown of resources
    (stop  [component] (log/info "Stopping Interop Component")
           (assoc component :conn nil)))

  (defn new-interop [conf] (map->Interop {:conf conf}))

  (defrecord Interop-Channels []
    component/Lifecycle
    (start [component] (log/info "Starting Interop Channels Component")
           (assoc component :send (chan) :receive (chan)))
    (stop  [component] (log/info "Stop Interop Channels Component")
           (assoc component :send nil :receive nil)))

  (defn new-interop-channels [] (map->Interop-Channels {}))
#+END_SRC

The =Interop-Channels= component can now be wired into the =Interop=
component where we create a configuration map and start a send loop with
this configuration for the *"matches"* topic. Here's that
*[[https://github.com/matthiasn/BirdWatch/blob/4ce6d8ff70359df9f98421c12984d24d0f311f6f/Clojure-Websockets/TwitterClient/src/clj/birdwatch_tc/interop/redis.clj][run-send-loop]]*
function:

#+BEGIN_SRC clojure
    (ns birdwatch-tc.interop.redis
      (:gen-class)
      (:require
       [clojure.tools.logging :as log]
       [clojure.pprint :as pp]
       [clojure.core.match :as match :refer (match)]
       [taoensso.carmine :as car :refer (wcar)]
       [clojure.core.async :as async :refer [<! put! go-loop]]))

    (defn run-send-loop
      "loop for sending items by publishing them on a Redis pub topic"
      [send-chan conn topic]
      (go-loop [] (let [msg (<! send-chan)]
                    (car/wcar conn (car/publish topic msg))
                    (recur))))

    (defn- msg-handler-fn
      "create handler function for messages from Redis Pub/Sub"
      [receive-chan]
      (fn [[msg-type topic payload]]
        (when (= msg-type "message")
          (put! receive-chan payload))))

    (defn subscribe-topic
      "subscribe to topic, put items on specified channel"
      [receive-chan conn topic]
      (car/with-new-pubsub-listener
        (:spec conn)
        {"matches" (msg-handler-fn receive-chan)}
        (car/subscribe topic)))

    (defn unsubscribe
      "unsubscribe listener from all topics"
      [listener]
      (car/with-open-listener listener (car/unsubscribe)))

    (defn close
      "close listener"
      [listener]
      (car/close-listener listener))
#+END_SRC

Here, we are only using =run-send-loop= to start sending all messages
that come in on a channel. Specifically, this=go-loop= consumes all
messages that come in on the =send-chan= channel and publishes them on
the =topic= in Redis for the specified configuration connection =conn=.
None of the other functions is used here, but this component is the same
on both sides of the pub/sub. We will look at the counterpart when
looking at the *MainApp* application.

Here's a drawing of this component together with the channels:

#+CAPTION: InterOp Component with Channels
[[file:images/tc_interop.png]]

*** Performance of Redis
    :PROPERTIES:
    :CUSTOM_ID: performance-of-redis
    :END:

Redis does a lot with very little CPU utilization. In a non-scientific
test, I fired up 50 JVMs (on four machines) subscribing to the topic on
which the TwitterClient publishes tweets with matched percolation
queries. Then I changed the tracked term from the
*[[https://dev.twitter.com/streaming/overview][Twitter Streaming API]]*
to *"love"*, which reliably maxes out the rate of tweets permitted.
Typically, with this term I see around *60 to 70* tweets per second.
With 50 connected processes, *3000 to 3500* tweets were delivered per
second overall, yet the CPU utilization of Redis idled somewhere between
*1.7%* and *2.3%*.

#+Latex:\pagebreak
* Server-side: MainApp
  :PROPERTIES:
  :CUSTOM_ID: server-side-mainapp
  :END:

** Architectural Overview
   :PROPERTIES:
   :CUSTOM_ID: architectural-overview
   :END:

This application handles the interaction with the web clients. It
receives tweets via subscribing to a Redis Pub/Sub and distributes them
to the connected clients when there's a match between the query of a
client and a new incoming tweet.

There can be multiple instances of this application, allowing the entire
system to be horizontally scalable.

#+CAPTION: MainApp Application
[[file:images/mainapp.png]]
** MainApp - InterOp Component
   :PROPERTIES:
   :CUSTOM_ID: mainapp---interop-component
   :END:

This component takes care of receiving data from another JVM. As a quick
reminder, this application subscribes to a
*[[http://redis.io/topics/pubsub][Redis Pub/Sub]]*:

#+CAPTION: Redesigned Architecture - InterOp
[[file:images/redesign2.png]]

The code is comparable to the =InterOp= component on the other side,
only that on this
*[[https://github.com/matthiasn/BirdWatch/blob/43a9c09493257b9c9b5e9e5644df5f67085feb84/Clojure-Websockets/MainApp/src/clj/birdwatch/interop/component.clj][side]]*
we don't publish but subscribe.

#+CAPTION: MainApp - InterOp Component
[[file:images/mainapp_interop.png]]

#+BEGIN_SRC clojure
  (ns birdwatch.interop.component
    (:gen-class)
    (:require
     [birdwatch.interop.redis :as red]
     [clojure.tools.logging :as log]
     [clojure.pprint :as pp]
     [com.stuartsierra.component :as component]
     [clojure.core.async :as async :refer [chan]]))

  ;;; The interop component allows sending and receiving messages via
  ;;; Redis Pub/Sub. It has both a :send and a :receive channel and can be
  ;;; used on both sides of the Pub/Sub.
  (defrecord Interop [conf channels listener]
    component/Lifecycle
    (start [component] (log/info "Starting Interop Component")
      (let [conn {:pool {}
                  :spec {:host (:redis-host conf)
                         :port (:redis-port conf)}}
            listener
            (red/subscribe-topic (:receive channels) conn "matches")]
             (assoc component :conn conn :listener listener)))
    (stop  [component] (log/info "Stopping Interop Component")
           (red/unsubscribe listener)
           (red/close listener)
           (assoc component :conn nil :listener nil)))

  (defn new-interop [conf] (map->Interop {:conf conf}))

  (defrecord Interop-Channels []
    component/Lifecycle
    (start [component] (log/info "Starting Interop Channels Component")
           (assoc component :send (chan) :receive (chan)))
    (stop  [component] (log/info "Stop Interop Channels Component")
           (assoc component :send nil :receive nil)))

  (defn new-interop-channels [] (map->Interop-Channels {}))
#+END_SRC

No big surprises here. Just like for the publisher side, there's the
configuration map. Next, we subscribe to a topic and hold on to the
returned listener so that we can unsubscribe from the topic and close it
later. All of these functions can be found in the =redis=
*[[https://github.com/matthiasn/BirdWatch/blob/43a9c09493257b9c9b5e9e5644df5f67085feb84/Clojure-Websockets/MainApp/src/clj/birdwatch/interop/redis.clj][namespace]]*,
which is the same as on the other side of the pub/sub:

#+BEGIN_SRC clojure
    (ns birdwatch.interop.redis
      (:gen-class)
      (:require
       [clojure.tools.logging :as log]
       [clojure.pprint :as pp]
       [clojure.core.match :as match :refer (match)]
       [com.matthiasnehlsen.inspect :as inspect :refer [inspect]]
       [taoensso.carmine :as car :refer (wcar)]
       [clojure.core.async :as async :refer [<! put! go-loop]]))

    (defn run-send-loop
      "loop for sending items by publishing them on a Redis pub topic"
      [send-chan conn topic]
      (go-loop [] (let [msg (<! send-chan)]
                    (car/wcar conn (car/publish topic msg))
                    (recur))))

    (defn- msg-handler-fn
      "create handler function for messages from Redis Pub/Sub"
      [receive-chan]
      (fn [[msg-type topic payload]]
        (when (= msg-type "message")
          (inspect :redis/receive payload)
          (put! receive-chan payload))))

    (defn subscribe-topic
      "subscribe to topic, put items on specified channel"
      [receive-chan conn topic]
      (car/with-new-pubsub-listener
        (:spec conn)
        {"matches" (msg-handler-fn receive-chan)}
        (car/subscribe topic)))

    (defn unsubscribe
      "unsubscribe listener from all topics"
      [listener]
      (car/with-open-listener listener (car/unsubscribe)))

    (defn close
      "close listener"
      [listener]
      (car/close-listener listener))
#+END_SRC

The only difference between both sides of the *pub/sub* lies in the
functions we use. One could also implement bidirectional communication
between two components by utilizing all of these functions. Maybe this
is something that could be moved into a library at some point when
having a clearer understanding of real-world requirements.
** MainApp - SwitchBoard Component
   :PROPERTIES:
   :CUSTOM_ID: mainapp---switchboard-component
   :END:

The =SwitchBoard= component is comparable to the one that we saw in the
*TwitterClient* application, only with more channels involved.

#+CAPTION: MainApp - SwitchBoard Component
[[file:images/mainapp_switchboard.png]]

Let's look at the code:

#+BEGIN_SRC clojure
  (ns birdwatch.switchboard
    (:gen-class)
    (:require
     [clojure.tools.logging :as log]
     [com.stuartsierra.component :as component]
     [clojure.core.async :as async :refer [chan mult tap pipe]]))

  ;;;; This component is the central switchboard for information flow in
  ;;;; this application. The individual channel components come together
  ;;;; like wiring harnesses in a car.

  (defrecord Switchboard [comm-chans pers-chans perc-chans iop-chans]
    component/Lifecycle
    (start
      [component]
      (log/info "Starting Switchboard Component")
      (let [tweets-mult (chan)]
        ;; Connect channels 1 on 1. Here, it would be easy to add message logging.
        (pipe (:tweet-count pers-chans) (:tweet-count comm-chans))
        (pipe (:register-perc comm-chans) (:register-percolation perc-chans))
        (pipe (:receive iop-chans) (:percolation perc-chans))
        (pipe (:percolation-matches perc-chans) (:perc-matches comm-chans))
        (pipe (:tweet-missing comm-chans) (:tweet-missing pers-chans))
        (pipe (:missing-tweet-found pers-chans) (:missing-tweet-found comm-chans))
        (pipe (:query comm-chans) (:query pers-chans))
        (pipe (:query-results pers-chans) (:query-results comm-chans))
        (assoc component :tweets-mult tweets-mult)))

    (stop [component] (log/info "Stopping Switchboard Component")
      (assoc component :tweets-mult nil)))

  (defn new-switchboard [] (map->Switchboard {}))
#+END_SRC

In this component, we only =pipe= channels into each other thus
facilitating only one-on-one connections. When looking at the code right
now, I realize that the =tweets-mult= is actually not used at all. I
remember though that when removing it and reloading the application on
the *repl*, the application did not work any longer. Supposedly, that
had something to do with the *component* library not recognizing that
anything in the component could change and thus holding on to the wrong
component instance from the first initialization and, as a result,
holding on to channels that aren't in use any longer. But that is just a
hunch and probably should be explored further.
** MainApp - Persistence Component
   :PROPERTIES:
   :CUSTOM_ID: mainapp---persistence-component
   :END:

This component takes care of responding to queries for previous tweets
by retrieving them from an index in ElasticSearch so that they can be
delivered to the connected web client. It also responds to queries for
single tweets that are missing in the user interface. This is not used
yet but will be used in the future. Finally, this component runs a loop
that frequently sends out stats about the size of the ElasticSearch
index that stores all the tweets.

#+CAPTION: MainApp - Persistence Component
[[file:images/mainapp_persistence.png]]

Here's how the
*[[https://github.com/matthiasn/BirdWatch/blob/d104db4a7ac7a745593e34398751f81a50d167d0/Clojure-Websockets/MainApp/src/clj/birdwatch/persistence/component.clj][component]]*
looks like:

#+BEGIN_SRC clojure
  (ns birdwatch.persistence.component
    (:gen-class)
    (:require
     [birdwatch.persistence.elastic :as es]
     [clojure.tools.logging :as log]
     [clojure.pprint :as pp]
     [clojurewerkz.elastisch.rest :as esr]
     [com.stuartsierra.component :as component]
     [clojure.core.async
      :as async
      :refer [<! chan go-loop tap pipeline-blocking]]))

  (defrecord Persistence [conf channels]
    component/Lifecycle
    (start [component]
      (log/info "Starting Persistence Component")
      (let [conn (esr/connect (:es-address conf))
            q-chan (:query channels)
            q-res-chan (:query-results channels)
            mt-chan (:tweet-missing channels)
            mt-res-chan (:missing-tweet-found channels)]
        (pipeline-blocking 4 q-res-chan (es/query-xf conf conn) q-chan)
        (pipeline-blocking 2 mt-res-chan (es/tweet-query-xf conf conn) mt-chan)
        (es/run-tweet-count-loop (:tweet-count channels) conf conn)
        (assoc component :conn conn)))
    (stop [component] ;; TODO: proper teardown of resources
      (log/info "Stopping Persistence Component")
      (assoc component :conn nil)))

  (defn new-persistence [conf] (map->Persistence {:conf conf}))

  (defrecord Persistence-Channels []
    component/Lifecycle
    (start [component] (log/info "Starting Persistence Channels Component")
      (assoc component
             :query (chan)
             :query-results (chan)
             :tweet-missing (chan)
             :missing-tweet-found (chan)
             :tweet-count (chan)))
    (stop [component] (log/info "Stop Persistence Channels Component")
      (assoc component :query nil :query-results nil :tweet-missing nil :missing-tweet-found nil
             :tweet-count nil)))

  (defn new-persistence-channels [] (map->Persistence-Channels {}))
#+END_SRC

Once again, we are using =pipeline=s and associated transducing
functions for taking a query off a channel and putting the result on
another channel. In the case of queries for a number of previous tweets,
the query is taken off the =:query= channel, processed by =es/query-xf=
and the result put onto the =:query-results= channel.

Here is the
*[[https://github.com/matthiasn/BirdWatch/blob/3c793a8ded198ba9aa2360f1efb538dd548383b2/Clojure-Websockets/MainApp/src/clj/birdwatch/persistence/elastic.clj][namespace]]*
with the functions that are used in the component:

#+BEGIN_SRC clojure
  (ns birdwatch.persistence.elastic
    (:gen-class)
    (:require
     [birdwatch.persistence.tools :as pt]
     [com.matthiasnehlsen.inspect :as inspect :refer [inspect]]
     [clojure.tools.logging :as log]
     [clojure.pprint :as pp]
     [clojurewerkz.elastisch.rest :as esr]
     [clojurewerkz.elastisch.rest.document :as esd]
     [clojurewerkz.elastisch.query :as q]
     [clojurewerkz.elastisch.rest.response :as esrsp]
     [clojure.core.async
      :as async
      :refer [<! <!! chan put! timeout go-loop thread onto-chan]]))

  (defn query
    "run a query on previous matching tweets"
    [{:keys [query n from]} conf conn]
    (let [search
          (esd/search conn (:es-index conf) "tweet"
                      :query query
                      :size n
                      :from from
                      :sort {:id :desc})
          hits (esrsp/hits-from search)
          source (pt/get-source hits)
          res (vec source)]
      res))

  (defn query-xf
    "create transducer for answering queries"
    [conf conn]
    (map (fn [q]
           (inspect :elastic/query q)
           {:uid (:uid q) :result (query q conf conn)})))

  (defn tweet-query-xf
    "create transducer for finding missing tweets"
    [conf conn]
    (map (fn [req]
           (let [res (esd/get conn (:es-index conf) "tweet" (:id_str req))]
             (inspect :elastic/missing {:req req :res res})
             (when-not res (log/debug "birdwatch.persistence missing" (:id_str req) res))
             {:tweet (pt/strip-source res) :uid (:uid req)}))))

  (defn run-tweet-count-loop
    "run loop for sending stats about total number of indexed tweets"
    [tweet-count-chan conf conn]
    (go-loop [] (<! (timeout 10000))
             (let [cnt (esd/count conn (:es-index conf) "tweet")]
               (inspect :elastic/tweet-count cnt)
               (put! tweet-count-chan (format "%,15d" (:count cnt))))
             (recur)))
#+END_SRC

The =query-xf= transducing function really only calls the =query=
function and passes the result of that query on to a map that also
contains the =:uid= of the requesting client. This is kind of the
address field on an envelope if you will. The =query= function then
retrieves tweets from ElasticSearch and runs =pt/get-source= on each
chunk, which gets source data from the query result. We will look at
that briefly below.

The =tweet-query-xf= transducing function is comparable to the one
above, only that it directly queries ElasticSearch and returns query
matches for missing tweets to the correct channel.

Then, there's also the =run-tweet-count-loop= function. It runs a
=go-loop= that gets executed every 10 seconds and then gets the size of
the tweet index and puts that on a channel. Eventually, this will be
broadcast to all connected web clients for display in the user
interface.

Finally, there are additional helper functions in a separate
*[[https://github.com/matthiasn/BirdWatch/blob/d104db4a7ac7a745593e34398751f81a50d167d0/Clojure-Websockets/MainApp/src/clj/birdwatch/persistence/tools.clj][namespace]]*:

#+BEGIN_SRC clojure
    (ns birdwatch.persistence.tools
      (:gen-class))

    (defn- strip-tweet
      "take only actually needed fields from tweet"
      [t]
      (let [u (:user t)]
        {:id_str (:id_str t)
         :id (:id t)
         :text (:text t)
         :created_at (:created_at t)
         :retweet_count (:retweet_count t)
         :favorite_count (:favorite_count t)
         :entities (:entities t)
         :user {:followers_count (:followers_count u)
                :name (:name u)
                :profile_image_url (:profile_image_url u)
                :screen_name (:screen_name u)}}))

    (defn strip-source
      "get tweet stripped down to necessary fields"
      [val]
      (let [s (:_source val)
            t (strip-tweet s)
            rt (:retweeted_status s)]
        (if rt
          (assoc t :retweeted_status (strip-tweet rt))
          t)))

    (defn get-source
      "get vector with :_source of each ElasticSearch result"
      [coll]
      (map strip-source coll))
#+END_SRC

All the functions above do is unwrap an ElasticSearch result and strip
tweets from all the keys that aren't actually used by the client.
Nothing fancy here, only something to reduce the payload size when
returning query results via the WebSocket connection to the client
asking for the tweets.
** MainApp - Percolation Component
   :PROPERTIES:
   :CUSTOM_ID: mainapp---percolation-component
   :END:

This component first of all receives registration requests from
connected web clients via the =:register-percolation= channel. For that,
it keeps information about all current =subscriptions= in an =atom=.

The component also receives the =[t matches]= vectors on the
=:percolation= channel. These originate from the =Percolator= component
inside the *TwitterClient* application, each of which contains a =map=
with a =tweet= plus a =set= with the IDs of all the =matches=.

A transducing function which has access to the =subscriptions= atom then
passes the vector on, enriched by the dereferenced =@subscriptions=.
This transducing function is used by a =pipeline= that takes each item
off the =:percolation= channel, has the transducing function process
each item and then puts the result on the =:percolation-matches=
channel.

#+CAPTION: MainApp - Percolation Component
[[file:images/mainapp_percolation.png]]

Without further ado, here's the
*[[https://github.com/matthiasn/BirdWatch/blob/43a9c09493257b9c9b5e9e5644df5f67085feb84/Clojure-Websockets/MainApp/src/clj/birdwatch/percolator/component.clj][code]]*:

#+BEGIN_SRC clojure
  (ns birdwatch.percolator.component
    (:gen-class)
    (:require
     [birdwatch.percolator.elastic :as es]
     [clojure.tools.logging :as log]
     [pandect.core :refer [sha1]]
     [clojure.pprint :as pp]
     [clojurewerkz.elastisch.rest :as esr]
     [com.stuartsierra.component :as component]
     [clojure.core.async :as async :refer [chan tap pipeline]]))

  (defrecord Percolator [conf channels]
    component/Lifecycle
    (start [component]
      (log/info "Starting Percolator Component")
      (let [conn (esr/connect (:es-address conf))
            subscriptions (atom {})
            perc-matches-chan (:percolation-matches channels)
            perc-chan (:percolation channels)]
        (pipeline 1 perc-matches-chan (es/percolation-xf subscriptions) perc-chan)
        (es/run-percolation-register-loop (:register-percolation channels) conn subscriptions)
        (assoc component :conn conn :subscriptions subscriptions)))
    ;; TODO: proper teardown of resources
    (stop [component] (log/info "Stopping Percolator Component")
      (assoc component :conn nil :subscriptions nil)))

  (defn new-percolator [conf] (map->Percolator {:conf conf}))

  (defrecord Percolation-Channels []
    component/Lifecycle
    (start [component] (log/info "Starting Percolation Channels Component")
      (assoc component :percolation (chan) :register-percolation (chan) :percolation-matches (chan)))
    (stop [component] (log/info "Stop Percolation Channels Component")
      (assoc component :percolation nil :register-percolation nil :percolation-matches nil)))

  (defn new-percolation-channels [] (map->Percolation-Channels {}))
#+END_SRC

If the explanations above haven't made a lot of sense to you yet, no
worries, the
*[[https://github.com/matthiasn/BirdWatch/blob/43a9c09493257b9c9b5e9e5644df5f67085feb84/Clojure-Websockets/MainApp/src/clj/birdwatch/percolator/elastic.clj][code]]*
will explain:

#+BEGIN_SRC clojure
    (ns birdwatch.percolator.elastic
      (:gen-class)
      (:require
       [clojure.tools.logging :as log]
       [pandect.core :refer [sha1]]
       [clojure.pprint :as pp]
       [com.matthiasnehlsen.inspect :as inspect :refer [inspect]]
       [clojurewerkz.elastisch.rest.percolation :as perc]
       [clojurewerkz.elastisch.rest.response    :as esrsp]
       [clojure.core.async :as async :refer [<! put! go-loop]]))

    (defn start-percolator
      "register percolation search with ID based on hash of the query"
      [{:keys [query uid]} conn subscriptions]
      (let [sha (sha1 (str query))]
        (swap! subscriptions assoc uid sha)
        (perc/register-query conn "percolator" sha :query query)
        (inspect :perc/start-percolator {:query query :sha sha})))

    (defn run-percolation-register-loop
      "loop for finding percolation matches and delivering those on the appropriate socket"
      [register-percolation-chan conn subscriptions]
      (go-loop [] (let [params (<! register-percolation-chan)]
                    (inspect :perc/params params)
                    (start-percolator params conn subscriptions)
                    (recur))))

    (defn percolation-xf
      "create transducer for adding de-ref'd subscription to percolation result"
      [subscriptions]
      (map (fn [[t matches]] [t matches @subscriptions])))
#+END_SRC

In =run-percolation-loop=, the =params= of a *search* are taken off the
=register-percolation-chan= and the =start-percolator= function is
called with this map, the connection =conn= and the =subscriptions=
atom. This function then uses =query= and =uid= from =params= to =swap!=
the =subscriptions= atom by =assoc=ing the =sha= hash of a query into
the map under the =uid= key. In addition, it registers the =query= in
ElasticSearch's percolator index, with the =sha= as the ID.

Finally, the =percolation-xf= transducing function, as mentioned above,
enriches the vector it receives by adding the dereferenced
=@subscriptions= in the third position. The *WebsocketComponent* will
eventually do the matchmaking, but we will look at that when we discuss
the component. Here, we don't need to know any of that, all we need to
know is the data structure that's expected down the line. That's what I
find so beautiful about using *core.async* in conjunction with the
*component* library, as we do in this application.
** WebSocket Communication Component
   :PROPERTIES:
   :CUSTOM_ID: websocket-communication-component
   :END:

This component handles the interaction with the web clients. It
distributes messages coming from WebSocket clients to the appropriate
channels of the application and vice versa.

#+CAPTION: MainApp - Communicator Component
[[file:images/mainapp_communicator.png]]

The actual communication over the network is then handled by the
HttpComponent which we will look at briefly in the next chapter. Here
are the =Communicator= and the `=Communicator-Channels=
*[[https://github.com/matthiasn/BirdWatch/blob/a7a27c76fb4a882daa485d0231de30c1cc078652/Clojure-Websockets/MainApp/src/clj/birdwatch/communicator/component.clj][components]]*:

#+BEGIN_SRC clojure
  (ns birdwatch.communicator.component
    (:gen-class)
    (:require
     [clojure.pprint :as pp]
     [clojure.tools.logging :as log]
     [birdwatch.communicator.websockets :as ws]
     [taoensso.sente :as sente]
     [taoensso.sente.packers.transit :as sente-transit]
     [com.stuartsierra.component :as component]
     [clojure.core.async :as async :refer [chan]]))

  ;; serialization format for client<->server comm
  (def packer (sente-transit/get-flexi-packer :json))

  (defrecord Communicator [channels chsk-router]
    component/Lifecycle
    (start [component]
      (log/info "Starting Communicator Component")
      (let [{:keys [ch-recv send-fn ajax-post-fn ajax-get-or-ws-handshake-fn connected-uids]}
            (sente/make-channel-socket! {:packer packer :user-id-fn ws/user-id-fn})
            event-handler (ws/make-handler (:query channels) (:tweet-missing channels) (:register-perc channels))
            chsk-router (sente/start-chsk-router! ch-recv event-handler)]
        (ws/run-users-count-loop send-fn connected-uids)
        (ws/send-loop (:perc-matches channels) (ws/perc-matches connected-uids send-fn))
        (ws/send-loop (:tweet-count channels) (ws/tweet-stats connected-uids send-fn))
        (ws/send-loop (:query-results channels) (ws/relay-msg :tweet/prev-chunk :result send-fn))
        (ws/send-loop (:missing-tweet-found channels) (ws/relay-msg :tweet/missing-tweet :tweet send-fn))
        (assoc component :ajax-post-fn ajax-post-fn
               :ajax-get-or-ws-handshake-fn ajax-get-or-ws-handshake-fn
               :chsk-router chsk-router)))
    (stop [component] (log/info "Stopping Communicator Component")
      (chsk-router) ;; stops router loop
      (assoc component :chsk-router nil)))

  (defn new-communicator [] (map->Communicator {}))

  (defrecord Communicator-Channels []
    component/Lifecycle
    (start [component] (log/info "Starting Communicator Channels Component")
      (assoc component
             :query (chan)
             :query-results (chan)
             :tweet-missing (chan)
             :missing-tweet-found (chan)
             :tweet-count (chan)
             :register-perc (chan)
             :perc-matches (chan)))
    (stop [component] (log/info "Stop Communicator Channels Component")
      (assoc component :query nil :query-results nil :tweet-missing nil
             :missing-tweet-found nil :tweet-count nil)))

  (defn new-communicator-channels [] (map->Communicator-Channels {}))
#+END_SRC

The =Communicator-Channels= component has more channels than the other
components we've seen so far, but there's really no limit on how many we
can use. There's a channel for passing query requests on from clients to
some query processor, another channel for results, the same for missing
tweets, a channel to send off requests for registering percolation, a
channel that frequently delivers stats about the index size in
ElasticSearch and a channel that delivers the percolation matches. Note
that like in all other components, we don't have to know anything about
the implementation of any other component in the system. All we need to
know are the channels for interfacing with the outside world.

Here's the associated
*[[https://github.com/matthiasn/BirdWatch/blob/3c793a8ded198ba9aa2360f1efb538dd548383b2/Clojure-Websockets/MainApp/src/clj/birdwatch/communicator/websockets.clj][namespace]]*:

#+BEGIN_SRC clojure
    (ns birdwatch.communicator.websockets
      (:gen-class)
      (:require
       [clojure.core.match :as match :refer (match)]
       [clojure.pprint :as pp]
       [clojure.tools.logging :as log]
       [taoensso.sente :as sente]
       [com.matthiasnehlsen.inspect :as inspect :refer [inspect]]
       [clojure.core.async :as async :refer [<! >! put! timeout go-loop]]))

    (defn user-id-fn
      "generates unique ID for request"
      [req]
      (let [uid (str (java.util.UUID/randomUUID))]
        (log/info "Connected:" (:remote-addr req) uid)
        uid))

    (defn make-handler
      "create event handler function for the websocket connection"
      [query-chan tweet-missing-chan register-percolation-chan]
      (fn [{event :event}]
        (match event
               [:cmd/percolate params] (put! register-percolation-chan params)
               [:cmd/query params]     (put! query-chan params)
               [:cmd/missing params]   (put! tweet-missing-chan params)
               [:chsk/ws-ping]         () ; currently just do nothing with ping (no logging either)
               :else                   (log/debug "Unmatched event:" (pp/pprint event)))))

    (defn send-loop
      "run loop, call f with message on channel"
      [channel f]
      (go-loop [] (let [msg (<! channel)] (f msg)) (recur)))

    (defn tweet-stats
      "send stats about number of indexed tweets to all connected clients"
      [uids chsk-send!]
      (fn [msg] (doseq [uid (:any @uids)]
                  (chsk-send! uid [:stats/total-tweet-count msg]))))

    (defn perc-matches
      "deliver percolation matches to interested clients"
      [uids chsk-send!]
      (fn [msg]
        (inspect :comm/perc-matches msg)
        (let [[t matches subscriptions] msg]
          (doseq [uid (:any @uids)]
            (when (contains? matches (get subscriptions uid))
              (chsk-send! uid [:tweet/new t]))))))

    (defn relay-msg
      "send query result chunks back to client"
      [msg-type msg-key chsk-send!]
      (fn [msg] (chsk-send! (:uid msg) [msg-type (msg-key msg)])))

    (defn run-users-count-loop
      "runs loop for sending stats about number of connected users to all connected clients"
      [chsk-send! connected-uids]
      (go-loop [] (<! (timeout 2000))
               (let [uids (:any @connected-uids)]
                 (inspect :comm/connected-uids uids)
                 (doseq [uid uids] (chsk-send! uid [:stats/users-count (count uids)])))
               (recur)))
#+END_SRC

The =user-id-fn= function takes care of generating a random UUID for
each new connection.

The =make-handler= function takes care of distributing incoming messages
from clients over WebSocket connections depending on their type, which
is denoted by the first position in a message vector and should be a
namespaced keyword. With that, =core.match= can put the payload onto the
appropriate channels.

The =send-loop= function takes care of sending messages from the server
to the client. It takes a function to call specific to the message type
and a channel to take from. Next, we have functions taking care of
specific messages, for example the =tweet-stats= function, which
delivers the stats to all connected clients whenever a stats message
comes in from the =:tweet-count= channel.

=perc-matches= does the matchmaking between percolation matches and
clients currently connected and will only deliver a new tweet to a
client when that matches the client's search. It is a function that
takes the current =uids= atom plus the =chsk-send!= from *sente* for
delivering tweets to individually connected clients. It then returns
another function that only takes a message from the =:perc-matches=
channel and then checks for each current connection if the =matches= set
contains the =subscriptions= map

Finally, we run a loop that frequently (every 2 seconds) broadcasts the
number of clients currently connected to all clients.
** Http Component
   :PROPERTIES:
   :CUSTOM_ID: http-component
   :END:

The =HttpServer= component handles the network part of the interaction
with the web clients whereas the =Communicator= component mentioned in
the last chapter handles the interaction between client connections and
the rest of the application.

#+CAPTION: MainApp - Http Component
[[file:images/mainapp_http.png]]

The =Communicator= component is a dependency of the =HttpServer= and
gets passed when the application starts. Let's dive right into the
*[[https://github.com/matthiasn/BirdWatch/blob/574d2178be6f399086ad2a5ec35c200d252bf887/Clojure-Websockets/MainApp/src/clj/birdwatch/http/component.clj][code]]*:

#+BEGIN_SRC clojure
  (ns birdwatch.http.component
    (:gen-class)
    (:require
     [clojure.tools.logging :as log]
     [org.httpkit.server :as http-kit-server]
     [ring.middleware.defaults]
     [ring.util.response :refer [resource-response response content-type]]
     [compojure.core     :as comp :refer (defroutes GET POST)]
     [compojure.route    :as route]
     [com.stuartsierra.component :as component]))

  (def ring-defaults-config
    (assoc-in ring.middleware.defaults/site-defaults [:security :anti-forgery]
              {:read-token (fn [req] (-> req :params :csrf-token))}))

  (defn- static-html
    [file-name]
    (content-type (resource-response file-name {:root "public"}) "text/html"))

  (defrecord Httpserver [conf comm server]
    component/Lifecycle
    (start [component] (log/info "Starting HTTP Component")
      (defroutes my-routes  ; created during start so that the correct communicator instance is used
        (GET  "/"    [] (static-html "index.html"))
        (GET  "/dev" [] (static-html "index-dev.html"))
        (GET  "/chsk" req ((:ajax-get-or-ws-handshake-fn comm) req))
        (POST "/chsk" req ((:ajax-post-fn comm) req))
        (route/resources "/") ; Static files, e.g. /js/build/birdwatch-opt.js (our cljs target)
        (route/not-found "Page not found"))
      (let [my-ring-handler   (ring.middleware.defaults/wrap-defaults my-routes ring-defaults-config)
            server (http-kit-server/run-server my-ring-handler {:port (:port conf)})
            uri (format "http://localhost:%s/" (:local-port (meta server)))]
        (log/info "Http-kit server is running at" uri)
        (assoc component :server server)))
    (stop [component] (log/info "Stopping HTTP Server")
      (server :timeout 100)
      (assoc component :server nil)))

  (defn new-http-server [conf] (map->Httpserver {:conf conf}))
#+END_SRC

The component code is mostly taken from the
*[[https://github.com/ptaoussanis/sente/blob/master/example-project/src/example/my_app.cljx][sente
example]]*. I've only adapted it to fit into the component lifecycle so
that the server is shut down when the component stops.

#+Latex:\pagebreak
* Server-side Conclusion
  :PROPERTIES:
  :CUSTOM_ID: server-side-conclusion
  :END:

In the previous chapters I have outlined an architecture which, at the
time of writing the code, I believed to be appropriate to meet the
requirements. Now, some time later, I'm naturally skeptical and want to
put this design to the test. Also, there's too much repetition in the
code, which is why I started writing the
*[[https://github.com/matthiasn/systems-toolbox][systems-toolbox]]*
library, which will be described in subsequent chapters.

First of all, I will have to describe the client side though, so that we
get a better understanding of the entire application.

Once that's done, I will try to come up with load testing strategies so
that we'll have a much better idea of what this architecture can do. How
many simultaneous clients can it handle, for example? I have no idea but
I can't wait to find out. All I know is that I've done some tests with
50 concurrent connections while subscribing to a term that maxed out the
Streaming API connection and the application wasn't very busy at all. So
it appears the application could have handled a lot more. Exactly how
many more is what I'd like to find out in subsequent chapters.

#+Latex:\pagebreak
* Old Client-side Architecture
  :PROPERTIES:
  :CUSTOM_ID: old-client-side-architecture
  :END:

On the client side, we have a single-page web application that responds
to new tweets matching a current real-time query with an immediately
updated user interface, including statistics. It is a ClojureScript
application in which different parts of the system are separated by
interacting exclusively via immutable messages put on
*[[file:core.async]]* channels[fn:1]. All state is local to each
component, protecting the state from accidentally mutilating it from
outside the "component" that is the owner of the state. The UI is
rendered using *[[http://reagent-project.github.io][Reagent]]* on top of
*[[http://facebook.github.io/react/][React.js]]*.

** React.js
   :PROPERTIES:
   :CUSTOM_ID: react.js
   :END:

*[[http://facebook.github.io/react/][React.js]]* is a JavaScript UI
rendering library from Facebook that by design works well with immutable
data structures because it doesn't depend on watching for changes inside
mutable objects. Instead, the entire state is rendered into a virtual
DOM every time new state is passed to it. While this may seem like a
waste of CPU resources at first, it is not because we are not talking
about the actual and slow DOM. Instead, React compares the newly
rendered virtual DOM representation with the previous one and only puts
the actual changes it detects into effect. This diffing algorithm is
very fast, resulting in React.js typically beating the more full-fledged
UI frameworks in terms of performance.

This mechanism with passing new state[fn:2] now works particularly well
with immutable data coming from ClojureScript. After running away from
*AngularJS* soon after trying it out with ClojureScript, this came as a
more than welcome and pleasant surprise back in the last quarter of
2013. David Nolen deserves all the praise for discovering this sweet
match between React.js and ClojureScript[fn:3].

** Reagent
   :PROPERTIES:
   :CUSTOM_ID: reagent
   :END:

*[[http://reagent-project.github.io][Reagent]]* provides a thin layer on
top of React.js in which we can use *Hiccup* syntax to write user
interfaces. I think this is wonderfully terse.

However when you study its documentation, you will notice that UI
components directly interact with application state held in atoms. While
that may be fine for small applications, I do not like this approach
when the application becomes more complex and we want to handle state
alterations in a specialized part of the application. In that case, when
I wear the hat of the developer who works on the "business logic" of the
application, I would not want the UI developer to be able to change
something so that all of a sudden my artifact appears to be broken, even
if some other part of the application is to blame. When you think about
an atom, guess what happens when you get a hold of it and run something
like this:

#+BEGIN_SRC clojure
    (reset! app-atom {})
#+END_SRC

Oops. Now this major glitch would be easy to detect, at least in terms
of something serious being wrong, but the effect could be much more
subtle by only altering or removing a key somewhere inside the
application state. Long story short, as the business logic guy, I would
sleep better when the devs working on other parts of the application
could not cause these problems. This does not change at all when the UI
guy happens to be me. When my mind works in the context of UI, it
shouldn't also have to be careful about not accidentally tripping on
some wire in the business logic. It's a major selling point for
immutable data, after all, that it's safe to pass around. An atom is not
safe to pass around. Anyone who gets a hold of it can do anything to it.
Only the dereferenced value inside an atom at any given moment in time
is safe to pass around.

** Ownership of Application State
   :PROPERTIES:
   :CUSTOM_ID: ownership-of-application-state
   :END:

Ownership of the application state did not seem like a big deal when I
first started working on the application. But when I realized that
encapsulation also entails limiting write access to application state, I
rewrote the client-side code base. Now, there's a state namespace that
is responsible for modifying and guarding application state. There
actually are a few namespaces around the state namespace, but they only
either contain pure functions or act on the application state atom that
is passed to them as an argument. All application state is encapsulated
in an atom inside a let binding in the function that initializes the
application state.

All changes to the application state are then broadcast using a
*core.async Pub/Sub*, but only as the dereferenced application state it
was at the time of dereferencing it. The application state messages
broadcasted this way are immutable, so no subscriber can accidentally
mutate or mutilate them in any way. You can think of it like TV
stations, broadcasting moving images over the air. An arbitrary number
of viewers can then tune in, select a channel (topic in the case of
Pub/Sub) and watch. What you'll watch is usually immutable, except for
some kind of backchannel like the telephone, email, or an actual letter.
But then it is completely up to the TV station of how to deal with these
messages. No ordinary viewer can just mess the experience up for all the
other viewers[fn:4].

I want the same kind of conceptual protection for my application's
state. This is handled nicely by encapsulating it inside a function and
only interacting via channels, where the control on how to deal with
incoming messages lies entirely with the state's owner.

Here's an architectural overview:

[[file:images/client-overview.png]]

Just like in radio or TV broadcast, the sender (in this case the State
component) does not know who has tuned in at any moment in time, and
there's also no way for the receivers to alter the content. The only way
to interact with the state owner is by using a backchannel, in this case
the =cmd-chan=. It is then entirely up to the State component how to
deal with these messages, just like it is up to the TV station how to
deal with me sending an email with a complaint how bad their shows are.

** Constraints
   :PROPERTIES:
   :CUSTOM_ID: constraints
   :END:

Generally, as a constraint, there should be as few external JavaScript
dependencies as possible. The following libraries have recently been
removed and replaced by ClojureScript code:

- *[[http://code.shutterstock.com/rickshaw/][Rickshaw]]* - timeseries
  chart library, replaced by directly manipulating SVG from
  ClojureScript
- *[[https://github.com/Tom-Alexander/regression-js][Regression.js]]* -
  library for regression analysis, replaced by translating a Common Lisp
  library to Clojure.
- Wordcount bar chart - previous implementation was realized with
  React.js in JavaScript, now implemented in ClojureScript

The following libraries are still required, however should also be
replaced where possible, depending on the time available:

- *[[http://momentjs.com][Moment.js]]* - required for date formatting
  and parsing
- *[[http://d3js.org][D3.js]]* - required for the word cloud
- *[[https://github.com/jasondavies/d3-cloud][d3.layout.cloud.js]]*
- *[[https://github.com/matthiasn/BirdWatch/blob/43a9c09493257b9c9b5e9e5644df5f67085feb84/Clojure-Websockets/MainApp/resources/public/js/wordcloud.js][wordcloud.js]]* -
  own JavaScript implementation for interacting with d3.layout.cloud.js

[fn:1] I find that Rich Hickey's talks are the best source for learning
       about core.async. I've made some transcripts for the most
       important talks because I personally benefit a lot from reading
       something in addition to listening to a talk. Check out my
       *[[https://github.com/matthiasn/talk-transcripts][talk-transcipts]]*
       on GitHub. There's really no way around taking the time for
       listening and / or reading these. Briefly summarized, Rich
       compares channels to conveyor belts onto which application
       components put messages without having to care what happens on
       the other side. This makes for a great abstraction for decoupling
       parts of an application.

[fn:2] State passed from the outside and conceptually treated as
       immutable data is called *Props* in React's terminology.

[fn:3] David's article
       *[[http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/][The
       Future of JavaScript MVC Frameworks]]* hit me while I was working
       on a book about AngularJS. I realized, oh darn, he's right, what
       I'm doing here doesn't make the amount of sense that I would want
       it to make, so I quit working on the book. While slightly
       discomforting back then, I am glad I followed my intuition.
       Immutable data in the browser is pure bliss.

[fn:4] Unless, of course, you're the owner of the channel and make
       stupid decisions as to what TV shows and films to buy.
** Core Namespace
   :PROPERTIES:
   :CUSTOM_ID: core-namespace
   :END:

This namespace initializes the application on the client side. Here's
the entire
*[[https://github.com/matthiasn/BirdWatch/blob/d88d191ccad1c921a7fa318ef23e10508d725182/Clojure-Websockets/MainApp/src/cljs/birdwatch/core.cljs][code]]*,
with the explanation below.

#+BEGIN_SRC clojure
    (ns birdwatch.core
      (:require [birdwatch.util :as util]
                [birdwatch.charts.ts-chart :as ts-c]
                [birdwatch.communicator :as comm]
                [birdwatch.charts.wordcount-chart :as wc-c]
                [birdwatch.charts.cloud-chart :as cloud]
                [birdwatch.ui.tweets :as tw]
                [birdwatch.ui.elements :as ui]
                [birdwatch.state.data :as state]
                [birdwatch.stats.timeseries :as ts]
                [birdwatch.stats.wordcount :as wc]
                [cljs.core.async :as async :refer [chan pub]]))

    ;;;; Main file of the BirdWatch client-side application.

    ;;; Channels for handling information flow in the application.
    (def stats-chan (chan)) ; Stats from server, e.g. total tweets, connected users.
    (def data-chan  (chan)) ; Data from server, e.g. new tweets and previous chunks.
    (def qry-chan   (chan)) ; Queries that will be forwarded to the server.
    (def cmd-chan   (chan)) ; Web-client internal command messages (e.g. state modification).
    (def state-pub-chan (chan)) ; Publication of state changes.
    (def state-pub (pub state-pub-chan first)) ; Pub for subscribing to

    ;;; Initialize application state (atom in state namespace) and wire channels.
    (state/init-state data-chan qry-chan stats-chan cmd-chan state-pub-chan)

    ;;; Initialization of WebSocket communication.
    (comm/start-communicator cmd-chan data-chan stats-chan qry-chan)

    ;;; Initialize Reagent components and inject channels.
    (ui/init-views         state-pub cmd-chan)
    (tw/mount-tweets       state-pub cmd-chan)
    (wc-c/mount-wc-chart   state-pub cmd-chan {:bars 25 :every-ms 1000})
    (cloud/mount-wordcloud state-pub cmd-chan {:n 250 :every-ms 5000})
    (ts-c/mount-ts-chart   state-pub {:every-ms 1000})
#+END_SRC

The namespace starts with a couple of imports, mostly of other
namespaces from this application. Other than that, only =chan= and =pub=
from =core.async= are needed.

Next, we create the channels that provide the communication backbone of
this application. All communication between the major building blocks of
this application takes place by putting messages on conveyor belts, as
Rich Hickey likes to call channels. These channels provide for a great
abstraction. Just like conveyor belts, we can put data on them, without
having to worry where the conveyor belts will take them. In fact, even
if a component in the system wants to know where the channel leads to,
it has no way of finding it out.

In addition to a couple of regular channels, there also is a =pub=,
which is a =core.async= construct for implementing the
*[[http://en.wikipedia.org/wiki/Publish–subscribe_pattern][Publish-subscribe
pattern]]*:

#+BEGIN_SRC clojure
    (def state-pub-chan (chan)) ; Publication of state changes.
    (def state-pub (pub state-pub-chan first)) ; Pub for subscribing to
#+END_SRC

Here, the =state-pub= is a publisher that takes all items off the
=state-pub-chan= and that uses the function =first= to determine the
topic of a message. In order for that to work, it expects a data
structure where the topic is the first element in a sequence or a
vector. In this application, we will use vectors for that type of
messages. The =pub= will then apply the function =first= to each
element, so whatever is in the first position of that vector will be the
topic of the message. *Namespaced keywords* are particularly useful for
this purpose.

One might wonder if sending the entire dereferenced application state on
a channel wasn't too expensive. But it is not expensive at all since we
are dealing with an immutable data structure that exists already and
which can be passed around cheaply because it doesn't need to be copied.

Then, with the channels and the pub created, we instantiate different
components of the system and pass the channels to the components as
needed.

The *State* component, as you've seen in the previous architectural
drawing, requires the =data-chan= and the =stats-chan= for incoming data
from the server, the =qry-chan= for outgoing messages to the server, the
=state-pub-chan= for publishing updated application state and the
=cmd-chan= for receiving command messages from the UI. All these are
injected by calling the =state-init= function:

#+BEGIN_SRC clojure
    ;;; Initialize application state (atom in state namespace) and wire channels.
    (state/init-state data-chan qry-chan stats-chan cmd-chan state-pub-chan)
#+END_SRC

Next, we initialize the *Communicator* for the WebSockets interaction
with the server:

#+BEGIN_SRC clojure
    ;;; Initialization of WebSocket communication.
    (comm/start-communicator cmd-chan data-chan stats-chan qry-chan)
#+END_SRC

Here, the =cmd-chan= is required for triggering an initial search once
the WebSocket connection with the server is established. =data-chan= and
=stats-chan= are the channels onto which the component puts the
respective data items coming from the server. Finally, =qry-chan= is the
channel from which the component takes queries to forward them to the
server.

Note that the Communicator and State components know nothing of each
other. They only know the channels with which the communication is
facilitated. This is a great feature especially when applications grow
larger. We then want as little coupling as possible.

Finally, we have a couple of UI components and charts. They all follow
the same pattern:

#+BEGIN_SRC clojure
    ;;; Initialize Reagent components and inject channels.
    (ui/init-views         state-pub cmd-chan)
    (tw/mount-tweets       state-pub cmd-chan)
    (wc-c/mount-wc-chart   state-pub cmd-chan {:bars 25 :every-ms 1000})
    (cloud/mount-wordcloud state-pub cmd-chan {:n 250 :every-ms 5000})
    (ts-c/mount-ts-chart   state-pub {:every-ms 1000})
#+END_SRC

All of them render the application state, which they receive by
subscribing to the =state-pub=. Then, when they require the sending of
messages back to the application logic inside the State component, they
are also provided with the =cmd-chan=. The charts then also receive a
map with the options. Besides chart-specific options like the number of
words to render in the wordcloud or the number of bars to render in the
bar chart, they also contain the =:every-ms= key. This key specifies how
often the component will re-render, no matter how often the state
changes. We will see later how this is implemented when discussing the
charts. For now, all we need to know is that we have control over how
often potentially expensive operations are triggered.
** WebSocket Communication
   :PROPERTIES:
   :CUSTOM_ID: websocket-communication
   :END:

The =birdwatch.communicator= namespace handles the interaction with the
server-side application by using a WebSocket connection provided by the
*[[https://github.com/ptaoussanis/sente][sente]]* library.

Conceptually, the bi-directional WebSocket connection is somewhat
similar to two *core.async* channels, one for sending and one for
receiving. Since there are no different channels for different message
types, all messages on the WebSocket connection need to be marked with
their type. This is done by wrapping the payload in a vector where the
message type is represented by a
*[[https://clojuredocs.org/clojure.core/keyword][namespaced keyword]]*
in the first position and the payload in the second position.

With this convention it is really easy to pattern match using
*[[https://github.com/clojure/core.match][core.match]]* as we will see
below. It is just as easy to add new message types. In fact, this
convention of a vector with two items in it, where the first one is a
namespaced keyword that denotes the payload type and a second item with
the payload, is so useful because of pattern matching that we will be
using it in other parts of the application as well.

This component interacts with the rest of the application through four
channels, =cmd-chan=, =data-chan=, =stats-chan=, and =qry-chan=:

[[file:images/client-communicator.png]]

Here's the entire
*[[https://github.com/matthiasn/BirdWatch/blob/54a03b1a5d1324075ca4e75451a2bc752a2ab9e3/Clojure-Websockets/MainApp/src/cljs/birdwatch/communicator.cljs][namespace]]*:

#+BEGIN_SRC clojure
    (ns birdwatch.communicator
      (:require-macros [cljs.core.async.macros :refer [go-loop]])
      (:require [cljs.core.match :refer-macros [match]]
                [taoensso.sente  :as sente  :refer (cb-success?)]
                [taoensso.sente.packers.transit :as sente-transit]
                [cljs.core.async :as async :refer [<! chan put!]]))

    (def packer
      "Defines our packing (serialization) format for client<->server comms."
      (sente-transit/get-flexi-packer :json))

    (defn make-handler
      "Create handler function for messages from WebSocket connection, wire channels and the
       start-function to call when the socket is established."
      [cmd-chan data-chan stats-chan]
      (fn [{:keys [event]}]
        (match event
               [:chsk/state {:first-open? true}] (do
                                                   (print "WS connected")
                                                   (put! cmd-chan [:start-search]))
               [:chsk/recv  payload]
               (let [[msg-type msg] payload]
                 (case (keyword (namespace msg-type))
                   :tweet   (put! data-chan payload)
                   :stats   (put! stats-chan payload)
                   :default (print "unmatched message" payload)))
               :else (print "Unmatched event: %s" event))))

    (defn query-loop
      "Take command / query message off of channel, enrich payload with :uid of current
       WebSocket connection and send to server. Channel is injected when loop is started."
      [channel send-fn chsk-state]
      (go-loop []
               (let [[cmd-type payload] (<! channel)]
                 (send-fn [cmd-type (assoc payload :uid (:uid @chsk-state))])
                 (recur))))

    (defn start-communicator
      "Start communicator by wiring channels."
      [cmd-chan data-chan stats-chan qry-chan]
      (let [ws (sente/make-channel-socket! "/chsk" {:packer packer :type :auto})
            {:keys [ch-recv send-fn state]} ws
            handler (make-handler cmd-chan data-chan stats-chan)]
        (sente/start-chsk-router! ch-recv handler)
        (query-loop qry-chan send-fn state)))
#+END_SRC

Let's go through this def by def, function by function.

#+BEGIN_SRC clojure
    (def packer
      "Defines our packing (serialization) format for client<->server comms."
      (sente-transit/get-flexi-packer :json))
#+END_SRC

This defines the packer for sente, we're using
*[[http://blog.cognitect.com/blog/2014/7/22/transit][transit]]* here.

Next, we have the =make-handler= function, which, as the name suggests,
creates a handler function for handling incoming messages on the
WebSocket connection. The returned handler function then already knows
what channels to put messages onto, as these were specified in the
initial call to the =make-handler= function that constructed the handler
function.

#+BEGIN_SRC clojure
    (defn make-handler
      "Create handler function for messages from WebSocket connection, wire channels and the
       start-function to call when the socket is established."
      [cmd-chan data-chan stats-chan]
      (fn [{:keys [event]}]
        (match event
               [:chsk/state {:first-open? true}] (do
                                                   (print "WS connected")
                                                   (put! cmd-chan [:start-search]))
               [:chsk/recv  payload]
               (let [[msg-type msg] payload]
                 (case (keyword (namespace msg-type))
                   :tweet   (put! data-chan payload)
                   :stats   (put! stats-chan payload)
                   :default (print "unmatched message" payload)))
               :else (print "Unmatched event: %s" event))))
#+END_SRC

The event received by the handler function above is pattern matched
using =core.match=, where we always have a vector with two elements. The
first match is triggered when =event= contains =:chsk/state= with
=:first-open?= set to =true=, which happens when the connection to the
server has been established. In that case, ="WS connected"= is printed
on the browser console and a =[:start-search]= message is put onto the
=cmd-chan= in order to start a search.

Next, when a vector is received that contains =:chsk/recv= in the first
position, we further destructure the payload, which also contains a
two-item vector: =(let [[msg-type msg] payload]=. In the following line,
we use =case= to match on the namespace of the namespaced keyword in
=msg-type=. If the namespace of the message type is =:tweet=, the
message is put on the =data-chan=; if it is =:stats=, the message is put
onto =stats-chan= and otherwise the payload is printed with a warning
that the event could not be matched.

Next, we have the =query-loop= function. This function starts a
=go-loop= that takes messages from the specified channel and then uses
the specified send-fn to send an item to the server.

#+BEGIN_SRC clojure
    (defn query-loop
      "Take command / query message off of channel, enrich payload with :uid of current
       WebSocket connection and send to server. Channel is injected when loop is started."
      [channel send-fn chsk-state]
      (go-loop []
               (let [[cmd-type payload] (<! channel)]
                 (send-fn [cmd-type (assoc payload :uid (:uid @chsk-state))])
                 (recur))))
#+END_SRC

Not surprisingly, this function also expects items on the channel to be
two-item vectors, as we can see in the destructuring when taking an item
off the channel: =(let [[cmd-type payload] (<! channel)]=. The function
also takes =chsk-state=, which is the atom associated with the sente
connection to the server. Here, the =:uid= from the map held in
=chsk-state= is used so that the server has information about the client
ID and can thus return responses to the correct client.

Finally, we have the =start-communicator= function. This function fires
up the WebSocket connection, calls the =make-handler= function and
starts the =query-loop=.

#+BEGIN_SRC clojure
    (defn start-communicator
      "Start communicator by wiring channels."
      [cmd-chan data-chan stats-chan qry-chan]
      (let [ws (sente/make-channel-socket! "/chsk" {:packer packer :type :auto})
            {:keys [ch-recv send-fn state]} ws
            handler (make-handler cmd-chan data-chan stats-chan)]
        (sente/start-chsk-router! ch-recv handler)
        (query-loop qry-chan send-fn state)))
#+END_SRC

This function takes the four channels we saw in the architectural
drawing above and wires them accordingly. Before that can happen,
=sente/make-channel-socket!= is called with a route for the connection
and the packer. Obviously, the route needs to match the one used on the
server side. This function returns a map, from which we require three
keys: ={:keys [ch-recv send-fn state]}=.

Then, the =handler= is created. =data-chan= and =stats-chan= are used by
the =handler= for forwarding received messages. The =cmd-chan= allows
the =handler= to trigger a new search when the connection to the client
is up, as we saw when we discussed the =handler= above.

With the =handler= and =ch-recv= from the map that was returned by
=sente/make-channel-socket!=, we can now start the router by calling
=(sente/start-chsk-router! ch-recv handler)=.

Finally, =qry-chan= is used when calling the =query-loop= function.

This is all there is to the *Communicator* component. Most notably, any
*state is contained* inside an atom that lives *inside the let-binding*
of the =start-communicator= function and is not reachable from the
outside. This may not seem terribly important here but we will see that
this is valuable when we discuss the application state in the *State*
component. Also, this namespace does not depend on any other namespace
inside our application and interacts entirely through channels that are
passed in when the =start-communicator= function is called.
** Application State
   :PROPERTIES:
   :CUSTOM_ID: application-state
   :END:

[[file:images/client-state.png]]

*** The birdwatch.state.data namespace
    :PROPERTIES:
    :CUSTOM_ID: the-birdwatch.state.data-namespace
    :END:

The application state of the application is held inside the
/let-binding/ of the =init-state= function within the
=birdwatch.state.data=
*[[https://github.com/matthiasn/BirdWatch/blob/2cfa1c68d911418e57fad7a6fa363a868b24b65a/Clojure-Websockets/MainApp/src/cljs/birdwatch/state/data.cljs][namespace]]*:

#+BEGIN_SRC clojure
    (ns birdwatch.state.data
      (:require [birdwatch.state.initial :as i]
                [birdwatch.state.comm :as c]))

    (defn init-state
      "Init app state and wire all channels required in the state namespace. The app
       atom is held inside the let binding of this function and thus protected from
       outside access / alteration. The only way to interact with it is by sending
       messages on channels, such as the provided data channel for adding new data or
       sending commands on the cmd-chan."
      [data-chan qry-chan stats-chan cmd-chan state-pub-chan]
      (let [app (atom {})]
        (i/init app)
        (c/stats-loop stats-chan app)
        (c/data-loop data-chan qry-chan app)
        (c/cmd-loop cmd-chan qry-chan app)
        (c/broadcast-state state-pub-chan app)))
#+END_SRC

After creating an atom named =app= in the aforementioned let-binding,
this atom is initialized. Let's look at the initialization process
quickly before covering the rest of the function.

*** The birdwatch.state.initial namespace
    :PROPERTIES:
    :CUSTOM_ID: the-birdwatch.state.initial-namespace
    :END:

Before instantiating the "business logic", the state needs to be
initialized. This is done by calling the =init= function inside the
=birdwatch.state.initial=
*[[https://github.com/matthiasn/BirdWatch/blob/c10fd4ecf7e2d763a5f6476fb4be6605d51123e7/Clojure-Websockets/MainApp/src/cljs/birdwatch/state/initial.cljs][namespace]]*:

#+BEGIN_SRC clojure
    (ns birdwatch.state.initial
      (:require [birdwatch.util :as util]
                [tailrecursion.priority-map :refer [priority-map-by]]))

    (defn initial-state
      "Returns fresh application state."
      []
      {:count 0
       :n 10
       :prev-chunks-loaded 0
       :tweets-map {}
       :search-text ""
       :page 1
       :search "*"
       :users-count 0
       :total-tweet-count 0
       :sorted :by-id
       :live true
       :by-followers (priority-map-by >)
       :by-retweets (priority-map-by >)
       :by-favorites (priority-map-by >)
       :by-rt-since-startup (priority-map-by >)
       :by-reach (priority-map-by >)
       :by-id (priority-map-by >)
       :words-sorted-by-count (priority-map-by >)})

    (defn init
      "Initializes application start when application starts by providing fresh state
       and setting the :search-text from the URI location hash."
      [app]
      (reset! app (initial-state))
      (swap! app assoc :search-text (util/search-hash)))
#+END_SRC

This =init= function takes the =app= atom passed as its only parameter
and resets it with the result of a call to the =initial-state= function.
Next, it also swaps the =:search-text= key of the application state with
a call to =util/search-hash=. This function gets the URL hash, which is
also set whenever a new search is started. This allows bookmarking of
specific searches. The next time a bookmark is opened, the same search
as last time will load.

With the application state properly initialized in our little excursion
to the =birdwatch.state.initial= namespace, we can now fire up the
"business logic" of the application which is realized as a number of
functions in the =birdwatch.state.comm= namespace. These functions start
up behavior such as taking messages off channels and reacting according
to the received message and adding a listener to state changes that are
then put on a channel for broadcasting on a =pub=.

*** The birdwatch.state.comm namespace
    :PROPERTIES:
    :CUSTOM_ID: the-birdwatch.state.comm-namespace
    :END:

Let's have a look at the =birdwatch.state.comm=
*[[https://github.com/matthiasn/BirdWatch/blob/4b686d2d3c378082fb3c2e860e05125c15768791/Clojure-Websockets/MainApp/src/cljs/birdwatch/state/comm.cljs][namespace]]*
in detail in order to see what functions get initialized in the body of
the =init-state= function:

#+BEGIN_SRC clojure
    (ns birdwatch.state.comm
      (:require-macros [cljs.core.async.macros :refer [go-loop]])
      (:require [birdwatch.state.search :as s]
                [birdwatch.state.initial :as i]
                [birdwatch.state.proc :as p]
                [cljs.core.async :as async :refer [<! put! pipe timeout chan sliding-buffer]]
                [cljs.core.match :refer-macros [match]]))

    ;;;; Channels processing namespace. Here, messages are taken from channels and processed.

    (defn- stats-loop
      "Process messages from the stats channel and update application state accordingly."
      [stats-chan app]
      (go-loop []
               (let [msg (<! stats-chan)]
                 (match msg
                        [:stats/users-count       n] (swap! app assoc :users-count n)
                        [:stats/total-tweet-count n] (swap! app assoc :total-tweet-count n)
                        :else (prn "unknown msg in stats-loop" msg))
                 (recur))))

    (defn- prev-chunks-loop
      "Take messages (vectors of tweets) from prev-chunks-chan, add each tweet to application
       state, then pause to give the event loop back to the application (otherwise, UI becomes
       unresponsive for a short while)."
      [prev-chunks-chan app]
      (go-loop []
               (let [chunk (<! prev-chunks-chan)]
                 (doseq [t chunk] (p/add-tweet! t app))
                 (<! (timeout 50))
                 (recur))))

    (defn- data-loop
      "Process messages from the data channel and process / add to application state.
       In the case of :tweet/prev-chunk messages: put! on separate channel individual items
       are handled with a lower priority."
      [data-chan qry-chan app]
      (let [prev-chunks-chan (chan)]
        (prev-chunks-loop prev-chunks-chan app)
        (go-loop []
                 (let [msg (<! data-chan)]
                   (match msg
                          [:tweet/new             tweet] (p/add-tweet! tweet app)
                          [:tweet/missing-tweet   tweet] (p/add-to-tweets-map! app :tweets-map tweet)
                          [:tweet/prev-chunk prev-chunk] (do
                                                           (put! prev-chunks-chan prev-chunk)
                                                           (s/load-prev app qry-chan))
                          :else (prn "unknown msg in data-loop" msg))
                   (recur)))))

    (defn- cmd-loop
      "Process command messages, e.g. those that alter application state."
      [cmd-chan qry-chan app]
      (go-loop []
               (let [msg (<! cmd-chan)]
                 (match msg
                        [:toggle-live            ] (swap! app update :live not)
                        [:set-search-text    text] (swap! app assoc :search-text text)
                        [:set-current-page   page] (swap! app assoc :page page)
                        [:set-page-size         n] (swap! app assoc :n n)
                        [:start-search           ] (s/start-search app (i/initial-state) qry-chan)
                        [:set-sort-order by-order] (swap! app assoc :sorted by-order)
                        [:retrieve-missing id-str] (put! qry-chan [:cmd/missing {:id_str id-str}])
                        [:append-search-text text] (s/append-search-text text app)
                        :else (prn "unknown msg in cmd-loop" msg))
                 (recur))))

    (defn- broadcast-state
      "Broadcast state changes on the specified channel. Internally uses a sliding
       buffer of size one in order to not overwhelm the rest of the system with too
       frequent updates. The only one that matters next is the latest state anyway.
       It doesn't harm to drop older ones on the channel."
      [pub-chan app]
      (let [sliding-chan (chan (sliding-buffer 1))]
        (pipe sliding-chan pub-chan)
        (add-watch app :watcher
                   (fn [_ _ _ new-state]
                     (put! sliding-chan [:app-state new-state])))))
#+END_SRC

Let's go through this namespace function by function.

First, we have the =stats-loop=:

#+BEGIN_SRC clojure
    (defn- stats-loop
      "Process messages from the stats channel and update application state accordingly."
      [stats-chan app]
      (go-loop []
               (let [msg (<! stats-chan)]
                 (match msg
                        [:stats/users-count       n] (swap! app assoc :users-count n)
                        [:stats/total-tweet-count n] (swap! app assoc :total-tweet-count n)
                        :else (prn "unknown msg in stats-loop" msg))
                 (recur))))
#+END_SRC

This function starts up an infinitely running =go-loop= that takes
messages off the =stats-chan= and then matches the messages against the
two following patterns using
*[[https://github.com/clojure/core.match][core.match]]*. When the
message matches one of the two patterns, the application state is
updated to reflect the data coming from the server. If the message
doesn't match, a warning is printed to the browser console.

Next, let's have a look at the =data-loop= function:

#+BEGIN_SRC clojure
    (defn- data-loop
      "Process messages from the data channel and process / add to application state.
       In the case of :tweet/prev-chunk messages: put! on separate channel individual items
       are handled with a lower priority."
      [data-chan qry-chan app]
      (let [prev-chunks-chan (chan)]
        (prev-chunks-loop prev-chunks-chan app)
        (go-loop []
                 (let [msg (<! data-chan)]
                   (match msg
                          [:tweet/new             tweet] (p/add-tweet! tweet app)
                          [:tweet/missing-tweet   tweet] (p/add-to-tweets-map! app :tweets-map tweet)
                          [:tweet/prev-chunk prev-chunk] (do
                                                           (put! prev-chunks-chan prev-chunk)
                                                           (s/load-prev app qry-chan))
                          :else (prn "unknown msg in data-loop" msg))
                   (recur)))))
#+END_SRC

This function follows the same pattern as the =stats-loop= function,
only that there are more patterns to match on. Also, the messages do not
contain stats but tweet data. In the case that a new tweet is received,
which is detected by the =:tweet/new= keyword in the first position of
the message vector, the =add-tweet!= function from the
=birdwatch.state.proc= namespace is called with the payload. We will
look at the mechanisms in that namespace later. When a missing tweet is
encountered, the =add-to-tweets-map!= function from the same namespace
is called. Finally, when a =:tweet/prev-chunk= message is encountered,
two functions are called. First of all, the =prev-chunk= is put on a
channel for processing these chunks. We'll look at that next. Then, also
the =load-prev= function from the =birdwatch.state.search= namespace is
called. We'll have a look at that in detail later. As a short
description for now, a number of previous chunks are loaded, currently
with 500 tweets each, and in order not to flood the server with too many
queries at the same time, subsequent queries are only fired when another
chunk has been retrieved.

Next, let's have a look at the =prev-chunks-loop= function which
processes chunks of previous tweets as mentioned above:

#+BEGIN_SRC clojure
    (defn- prev-chunks-loop
      "Take messages (vectors of tweets) from prev-chunks-chan, add each tweet to application
       state, then pause to give the event loop back to the application (otherwise, UI becomes
       unresponsive for a short while)."
      [prev-chunks-chan app]
      (go-loop []
               (let [chunk (<! prev-chunks-chan)]
                 (doseq [t chunk] (p/add-tweet! t app))
                 (<! (timeout 50))
                 (recur))))
#+END_SRC

Here in this =go-loop=, chunks are taken off the =prev-chunks-chan= and
then every tweet in this chunk is added to the application state, in a
similar fashion to what we've seen previously for messages of type
=:tweet/new= by calling the =add-tweet!= function in the
=birdwatch.state.proc= namespace. Then, after each chunk,
=(<! (timeout 50))= is used. This is done to give control back to the
JavaScript event loop instead of blocking until the =prev-chunks-chan=
is empty. Without this, the UI would become unresponsive up until all
previous tweets are loaded.

Next, we have the =cmd-loop= function, its purpose is to take command
messages off the =cmd-chan= and process them as required:

#+BEGIN_SRC clojure
    (defn- cmd-loop
      "Process command messages, e.g. those that alter application state."
      [cmd-chan qry-chan app]
      (go-loop []
               (let [msg (<! cmd-chan)]
                 (match msg
                        [:toggle-live            ] (swap! app update :live not)
                        [:set-search-text    text] (swap! app assoc :search-text text)
                        [:set-current-page   page] (swap! app assoc :page page)
                        [:set-page-size         n] (swap! app assoc :n n)
                        [:start-search           ] (s/start-search app (i/initial-state) qry-chan)
                        [:set-sort-order by-order] (swap! app assoc :sorted by-order)
                        [:retrieve-missing id-str] (put! qry-chan [:cmd/missing {:id_str id-str}])
                        [:append-search-text text] (s/append-search-text text app)
                        :else (prn "unknown msg in cmd-loop" msg))
                 (recur))))
#+END_SRC

The mechanism at play in the =cmd-loop= function above should be
familiar to you by now. There's a =go-loop= inside a function that has
access to the application state and that either alters the application
state or calls a function like =start-search= or puts a message on a
channel such as =qry-chan= above. All control over how to alter the
application state from user input lies entirely with this =cmd-loop=
function. It would be very easy to add additional message patterns for
new functionality and then dispatch the message accordingly from this
single point on.

Finally in this namespace, we have the mechanism for broadcasting
application state changes inside the =broadcast-state= function. When
you look at the samples for
*[[http://reagent-project.github.io][Reagent]]*, you will notice that
the UI components interact directly with the application state. While
that may be fine for small samples, I don't like this approach for
larger applications. Whenever I work in the UI context, I want it to be
absolutely impossible to mess up application state by accidentally
replacing a key in the application state with an unexpected or invalid
value. We've already seen above that we can handle any kind of UI
interaction easily by putting messages that represent our intent on the
=cmd-chan=, which, as we'll see later, is available to all UI elements
in our application. So that solves the problem of where state is
altered.

But I want to take it a little bit further and not even hand the
application state to *Reagent* as an atom that can be modified.
Conventions not to use something in a bad way are nice and all, but when
you're working in a team on a larger application, the only way to keep
anyone from directly modifying application state from a UI component is
by completely hiding it.

So how could we achieve this? After scratching my head for a moment, I
came up with the following solution inside the =broadcast-state=
function:

#+BEGIN_SRC clojure
    (defn- broadcast-state
      "Broadcast state changes on the specified channel. Internally uses a sliding
       buffer of size one in order to not overwhelm the rest of the system with too
       frequent updates. The only one that matters next is the latest state anyway.
       It doesn't harm to drop older ones on the channel."
      [pub-chan app]
      (let [sliding-chan (chan (sliding-buffer 1))]
        (pipe sliding-chan pub-chan)
        (add-watch app :watcher
                   (fn [_ _ _ new-state]
                     (put! sliding-chan [:app-state new-state])))))
#+END_SRC

Here, we're adding a watcher to the application state atom using
=add-watch=. This calls an arity-4 function every time the application
state changes. We're only interested in the new application state after
the modification, which is the last argument to the function to call on
state changes, so we ignore their first three arguments. Then, we put
the =new-state= on a channel.

But wait! Isn't that terribly inefficient? It depends. First of all, the
application state inside the atom is an immutable data structure.
Because of this feature, it does not have to be copied but can be shared
freely, as it cannot be mutated. So that is nothing to worry about.

There is one potential point of contention though. Especially when
loading thousands of previous tweets, there are a lot of changes within
a short time. On my i7 Retina MacBook, roughly 1000 tweets are processed
per second. That amounts to tens of thousands of times that the function
above would be triggered per second. One could think about some kind of
rate limiting, but *core.async* has a better tool in its toolbox: the
*[[https://clojure.github.io/core.async/#clojure.core.async/sliding-buffer][sliding-buffer]]*.

The way a =sliding-buffer= works is as follows: when more messages are
put on a channel than can be taken off the channel on the other side, a
buffer is filled. When that buffer is full, the oldest element in the
buffer is dropped. This is perfect for our use case here. We can even
use a buffer as small as 1 element that will be buffered. When the
element can be consumed off the channel, fine. When there's a new
element coming it, it is the newer application state, and the latest
state is the only one we've ever been interested in for rendering, so
the slightly older application state can safely be dropped.

Accordingly, we're creating a channel named =sliding-channel= with such
a =sliding-buffer= of size 1. Then, the =sliding-chan= is =pipe=d into
the =pub-chan= which has been provided as an argument to the
=broadcast-state= function. This just means that every message from the
channel provided as the first argument to =pipe= is put onto the channel
that is provided as the second argument to =pipe=.

*** The birdwatch.state.search namespace
    :PROPERTIES:
    :CUSTOM_ID: the-birdwatch.state.search-namespace
    :END:

The =birdwatch.state.search=
*[[https://github.com/matthiasn/BirdWatch/blob/c14a72f196f729786b0049655d98a2218322d81e/Clojure-Websockets/MainApp/src/cljs/birdwatch/state/search.cljs][namespace]]*
is concerned with starting new real-time searches and loading previous
tweets matching the search criteria:

#+BEGIN_SRC clojure
    (ns birdwatch.state.search
      (:require [birdwatch.util :as util]
                [cljs.core.async :as async :refer [put!]]))

    (defn append-search-text
      "Appends string s to search-text in app, separated by space."
      [app s]
      (swap! app assoc :search-text (str (:search-text @app) " " s)))

    (defn- load-prev
      "Loads previous tweets matching the current search. Search is contructed
       by calling the util/query-string function with dereferenced app state."
      [app qry-chan]
      (let [chunks-to-load 10
            chunk-size 500
            prev-chunks-loaded (:prev-chunks-loaded @app)]
        (when (< prev-chunks-loaded chunks-to-load)
          (put! qry-chan [:cmd/query {:query (util/query-string @app)
                                      :n chunk-size
                                      :from (* chunk-size prev-chunks-loaded)}])
          (swap! app update-in [:prev-chunks-loaded] inc))))

    (defn- start-percolator
      "Triggers percolation matching of new tweets on the server side so that
       future matches will be delivered to the client."
      [app qry-chan]
      (put! qry-chan [:cmd/percolate {:query (util/query-string @app)}]))

    (defn start-search
      "Initiates a new search."
      [app initial-state qry-chan]
      (let [search (:search-text @app)
            s (if (= search "") "*" search)]
        (reset! app initial-state)
        (swap! app assoc :search-text search)
        (swap! app assoc :search s)
        (aset js/window "location" "hash" (js/encodeURIComponent s))
        (start-percolator app qry-chan)
        (dotimes [n 2] (load-prev app qry-chan))))
#+END_SRC

In the namespace above, we have four functions that are concerned with
different angles of getting results of a real-time search to the client.
First, there's the =append-search-text= function:

#+BEGIN_SRC clojure
    (defn append-search-text
      "Appends string s to search-text in app, separated by space."
      [app s]
      (swap! app assoc :search-text (str (:search-text @app) " " s)))
#+END_SRC

In this function, the =:search-text= key inside the application state
atom is appended with an additional word. This function is called when a
message comes in after clicking on a word in the word cloud or a line in
the bar chart and adds the respective word in the input field for the
next search.

Next, there's the '=load-prev= function:

#+BEGIN_SRC clojure
    (defn- load-prev
      "Loads previous tweets matching the current search. Search is contructed
       by calling the util/query-string function with dereferenced app state."
      [app qry-chan]
      (let [chunks-to-load 10
            chunk-size 500
            prev-chunks-loaded (:prev-chunks-loaded @app)]
        (when (< prev-chunks-loaded chunks-to-load)
          (put! qry-chan [:cmd/query {:query (util/query-string @app)
                                      :n chunk-size
                                      :from (* chunk-size prev-chunks-loaded)}])
          (swap! app update-in [:prev-chunks-loaded] inc))))
#+END_SRC

This function is concerned with loading previous tweets up to the
desired number, in chunks of a defined size. Specifically, as it
currently stands, =10= chunks of size =500= each will be loaded. First,
these two values are defined in the =let= binding, together with
=prev-chunks-loaded=, which is derived from the application state. Then,
if fewer chunks have previously been loaded than desired, a query is put
on the =qry-chan= for the next chunk to be retrieved. Then, finally, the
application state is modified to reflect that the loading of an
additional chunk is on its way.

Next, there's the =start-percolator= function. This function is
responsible for triggering a percolation query for the current search on
the server side:

#+BEGIN_SRC clojure
    (defn- start-percolator
      "Triggers percolation matching of new tweets on the server side so that
       future matches will be delivered to the client."
      [app qry-chan]
      (put! qry-chan [:cmd/percolate {:query (util/query-string @app)}]))
#+END_SRC

We've already covered the topic of percolation queries on the server
side, so there's no reason to go into detail here. What you need to know
is that a percolation query matches (and in our case delivers) all
future matches to the specified query.

Finally, we have the =start-search= function which, as the name
suggests, triggers all aspects of a search:

#+BEGIN_SRC clojure
    (defn start-search
      "Initiates a new search."
      [app initial-state qry-chan]
      (let [search (:search-text @app)
            s (if (= search "") "*" search)]
        (reset! app initial-state)
        (swap! app assoc :search-text search)
        (swap! app assoc :search s)
        (aset js/window "location" "hash" (js/encodeURIComponent s))
        (start-percolator app qry-chan)
        (dotimes [n 2] (load-prev app qry-chan))))
#+END_SRC

First of all, it determines the current =:search-text= and replaces it
with =*= if it's empty. Then, it resets the application state to an
empty slate. Next, within the shiny new application state, it resets the
values for the =:search-text= and the =:search= keys within the
application state atom. It then also sets the hash location within the
browser to reflect the new search so that this new search can be
bookmarked properly.

This is followed by calling the =start-percolator= function and finally
calling the =load-prev= function multiple times. Here, =n= determines
the parallelity factor. By sending two searches right away, the server
can process them in parallel. Then, once a result comes back,
=load-prev= is called again as we've seen when discussing the
=birdwatch.state.comm= namespace, triggering the dispatch of another
query iff there remain searches to be performed.

*** The birdwatch.state.proc namespace
    :PROPERTIES:
    :CUSTOM_ID: the-birdwatch.state.proc-namespace
    :END:

Finally, we have the =birdwatch.state.proc=
*[[https://github.com/matthiasn/BirdWatch/blob/4b686d2d3c378082fb3c2e860e05125c15768791/Clojure-Websockets/MainApp/src/cljs/birdwatch/state/proc.cljs][namespace]]*.
This namespace is concerned with processing incoming tweets and adding
them to the appropriate sort orders:

#+BEGIN_SRC clojure
  (ns birdwatch.state.proc
    (:require [birdwatch.stats.wordcount :as wc]))

  (defn swap-pmap
    "swaps item in priority-map"
    [app priority-map id n]
    (swap! app assoc priority-map (assoc (priority-map @app) id n)))

  (defn- add-to-tweets-map!
    "adds tweet to tweets-map"
    [app tweets-map tweet]
    (swap! app
           assoc-in [tweets-map (keyword (:id_str tweet))]
           tweet))

  (defn- swap-when-larger
    "Swaps item in priority-map when new value is larger than old value."
    [app priority-map rt-id n]
    (when (> n (rt-id (priority-map @app))) (swap-pmap app priority-map rt-id n)))

  (defn add-words
    "Add words to the words map and the sorted set with the counts (while discarding old entry)."
    [app words]
    (doseq [word words]
      (swap-pmap app :words-sorted-by-count word (inc (get (:words-sorted-by-count @app) word 0)))))

  (defn add-rt-status!
    "Process original, retweeted tweet."
    [app tweet]
    (if (contains? tweet :retweeted_status)
      (let [state @app
            rt (:retweeted_status tweet)
            rt-id (keyword (:id_str rt))
            rt-count (:retweet_count rt)]
        (swap-when-larger app :by-retweets rt-id rt-count)
        (swap-when-larger app :by-favorites rt-id (:favorite_count rt))
        (swap-pmap app :by-rt-since-startup rt-id (inc (get (:by-rt-since-startup state) rt-id 0)))
        (swap-pmap app :by-reach rt-id (+ (get (:by-reach state) rt-id 0) (:followers_count (:user tweet))))
        (when (> rt-count (:retweet_count (rt-id (:tweets-map state))))
          (add-to-tweets-map! app :tweets-map rt)))))

  (defn add-tweet!
    "Increment counter, add tweet to tweets map and to sorted sets by id and by followers. Modifies
     application state."
    [tweet app]
    (let [state @app
          id-str (:id_str tweet)
          id-key (keyword id-str)]
      (swap! app assoc :count (inc (:count state)))
      (add-to-tweets-map! app :tweets-map tweet)
      (swap-pmap app :by-followers id-key (:followers_count (:user tweet)))
      (swap-pmap app :by-id id-key id-str)
      (swap-pmap app :by-reach id-key (+ (get (:by-reach state) id-key 0) (:followers_count (:user tweet))))
      (add-rt-status! app tweet)
      (add-words app (wc/words-in-tweet (:text tweet)))))
#+END_SRC

The code above still needs some refactoring. I don't like the way it
looks. Let me get back to that before trying to walk you through.

*** State summary
    :PROPERTIES:
    :CUSTOM_ID: state-summary
    :END:

Now with the explanations in this chapter, I hope you will have a much
better understanding of what's going on in this drawing:

[[file:images/client-state.png]]

What I particularly like about this architecture is the complete
encapsulation of the State component from other parts of the
application. In fact, other parts of the application do not even know
that this mechanism exists at all. All they see are channels they
interact with. That makes it much easier to change parts of the
application without having it blow up in unexpected other parts.
** User Interface
   :PROPERTIES:
   :CUSTOM_ID: user-interface
   :END:

*** React.js, Immutable Data and Reagent
    :PROPERTIES:
    :CUSTOM_ID: react.js-immutable-data-and-reagent
    :END:

*[[http://facebook.github.io/react/][React]]* is a revolutionary way to
build user interfaces. Its model is particularly well suited for working
with immutable data structures because it is based on rendering out the
entire application state every single time something changes. Unlike
other frameworks, it does not require a mutation of your application
state itself. React will then render the state into a virtual DOM,
always keep the previous version of the virtual DOM and run an efficient
diffing algorithm between the two. It will only change the actual and
slow DOM where it has found changes between the previous and the current
virtual DOM during the diffing phase.

This may at first sound inefficient but it is actually very fast, making
it trivial to achieve 60 frames per second in the browser in most cases.
As far as I know, *[[https://twitter.com/swannodette][David Nolen]]* was
the first who realized how well this model is suited for working with
ClojureScript's immutable data structures. He then developed
*[[https://github.com/swannodette/om][Om]]*, which he first announced in
this
*[[http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/][blog
post]]*. Kudos to him for this discovery. At that time I was working on
an
*[[http://www.amazon.com/AngularJS-UI-Development-Amit-Ghart-ebook/dp/B00OXVAK7A/ref=sr_1_1?ie=UTF8&qid=1420394659&sr=8-1][AngularJS]]*
book and reading his blog post made me realize that AngularJS is not the
way to go, at least not for me. I had already been exposed to functional
programming principles enough to know the value of working with
immutable values. Luckily, the publisher found a co-author as I didn't
want to spend another couple of months with AngularJS.

I wrote the first version of the ClojureScript client using *Om*, but I
always had the problem that I needed a rather large amount of context
when coming back to the code for the user interface. I then discovered
*[[https://github.com/reagent-project/reagent][Reagent]]*, which also
uses *React.js* and is based on the same principles as Om.

I found the required code for a Reagent component to be much more
succinct and legible so that I made a complete switch. A good part of
the reason here is that I like its
*[[https://github.com/weavejester/hiccup][Hiccup]]* syntax.

Now when I come back to the UI code, I scratch my head a lot less than
with the previous version. I shared the experience I read in this
*[[http://diogo149.github.io/2014/10/19/om-no/][blog post]]*, which made
me give Reagent a shot. I haven't regretted it. Reagent exposes a lot
less incidental complexity than Om, and that just works better with my
tiny brain. For more information on Reagent I can also recommend this
*[[http://getprismatic.com/story/1405451329953][blog post]]*, besides
the decent enough documentation of the project itself.

I will not start with an introduction to Reagent here as the previously
mentioned resources should have you covered. Instead, I will just
explain the code, which you actually may find simple enough without
consulting many other resources. If some of it looks too simple to be
true, no worries, it really is not.
*** Interacting with Application State from the UI
    :PROPERTIES:
    :CUSTOM_ID: interacting-with-application-state-from-the-ui
    :END:

There is one major way in which I deviate from the Reagent samples and
documentation and that is passing application state to Reagent. As I
previously mentioned, I do not like to pass an atom around because it is
all too simple to destroy it. When working with UI code, I simply don't
want to be able to do that, nor do I want others working on the same
codebase to be able to accidentally mutilate the application state from
outside a tightly limited state owner.

Luckily, the solution to that is relatively simple. I have already
mentioned in the *State* chapter that there's a =broadcast-state=
function that puts dereferenced application state changes on a channel,
which are then broadcasted to interest parties using a *core.async pub*.

All that any of the UI components has to do now is subscribe to this
*pub* and =reset!= an atom local to the UI component with that new
state. Reagent's =atom= implementation, which needs to be used here,
allows Reagent to detect changes to this atom and re-render accordingly.
From Reagent's
*[[https://github.com/reagent-project/reagent/blob/master/src/reagent/core.cljs#L173][source]]*:
/"Like clojure.core/atom, except that it keeps track of derefs. Reagent
components that derefs one of these are automatically re-rendered."/.

Now using this atom locally is safe, whatever anyone decided to do with
it does not affect the state of the application. In order to change the
application, the UI component will have to send the state owner a
message on the =cmd-chan=.

Using this approach has an additional advantage. If the UI is a function
of the data that involves complex statistical reasoning, we do not
necessarily want to trigger a re-render every single time the
application state changes as this can easily become too expensive.
Instead, I would like to have a way to throttle how often an update
occurs. We've already seen part of the solution to that when we sent the
dereferenced application state on the =state-pub-chan=. There, we were
using a =sliding-buffer= and we can use the same mechanism here again,
with the addition of a =timeout= inside the =go-loop= receiving messages
from subscribing to state changes. Let's have a look at this mechanism
with a simple example:

#+BEGIN_SRC clojure
    (defn count-view [app] [:span (:count @app)])

    (defn init-count-view
      "Initialize count view view and wire state"
      [state-pub]
      (let [app (atom {})
            state-chan (chan (sliding-buffer 1))]
        (go-loop []
                 (let [[_ state-snapshot] (<! state-chan)]
                   (reset! app state-snapshot)
                   (<! (timeout 10))
                   (recur)))
        (sub state-pub :app-state state-chan)
        (r/render-component [count-view app] (util/by-id "tweet-count"))))
#+END_SRC

First in this example, there's a Reagent component called =count-view=.
It only renders a simple =:span= with the value of the =count= key
inside the application state. Next, there's the =init-count-view=
function which subscribes to the =state-pub=, creates a local atom,
starts a =go-loop= that updates the local atom when changes occur and
finally initializes the view with the local atom. Notice the usage of
the =sliding-buffer=. Once again, only the latest state change is kept.
In addition to that, a =timeout= of 10 milliseconds occurs inside the
=go-loop=, which effectively limits the number of updates to a maximum
of 100 per second. If more updates occur, the =go-loop= will be busy,
causing the =sliding-buffer= to accept the latest update and drop older
ones. Then, when the timeout is up, the =go-loop= will always have the
latest state message. In this simple case, the =timeout= may not be
necessary at all, but it becomes more useful when we only want to update
the UI every second or even less often when more expensive statistical
reasoning needs to be performed before actually rendering the UI.

Here's the part of the architecture drawing that hopefully helps by
illustrating the mechanism involved:

[[file:images/client-state-pub.png]]

For completeness, in order to render this component into the DOM, we
need some HTML, with an =id= where the element can be rendered:

{lang=html}

#+BEGIN_SRC html
    <div id="count">Tweets: <span id="tweet-count"></span></div>
#+END_SRC

The result of this can be seen on the right side of this screenshot:

[[file:images/header.png]]
*** Simple Reagent Components
    :PROPERTIES:
    :CUSTOM_ID: simple-reagent-components
    :END:

In the previous chapter, we've learned how to initialize UI elements
while also subscribing to the =state-pub=. This may seem a little
excessive for some very small UI components, so I've decided to put all
the small UI elements such as the =search-view=, the =pagination-view=,
the =sort-view=, the =count-view=, the =total-count-view=, and the
=users-count-view= together in a single namespace and let them share one
function called =init-views= for initializing and wiring them
altogether. Here's a screenshot with the elements circled in red that
are rendered by the =birdwatch.ui.elements= namespace:

[[file:images/client-elements.png]]

And here's how that looks like in
*[[https://github.com/matthiasn/BirdWatch/blob/277531c52e58b726f3cdb60898941d90b544b797/Clojure-Websockets/MainApp/src/cljs/birdwatch/ui/elements.cljs][code]]*:

#+BEGIN_SRC clojure
    (ns birdwatch.ui.elements
      (:require-macros [cljs.core.async.macros :refer [go-loop]])
      (:require [birdwatch.util :as util]
                [cljs.core.async :as async :refer [put! pipe chan sub timeout sliding-buffer]]
                [reagent.core :as r :refer [atom]]))

    (def cmd-chan (chan))
    (defn- put-cmd [msg] (put! cmd-chan msg))

    (defn- count-view [app] [:span (:count @app)])

    (defn- users-count-view [app]
      (let [users (:users-count @app)]
        [:span "Connected: " [:strong users] (if (= users 1) " user" " users")]))

    (defn- total-count-view [app]
      [:span "Indexed: " [:strong (:total-tweet-count @app)] " tweets"])

    (def sort-orders [[:by-id "latest"][:by-followers "followers"]
                      [:by-retweets "retweets"][:by-rt-since-startup "retweets2"]
                      [:by-reach "reach"][:by-favorites "favorites"]])

    (defn- btn-class? [p] (if p " pure-button-primary" " sort-button"))

    (defn- sort-view [app]
      (let [curr-order (:sorted @app)]
        [:div
         [:button.pure-button.not-rounded
          {:class (btn-class? (:live @app)) :on-click #(put-cmd [:toggle-live])} "Live"]
         [:button.pure-button.not-rounded.sort-button "Sort by:"]
         (for [[k text] sort-orders :let [btn-class (btn-class? (= k curr-order))]]
           ^{:key text} [:button.pure-button.not-rounded
                         {:class btn-class :on-click #(put-cmd [:set-sort-order k])} text])]))

    (defn- search-view [app]
      [:form.pure-form
       [:fieldset
        [:input {:type "text" :value (:search-text @app)
                 :on-key-press #(when (== (.-keyCode %) 13) (put-cmd [:start-search]))
                 :on-change #(put-cmd [:set-search-text (.. % -target -value)])
                 :placeholder "Example search: java (job OR jobs OR hiring)"}]
        [:button.pure-button.pure-button-primary {:on-click #(put-cmd [:start-search])}
         [:span {:class "glyphicon glyphicon-search"}]]]])

    (defn- pag-item [idx app]
      [:button.pure-button.not-rounded.button-xsmall
       {:class (when (= idx (:page @app)) " pure-button-primary")
        :on-click #(put-cmd [:set-current-page idx])} idx])

    (defn- pag-size-item [n app]
      [:button.pure-button.not-rounded.button-xsmall
       {:class (when (= n (:n @app)) " pure-button-primary")
        :on-click #(put-cmd [:set-page-size n])} n])

    (defn- pagination-view [app]
      [:div
       [:button.pure-button.not-rounded.button-xsmall [:strong "Page:"]]
       (for [idx (take 15 (range 1 (Math/floor (/ (:count @app) (:n @app)))))]
         ^{:key idx} [pag-item idx app])
       [:button.pure-button.not-rounded.button-xsmall [:strong "per Page:"]]
       (for [n [5 10 25 100]]
         ^{:key (str "pag-size" n)} [pag-size-item n app])])

    (def views [[count-view "tweet-count"][total-count-view "total-tweet-count"]
                [search-view "search"][users-count-view "users-count"]
                [sort-view "sort-buttons"][pagination-view "pagination"]])

    (defn init-views
      "Initialize all views contained in the vector above and connect channel for
       outgoing command messages (e.g. for altering state)"
      [state-pub cmd-out-chan]
      (let [app (atom {})
            state-chan (chan (sliding-buffer 1))]
        (pipe cmd-chan cmd-out-chan)
        (go-loop []
                 (let [[_ state-snapshot] (<! state-chan)]
                   (reset! app state-snapshot)
                   (<! (timeout 10))
                   (recur)))
        (sub state-pub :app-state state-chan)
        (doseq [[component id] views] (r/render-component [component app] (util/by-id id)))))
#+END_SRC

Okay, let's start in the beginning, shall we? First of all, there are
the imports. When looking at those, you will notice that this namespace
only depends on a single other namespace from this application,
=birdwatch.util=. This utility namespace only contains a couple of
utility functions, all of which are pure, so that's fine in terms of
encapsulation. Then, we create a local =cmd-chan=:

#+BEGIN_SRC clojure
    (def cmd-chan (chan))
    (defn- put-cmd [msg] (put! cmd-chan msg))

    (defn- count-view [app] [:span (:count @app)])
#+END_SRC

We could just as well pass the =cmd-chan= from the arguments to the
=init-views= function around, but I found this approach a little simpler
here where not all components need the =cmd-chan=. Next, there's the
=put-cmd= utility function which simply shortens the amount of effort
required to put something on the local channel. We will later have to
=pipe= this local channel into the application-wide command channel, but
we'll get to that. Next, there's the =count-view= function. We've
already seen this one in the simple example in the last chapter.

Next, there is the =users-count-view= component which is only slightly
more involved:

#+BEGIN_SRC clojure
    (defn users-count-view [app]
      (let [users (:users-count @app)]
        [:span "Connected: " [:strong users] (if (= users 1) " user" " users")]))
#+END_SRC

Here, we have some conditional logic so that if only one user is
connected, we use "user" as a singular:

[[file:images/user-count.png]]

Otherwise, we use the plural "users":

[[file:images/user-count2.png]]

After seeing the two components above, the =total-count-view= component
should not contain any surprises:

#+BEGIN_SRC clojure
    (defn total-count-view [app]
      [:span "Indexed: " [:strong (:total-tweet-count @app)] " tweets"])
#+END_SRC

This renders the number of tweets indexed in total. As mentioned in the
server-side chapter, the =Persistence= component sends a message with an
updated total every so many seconds, which is then distributed to all
connected clients.

The =sort-view= component is a little more involved. We need a couple of
buttons for different sort orders, each of which needs a keyword that
will be set as the application's current sort order and a label string.
In order not to repeat ourselves, we use a vector named =sort-orders=
for all the buttons, each of which we can represent as a two-item
vector, with the key in the first position and the label string in the
second position:

#+BEGIN_SRC clojure
    (def sort-orders [[:by-id "latest"][:by-followers "followers"]
                      [:by-retweets "retweets"][:by-rt-since-startup "retweets2"]
                      [:by-reach "reach"][:by-favorites "favorites"]])

    (defn- btn-class? [p] (if p " pure-button-primary" " sort-button"))

    (defn- sort-view [app]
      (let [curr-order (:sorted @app)]
        [:div
         [:button.pure-button.not-rounded
          {:class (btn-class? (:live @app)) :on-click #(put-cmd [:toggle-live])} "Live"]
         [:button.pure-button.not-rounded.sort-button "Sort by:"]
         (for [[k text] sort-orders :let [btn-class (btn-class? (= k curr-order))]]
           ^{:key text} [:button.pure-button.not-rounded
                         {:class btn-class :on-click #(put-cmd [:set-sort-order k])} text])]))
#+END_SRC

Then, in the =sort-view= component itself, we dereference the local
state and use =(:sorted @app)= as =curr-order= in the =let=-binding.
With that, we can start constructing the markup generated by this
component, starting with a =:div=. This =:div= then contains a couple of
buttons, starting with the *Live* button.

Clicking this "Live" button toggles if the tweets view gets updated or
not. Oftentimes, updates happen too frequently to read anything else,
particularly when sorting tweets by time, when every new tweet will push
the previous ones down in the list. When the key inside the application
state is set to false, the tweets component will simply not update,
which is trivial to realize through the mechanism of sending state
updates on a =pub=. We will see that later when talking about the tweets
component. Here, all we need to concern ourselves with is to send a
message to the state component when the button is pressed.

Next, there's a static button with the label ="Sort By"=. Note that with
Hiccup, we can simply assign classes to the button, like so:

#+BEGIN_SRC clojure
    [:button.pure-button.not-rounded.sort-button "Sort by"]
#+END_SRC

This assigns the classes =pure-button=, =not-rounded= and =sort-button=
to the button, resulting in this styling:

#+CAPTION: Sort-view Component
[[file:images/sort-by.png]]

Next, we want to create additional buttons for every element in the
=sort-orders= vector.

#+BEGIN_SRC clojure
    (for [[k text] sort-orders :let [btn-class (btn-class? (= k curr-order))]]
      ^{:key text} [:button.pure-button.not-rounded
                    {:class btn-class :on-click #(put-cmd [:set-sort-order k])} text])
#+END_SRC

Above, =for= every item in =sort-orders= we destructure the vector as
=k= (a keyword representing the sort order) and =text= and then
determine if =k= equals =curr-order= by calling the helper function
=btn-class?=:

#+BEGIN_SRC clojure
    (defn- btn-class? [p] (if p " pure-button-primary" " sort-button"))
#+END_SRC

This will set the =btn-class= in the =:let= binding to
=" pure-button-primary"= if the predicate is fulfilled (k equals
curr-order), otherwise it will set it to =" sort-button"=. This controls
the color through the associated CSS. If the sort order that the button
represents is active, we want the color to be light blue and otherwise
light gray. With that, we can now create the individual button:

#+BEGIN_SRC clojure
    ^{:key text} [:button.pure-button.not-rounded
                  {:class btn-class :on-click #(put-cmd [:set-sort-order k])} text])
#+END_SRC

All buttons share the =.pure-button.not-rounded= classes. In addition we
set the class in the properties map of the button component:
=:class btn-class=. In that map we also define an =:on-click= function:
=#(put-cmd [:set-sort-order k])} text])=. This sends a command message
of type ´´´´:set-sort-order´´´´ to the State component with key
associated with the clicked button.

Finally, we pass the =text= label to the button. Note that we will also
set metadata on the component where we use the =text= of the component
as the key: =^{:key text}=. This is good practice for ReactJS whenever
we render a list of something. Here, it wouldn't hurt much to omit it as
the list is neither dynamic nor large, but it would still result in a
warning on the console.

Next, there's the =search-view= component:

#+BEGIN_SRC clojure
    (defn- search-view [app]
      [:form.pure-form
       [:fieldset
        [:input {:type "text" :value (:search-text @app)
                 :on-key-press #(when (== (.-keyCode %) 13) (put-cmd [:start-search]))
                 :on-change #(put-cmd [:set-search-text (.. % -target -value)])
                 :placeholder "Example search: java (job OR jobs OR hiring)"}]
        [:button.pure-button.pure-button-primary {:on-click #(put-cmd [:start-search])}
         [:span {:class "glyphicon glyphicon-search"}]]]])
#+END_SRC

Here, a =:form= of class =pure-form= is rendered with a =:fieldset=
inside. This then contains an =:input= field and a =:button=. The
=:value= of the =:input= field is always determined by the value of the
=:search-text= key of the application state map. Then, when the user
changes the content of the input field, the =:on-change= function is
called, which sends a command message of type =:set-search-text= to the
State component: =#(put-cmd [:set-search-text (.. % -target -value)])=
with the value of the input field.

Then, either on =ENTER= inside the field or a press of the button,
=#(put-cmd [:start-search])= is run, which sends a command message of
type =:start-search= to the State component, with no further parameters.
Not surprisingly, you can see the search view on the left here:

[[file:images/header.png]]

The last component in this namespace is =pagination-view=:

#+BEGIN_SRC clojure
    (defn- pag-item [idx app]
      [:button.pure-button.not-rounded.button-xsmall
       {:class (when (= idx (:page @app)) " pure-button-primary")
        :on-click #(put-cmd [:set-current-page idx])} idx])

    (defn- pag-size-item [n app]
      [:button.pure-button.not-rounded.button-xsmall
       {:class (when (= n (:n @app)) " pure-button-primary")
        :on-click #(put-cmd [:set-page-size n])} n])

    (defn- pagination-view [app]
      [:div
       [:button.pure-button.not-rounded.button-xsmall [:strong "Page:"]]
       (for [idx (take 15 (range 1 (Math/floor (/ (:count @app) (:n @app)))))]
         ^{:key idx} [pag-item idx app])
       [:button.pure-button.not-rounded.button-xsmall [:strong "per Page:"]]
       (for [n [5 10 25 100]]
         ^{:key (str "pag-size" n)} [pag-size-item n app])])
#+END_SRC

Before we dive into the code, here's how the =pagination-view= looks
like when rendered:

[[file:images/pagination.png]]

Here, we first have a =pag-item= component for each page, which is used
for switching the view to the particular page when clicked. In that
case, a message of type =:set-current-page= with the index =idx= of the
clicked button is put onto the =cmd-chan=: =[:set-current-page idx])=.

Next, we have the same kind of button used for different page sizes for
the tweet view as you saw on the right in the screenshot of the
=pagination-view= above. Only that this time, the message sets the page
size: =[:set-page-size n]=.

Within the =pagination-view=, we then include one =pag-item= for each of
the pages within the tweets loaded. This should be updated to use actual
numbers from the application. But then, we would also need buttons for
/first/ and /last/ if we don't want to render 500 pagination items or
so. Pull request, anyone? Right now, we will simply use 15 or, if the
actual number of pages is lower, that number.

Once again, a =:key= is assigned to each =pag-item=. As mentioned, this
is good practice when working with React. Don't adhere and at least
you're reminded by a warning on the console.

Below, we repeat the process for the =pag-size=, which we also use as a
string for the prefix to the React key. Here, we simply use 4 different
page size options: =[5 10 25 100]=.

Finally in this namespace, we have some code for initializing the
Reagent components on application startup:

#+BEGIN_SRC clojure
    (def views [[count-view "tweet-count"][total-count-view "total-tweet-count"]
                [search-view "search"][users-count-view "users-count"]
                [sort-view "sort-buttons"][pagination-view "pagination"]])

    (defn init-views
      "Initialize all views contained in the vector above and connect channel for
       outgoing command messages (e.g. for altering state)"
      [state-pub cmd-out-chan]
      (let [app (atom {})
            state-chan (chan (sliding-buffer 1))]
        (pipe cmd-chan cmd-out-chan)
        (go-loop []
                 (let [[_ state-snapshot] (<! state-chan)]
                   (reset! app state-snapshot)
                   (<! (timeout 10))
                   (recur)))
        (sub state-pub :app-state state-chan)
        (doseq [[component id] views] (r/render-component [component app] (util/by-id id)))))
#+END_SRC

First, we have the vector =views= which contains one vector per
component, with the function defining it in the first position and the
ID of the DOM element to render it into in the second position.

Next, we have the =init-views= function. You will recognize the
mechanism for subscribing to state changes we discussed in the last
chapter. In addition, we pipe the local =cmd-chan= into the
=cmd-cmd-chan= that the function receives as an argument:
=(pipe cmd-chan cmd-out-chan)=.

Once the connection to the rest of the application is established, each
component inside the =views= vector is rendered / mounted into the DOM
inside the =doseq=, where we destructure the individual vectors as
=[component id]= and use them for calls to =r/render-component=. This
=init-views= function is then called from the =core= namespace when the
application starts as we've already seen in a previous chapter.
*** Reagent Components for Tweets
    :PROPERTIES:
    :CUSTOM_ID: reagent-components-for-tweets
    :END:

Next, let's have a look at the =birdwatch.ui.tweets=
*[[https://github.com/matthiasn/BirdWatch/blob/c14a72f196f729786b0049655d98a2218322d81e/Clojure-Websockets/MainApp/src/cljs/birdwatch/ui/tweets.cljs][namespace]]*:

#+BEGIN_SRC clojure
    (ns birdwatch.ui.tweets
      (:require-macros [cljs.core.async.macros :refer [go-loop]])
      (:require [birdwatch.ui.util :as util]
                [cljs.core.async :as async :refer [put! chan sub <! timeout sliding-buffer]]
                [reagent.core :as r :refer [atom]]))

    (defn twitter-intent
      "Renders a twitter intent as a clickable image, for example for retweeting directly
       from inside the application."
      [tweet intent icon]
      [:a {:href (str "https://twitter.com/intent/" intent (:id_str tweet))}
       [:img {:src (str "/images/" icon)}]])

    (defn twitter-intents
      "Renders the three relevant twitter intents using the component above."
      [tweet]
      [:div.intent
       [twitter-intent tweet "tweet?in_reply_to=" "reply.png"]
       [twitter-intent tweet "retweet?tweet_id=" "retweet.png"]
       [twitter-intent tweet "favorite?tweet_id=" "favorite.png"]])

    (defn missing-tweet
      "Renders the view for a missing tweet, which in ideal cases should only
       be shown for fractions of a second until the tweet that should have
       been displayed instead is loaded over the WebSockets connection."
      [tweet cmd-chan]
      (let [id-str (:id_str tweet)]
        (put! cmd-chan [:retrieve-missing id-str])
        [:div.tweet "loading... " (:id_str tweet)]))

    (defn tweet-text
      "Renders the text of a tweet including followers count plus retweet,
       favorites and retweeted-within-loaded-tweets count."
      [tweet user state]
      [:div.tweettext
       [:div {:dangerouslySetInnerHTML #js {:__html (:html-text tweet)}}]
       [:div.pull-left.timeInterval (str (util/number-format (:followers_count user)) " followers")]
       [:div.pull-right.timeInterval (str (util/rt-count tweet state) (util/fav-count tweet state))
        [:br] (util/rt-count-since-startup tweet state)]])

    (defn image-view
      "Renders the first image inside the media vector as its only argument.
       The assumption is that the interesting image is always contained at
       that position, which appears to be the case."
      [media]
      [:div.tweet-image
       [:a {:href (:url (get media 0)) :target "_blank"}
        [:img.pure-img-responsive {:src (str (:media_url (get media 0)) ":small")}]]])

    (defn tweet-view
      "Renders a tweet with all the elements it contains. Takes the raw (unformatted)
       tweet and the dereferenced application state as arguments."
      [raw-tweet state]
      (let [tweet ((memoize util/format-tweet) raw-tweet)
            user (:user tweet)
            screen-name (:screen_name user)
            href (str "http://www.twitter.com/" screen-name)]
        [:div.tweet
         [:span [:a {:href href :target "_blank"} [:img.thumbnail{:src (:profile_image_url user)}]]]
         [:a {:href href :target "_blank"} [:span.username {:src (:profile_image_url user)} (:name user)]]
         [:span.username_screen (str " @" screen-name)]
         [:div.pull-right.timeInterval (util/from-now (:created_at tweet))]
         [tweet-text tweet user state]
         (when-let [media (:media (:entities tweet))] (pos? (count media)) [image-view media])
         [twitter-intents tweet]]))

    (defn tweets-view
      "Renders a list of tweets. Takes two atoms app and tweets plus the cmd-chan
       as arguments. Dereferences both and passes down dereferenced data structures
       so that so that the tweet-view component and all components down the hierarchy
       can be implemented as pure functions.
       Rerenders the entire list whenever one (or both) of the atoms change."
      [app tweets cmd-chan]
      (let [state @app]
        [:div (for [t @tweets] (if (:user t)
                                 ^{:key (:id_str t)} [tweet-view t state]
                                 ^{:key (:id_str t)} [missing-tweet t cmd-chan]))]))

    (defn mount-tweets
      "Mounts tweet component and sets up the mechanism for subscribing to application
       state changes that are broadcast on state-pub passed in as an argument.
       Also takes the cmd-chan in order to wire component up with the backchannel
       to the application state publisher. Not currently used, only for same signature
       as birdwatch.ui.elements/init-views."
      [state-pub cmd-chan]
      (let [app (atom {})
            tweets (atom [])
            state-chan (chan (sliding-buffer 1))]
        (go-loop []
                 (let [[_ state-snapshot] (<! state-chan)
                       order (:sorted state-snapshot)
                       n (:n state-snapshot)
                       page (dec (:page state-snapshot))]
                   (when (:live state-snapshot)
                     (reset! app state-snapshot)
                     (reset! tweets (util/tweets-by-order order state-snapshot n page)))
                   (<! (timeout 20)))
                 (recur))
        (sub state-pub :app-state state-chan)
        (r/render-component [tweets-view app tweets cmd-chan] (util/by-id "tweet-frame"))))
#+END_SRC

The first component here is =twitter-intent=:

#+BEGIN_SRC clojure
    (defn twitter-intent
      "Renders a twitter intent as a clickable image, for example for retweeting directly
       from inside the application."
      [tweet intent icon]
      [:a {:href (str "https://twitter.com/intent/" intent (:id_str tweet))}
       [:img {:src (str "/images/" icon)}]])
#+END_SRC

This renders a link to Twitter for the specified intent (e.g. retweet)
with the correct icon and for the specified tweet. When clicking on this
link, you can, for example, retweet a tweet. Here's how =twitter-intent=
is used:

#+BEGIN_SRC clojure
    (defn twitter-intents
      "Renders the three relevant twitter intents using the component above."
      [tweet]
      [:div.intent
       [twitter-intent tweet "tweet?in_reply_to=" "reply.png"]
       [twitter-intent tweet "retweet?tweet_id=" "retweet.png"]
       [twitter-intent tweet "favorite?tweet_id=" "favorite.png"]])
#+END_SRC

In the =twitter-intents= component, we create a =div= with three
=twitter-intent= components, one for each possible intent. Here's how
that looks like when rendered:

[[file:images/intents.png]]

#+BEGIN_SRC clojure
    (defn missing-tweet
      "Renders the view for a missing tweet, which in ideal cases should only
       be shown for fractions of a second until the tweet that should have
       been displayed instead is loaded over the WebSockets connection."
      [tweet cmd-chan]
      (let [id-str (:id_str tweet)]
        (put! cmd-chan [:retrieve-missing id-str])
        [:div.tweet "loading... " (:id_str tweet)]))
#+END_SRC

The =missing-tweet= component is rendered for a short while if a tweet
is not found locally. Not only does it show a text that the tweet is
loading, it also =put!=s a message on the channel requesting the tweet
from the server. Then, once the server delivers the tweet back, the
actual tweet instead of this placeholder is rendered immediately. This
component is not really used at the moment but it should become useful
soon.

The =tweet-text= component is responsible for rendering the tweet text
plus the followers, the retweet and favorite count as well as the count
of how often the tweet has been retweeted within the tweets currently
loaded in the application.

#+BEGIN_SRC clojure
    (defn tweet-text
      "Renders the text of a tweet including followers count plus retweet,
       favorites and retweeted-within-loaded-tweets count."
      [tweet user state]
      [:div.tweettext
       [:div {:dangerouslySetInnerHTML #js {:__html (:html-text tweet)}}]
       [:div.pull-left.timeInterval (str (util/number-format (:followers_count user)) " followers")]
       [:div.pull-right.timeInterval (str (util/rt-count tweet state) (util/fav-count tweet state))
        [:br] (util/rt-count-since-startup tweet state)]])
#+END_SRC

The =tweet-text= component also takes the =state= argument, which is the
locally cached application state that is reset every so often with
updates it gets by subscribing to the =state-pub=.

There's one surprise here. Inside the first child =div=,
=:dangerouslySetInnerHTML= is used, which is React's way of rendering
already formatted HTML inside a component. The tweet text, which
contains links, has already been formatted as HTML in a previous
processing step, and here we simply use that HTML string.

Here's the CSS used in the component above:

{lang="CSS"}

#+BEGIN_SRC css
    .tweettext {
        padding-left: 10px;
        padding-bottom: 10px;
        font-size: 10px;
        overflow: auto;
        min-height: 50px;
    }
    .timeInterval {
        padding-top: 2px;
        font-size: 10px;
        color:#999;
        text-align: right;
    }
#+END_SRC

The =.timeInterval= naming is probably not ideal, but I'm just re-using
it from the time interval in the =tweet-view= component we will look at
below.

Next, we have the =image-view= component:

#+BEGIN_SRC clojure
    (defn image-view
      "Renders the first image inside the media vector as its only argument.
       The assumption is that the interesting image is always contained at
       that position, which appears to be the case."
      [media]
      [:div.tweet-image
       [:a {:href (:url (get media 0)) :target "_blank"}
        [:img.pure-img-responsive {:src (str (:media_url (get media 0)) ":small")}]]])
#+END_SRC

This is really straightforward, it just creates a =div= of class
=tweet-image= that contains a link that opens in a new tab. This link
also contains an image with the source URL set to load the image from
Twitter. Here's the CSS for the =tweet-image= class:

{lang="CSS"}

#+BEGIN_SRC css
    .tweet-image {
        max-width: 100%;
    }
#+END_SRC

With these components in place we can now look at the representation of
a tweet, which looks like this:

[[file:images/tweet.png]]

Here's the same in code:

#+BEGIN_SRC clojure
    (defn tweet-view
      "Renders a tweet with all the elements it contains. Takes the raw (unformatted)
       tweet and the dereferenced application state as arguments."
      [raw-tweet state]
      (let [tweet ((memoize util/format-tweet) raw-tweet)
            user (:user tweet)
            screen-name (:screen_name user)
            href (str "http://www.twitter.com/" screen-name)]
        [:div.tweet
         [:span [:a {:href href :target "_blank"} [:img.thumbnail{:src (:profile_image_url user)}]]]
         [:a {:href href :target "_blank"} [:span.username {:src (:profile_image_url user)} (:name user)]]
         [:span.username_screen (str " @" screen-name)]
         [:div.pull-right.timeInterval (util/from-now (:created_at tweet))]
         [tweet-text tweet user state]
         (when-let [media (:media (:entities tweet))] (pos? (count media)) [image-view media])
         [twitter-intents tweet]]))
#+END_SRC

This component takes =raw-tweet= and also the entire local
```state=and renders the tweet by calling=util/format-tweet=with it. Note how the result is=memoize=d. This caches previous calls to the same, referentially transparent function. I'm not sure if **[memoize](https://clojuredocs.org/clojure.core/memoize)** really improves performance in this context, but since it's so simple to do, why not. A couple of other values are taken from the tweet map and with that, a=:div=is rendered with the components you would expect when you look at the image above. No big surprises there, except maybe for only rendering the image view when there is media to render. Otherwise, the=when-let=would simply evaluate to=nil````
and thus be ignored.

With the =tweet-view= component in place, we can now render a list of
them in the =tweets-view= component:

#+BEGIN_SRC clojure
    (defn tweets-view
      "Renders a list of tweets. Takes two atoms app and tweets plus the cmd-chan
       as arguments. Dereferences both and passes down dereferenced data structures
       so that so that the tweet-view component and all components down the hierarchy
       can be implemented as pure functions.
       Rerenders the entire list whenever one (or both) of the atoms change."
      [app tweets cmd-chan]
      (let [state @app]
        [:div (for [t @tweets] (if (:user t)
                                 ^{:key (:id_str t)} [tweet-view t state]
                                 ^{:key (:id_str t)} [missing-tweet t cmd-chan]))]))
#+END_SRC

In this component, we dereference the application state as =app=, derive
the tweets to be rendered as =tweets= and then render a tweet for each
entry. If the tweet is not available locally, we render a
=missing-tweet= component, otherwise we render a =tweet-view= component.
In each case, we set a =:key= as metadata on the component. This allows
the underlying React to be more efficient by being able to reuse
components instead of having to throw away the DOM node and render a new
one. You can probably already guess how the list rendering looks like.
If not, you can find it again in the screenshots of the next chapter.

Finally, the tweets view needs to be rendered and mounted, which happens
inside the =mount-tweets= function:

#+BEGIN_SRC clojure
    (defn mount-tweets
      "Mounts tweet component and sets up the mechanism for subscribing to application
       state changes that are broadcast on state-pub passed in as an argument.
       Also takes the cmd-chan in order to wire component up with the backchannel
       to the application state publisher. Not currently used, only for same signature
       as birdwatch.ui.elements/init-views."
      [state-pub cmd-chan]
      (let [app (atom {})
            tweets (atom [])
            state-chan (chan (sliding-buffer 1))]
        (go-loop []
                 (let [[_ state-snapshot] (<! state-chan)
                       order (:sorted state-snapshot)
                       n (:n state-snapshot)
                       page (dec (:page state-snapshot))]
                   (when (:live state-snapshot)
                     (reset! app state-snapshot)
                     (reset! tweets (util/tweets-by-order order state-snapshot n page)))
                   (<! (timeout 20)))
                 (recur))
        (sub state-pub :app-state state-chan)
        (r/render-component [tweets-view app tweets cmd-chan] (util/by-id "tweet-frame"))))
#+END_SRC

The mechanism above is comparable to the approach in the
=birdwatch.ui.elements= namespace. The function takes the =state-pub=
and the =cmd-chan= as arguments. It then sets up a subscriber to the
application state change publisher =state-pub=. Inside a =let= binding,
we find the two atoms =app= and =tweets=. The =app= is used the way
we've already seen. In addition, the =tweets= atom is used for a list of
the tweets to render inside the =tweets-view=. Then further along, when
the view is set to /live/, the =app= atom is reset with the
=state-snapshot= and the =tweets= atom is reset with the value returned
when calling the =util/tweets-by-order= function with a couple of values
derived from the =state-snapshot=.
*** The birdwatch.ui.util namespace
    :PROPERTIES:
    :CUSTOM_ID: the-birdwatch.ui.util-namespace
    :END:

In the code for the Reagent components, we have used a couple of helpers
from the =birdwatch.ui.util=
*[[https://github.com/matthiasn/BirdWatch/blob/aae1a7313211f26946ae55278fb8d3c484060c70/Clojure-Websockets/MainApp/src/cljs/birdwatch/ui/util.cljs][namespace]]*,
all of which are pure functions:

#+BEGIN_SRC clojure
    (ns birdwatch.ui.util
      (:require [clojure.string :as s]))

    (defn by-id
      "Helper function, gets DOM element by ID."
      [id]
      (.getElementById js/document id))

    (defn number-format
      "Formats a number for display, e.g. 1.7K, 122K or 1.5M followers."
      [number]
      (cond
       (< number 1000) (str number)
       (< number 100000) (str (/ (.round js/Math (/ number 100)) 10) "K")
       (< number 1000000) (str (.round js/Math (/ number 1000)) "K")
       :default (str (/ (.round js/Math (/ number 100000)) 10) "M")))

    (defn from-now
      "Formats a date using the external moment.js library."
      [date]
      (let [time-string (. (js/moment. date) (fromNow true))]
        (if (= time-string "a few seconds") "just now" time-string)))

    (def twitter-url "https://twitter.com/")

    (defn a-blank
      "Creates HTML string for a link that opens in a new tab in the browser."
      [url text]
      (str "<a href='" url "' target='_blank'>" text "</a>"))

    (defn- url-replacer
      "Replace URL occurences in tweet texts with HTML (including links)."
      [acc entity]
      (s/replace acc (:url entity) (a-blank (:url entity) (:display_url entity))))

    (defn- hashtags-replacer
      "Replaces hashtags in tweet text with HTML (including links)."
      [acc entity]
      (let [hashtag (:text entity)
            f-hashtag (str "#" hashtag)]
        (s/replace acc f-hashtag (a-blank (str twitter-url "search?q=%23" hashtag) f-hashtag))))

    (defn- mentions-replacer
      "Replaces user mentions in tweet text with HTML (including links)."
      [acc entity]
      (let [screen-name (:screen_name entity)
            f-screen-name (str "@" screen-name)]
        (s/replace acc f-screen-name (a-blank (str twitter-url screen-name) f-screen-name))))

    (defn- reducer
      "Generic reducer, allows calling specified function for each item in provided collection."
      [text coll fun]
      (reduce fun text coll))

    (defn format-tweet
      "Formats tweet text for display by running multiple reducers."
      [tweet]
      (let [{:keys [urls media user_mentions hashtags]} (:entities tweet)]
        (assoc tweet :html-text
          (-> (:text tweet)
              (reducer , urls url-replacer)
              (reducer , media url-replacer)
              (reducer , user_mentions mentions-replacer)
              (reducer , hashtags hashtags-replacer)
              (s/replace , "RT " "<strong>RT </strong>")))))

    (defn entity-count
      "Gets count of specified entity from either tweet, or, when exists, original (retweeted) tweet."
      [tweet state k s]
      (let [rt-id (if (contains? tweet :retweeted_status)
                    (:id_str (:retweeted_status tweet))
                    (:id_str tweet))
            count (k ((keyword rt-id) (:tweets-map state)))]
        (if count (str (number-format count) s) "")))

    (defn rt-count
      "Gets the formatted string for the :retweet_count if exists, otherwise yields empty string."
      [tweet state]
      (entity-count tweet state :retweet_count " RT | "))

    (defn fav-count
      "Gets the formatted string for the :favorite_count if exists, otherwise yields empty string."
      [tweet state]
      (entity-count tweet state :favorite_count " fav"))

    (defn rt-count-since-startup
      "Gets RT count since startup for tweet, if exists returns formatted string."
      [tweet state]
      (let [t (if (contains? tweet :retweeted_status)
                (:retweeted_status tweet)
                tweet)
            cnt ((keyword (:id_str t)) (:by-rt-since-startup state))
            reach ((keyword (:id_str t)) (:by-reach state))]
        (when (> cnt 0)
          (str "analyzed: " (number-format cnt) " retweets, reach " (number-format reach)))))

    (defn tweets-by-order
      "Finds top n tweets by specified order."
      [order state n skip]
      (map (fn [[k v]] (get (:tweets-map state) k {:id_str (name k)}))
           (->> (order state)
                (drop (* n skip) ,)
                (take n ,))))
#+END_SRC

I don't know, but for my taste this namespace is almost too long in
terms of the number of lines. What do you think? Anyway, let's go
through the code function by function. First, we have the =by-id=
function:

#+BEGIN_SRC clojure
    (defn by-id
      "Helper function, gets DOM element by ID."
      [id]
      (.getElementById js/document id))
#+END_SRC

This function is very straightforward despite the interaction with the
JavaScript host platform. All it does is getting a DOM element by ID.
Next, we have the =number-format= function:

#+BEGIN_SRC clojure
    (defn number-format
      "Formats a number for display, e.g. 1.7K, 122K or 1.5M followers."
      [number]
      (cond
       (< number 1000) (str number)
       (< number 100000) (str (/ (.round js/Math (/ number 100)) 10) "K")
       (< number 1000000) (str (.round js/Math (/ number 1000)) "K")
       :default (str (/ (.round js/Math (/ number 100000)) 10) "M")))
#+END_SRC

You know what this does if you've ever used Twitter. It reduces large
numbers to fewer significant figures. Take Justin Bieber, for example.
There's simply not enough space to display his number of followers,
which was *59,776,559* at the time of writing. It is so much easier to
squeeze in *59.8M* instead.

#+BEGIN_SRC clojure
    (defn from-now
      "Formats a date using the external moment.js library."
      [date]
      (let [time-string (. (js/moment. date) (fromNow true))]
        (if (= time-string "a few seconds") "just now" time-string)))
#+END_SRC

The result of the =from-now= function should be equally familiar. It
shows "just now" when a timestamp was, well, just now. Or "30 min" or
"12 hours" or whatever. You get the idea. If you want to know more about
the behavior, the *[[http://momentjs.com][moment.js]]* documentation has
you covered. This function is just a thin wrapper over it.

#+BEGIN_SRC clojure
    (def twitter-url "https://twitter.com/")

    (defn a-blank
      "Creates HTML string for a link that opens in a new tab in the browser."
      [url text]
      (str "<a href='" url "' target='_blank'>" text "</a>"))
#+END_SRC

The =a-blank= returns an HTML string for a link that opens in a new tab.
The tweet text is constructed as an HTML string as a whole and passed
into the =tweet-text= component's div. Remember from the last chapter?
Here's a reminder, it involved dangerously setting something:

#+BEGIN_SRC clojure
    [:div {:dangerouslySetInnerHTML #js {:__html (:html-text tweet)}}]
#+END_SRC

It may be possible to implement this in pure Reagent without this
"dangerous" behavior. That's fine by me as injections of malicious code
don't seem to be an issue in this application. And it would be more
elegant. Anyone interested in solving this? Maybe that could be a task
to solve during a meetup or so. If you're interested, knock yourself
out.

The =a-blank= function we've seen a moment ago is then used by the
=url-replacer=, =hashtags-replacer=, and =mentions-replacer= functions:

#+BEGIN_SRC clojure
    (defn- url-replacer
      "Replaces URL occurrences in tweet texts with HTML (including links)."
      [acc entity]
      (s/replace acc (:url entity) (a-blank (:url entity) (:display_url entity))))
#+END_SRC

#+BEGIN_SRC clojure
    (defn- hashtags-replacer
      "Replaces hashtags in tweet text with HTML (including links)."
      [acc entity]
      (let [hashtag (:text entity)
            f-hashtag (str "#" hashtag)]
        (s/replace acc f-hashtag (a-blank (str twitter-url "search?q=%23" hashtag) f-hashtag))))
#+END_SRC

#+BEGIN_SRC clojure
    (defn- mentions-replacer
      "Replaces user mentions in tweet text with HTML (including links)."
      [acc entity]
      (let [screen-name (:screen_name entity)
            f-screen-name (str "@" screen-name)]
        (s/replace acc f-screen-name (a-blank (str twitter-url screen-name) f-screen-name))))
#+END_SRC

The three /replacer/ functions we have just looked at obviously need to
be called from somewhere. I wanted to use the
*[[http://clojuredocs.org/clojure.core/-%3E][thread-first macro]]* and
pass the result from one =reduce= into the next =reduce= until all
replacements had been performed. However, the signature of =reduce= did
not match. Not to worry, I can just write a function for that:

#+BEGIN_SRC clojure
    (defn- reducer
      "Generic reducer, allows calling specified function for each item in collection provided."
      [text coll fun]
      (reduce fun text coll))
#+END_SRC

In the =reducer= function above, reduce is called internally while
providing the signature I need, so to work with either the
=thread-first= or the =thread-last= macro. This =reducer= can now be
called from inside the function that formats the entire tweet text HTML
string:

#+BEGIN_SRC clojure
    (defn format-tweet
      "Formats tweet text for display by running multiple reducers."
      [tweet]
      (let [{:keys [urls media user_mentions hashtags]} (:entities tweet)]
        (assoc tweet :html-text
          (-> (:text tweet)
              (reducer , urls url-replacer)
              (reducer , media url-replacer)
              (reducer , user_mentions mentions-replacer)
              (reducer , hashtags hashtags-replacer)
              (s/replace , "RT " "<strong>RT </strong>")))))
#+END_SRC

So much for the tweet text. But we have more to discuss. We need to get
the counts of multiple entities, such as the /followers/, /retweet/,
/favorites/, or the /retweets within the loaded tweets/:

#+BEGIN_SRC clojure
    (defn entity-count
      "Gets count of specified entity from either tweet or, if exists, original (retweeted) tweet."
      [tweet state k s]
      (let [rt-id (if (contains? tweet :retweeted_status)
                    (:id_str (:retweeted_status tweet))
                    (:id_str tweet))
            count (k ((keyword rt-id) (:tweets-map state)))]
        (if count (str (number-format count) s) "")))
#+END_SRC

This =entity-count= function takes a =tweet=, the =state= snapshot, a
keyword =k= and a string =s=. It then checks if the =tweet= is a retweet
(contains a =:retweeted-status= ). If so, it uses the ID of the retweet,
otherwise it takes the ID of =tweet= as =rt-id=. Then, =count= is
determined by looking up the =rt-id= within the =state= snapshot, using
=k= as the lookup function. Finally, if =count= exists, it concatenates
the result from calling the =number-format= function with =count= and
the string =s=. This =entity-count= function can now be used more
specifically:

#+BEGIN_SRC clojure
    (defn rt-count
      "Gets the formatted string for the :retweet_count if exists, otherwise yields empty string."
      [tweet state]
      (entity-count tweet state :retweet_count " RT | "))

    (defn fav-count
      "Gets the formatted string for the :favorite_count if exists, otherwise yields empty string."
      [tweet state]
      (entity-count tweet state :favorite_count " fav"))
#+END_SRC

Both =rt-count= and =fav-count= simply call =entity-count= with the
respective keywords and strings. The =rt-count-since-startup= is a
little more involved:

#+BEGIN_SRC clojure
    (defn rt-count-since-startup
      "Gets RT count since startup for tweet, if exists returns formatted string."
      [tweet state]
      (let [t (if (contains? tweet :retweeted_status)
                (:retweeted_status tweet)
                tweet)
            cnt ((keyword (:id_str t)) (:by-rt-since-startup state))
            reach ((keyword (:id_str t)) (:by-reach state))]
        (when (> cnt 0)
          (str "analyzed: " (number-format cnt) " retweets, reach " (number-format reach)))))
#+END_SRC

Once again, we look if the tweet is a retweet. If so, further reasoning
is done on the retweet; if not, the tweet itself is used. Then, we can
look up the number of retweets within the loaded tweets and the reach
within the same dataset by looking up the count within the respective
sort orders, which we have derived and updated when ingesting tweets.

Finally, there is a function that returns a list of tweets for display
in the UI, paginated, with the correct number of items and in the right
sort order:

#+BEGIN_SRC clojure
    (defn tweets-by-order
      "Finds top n tweets by specified order."
      [order state n skip]
      (map (fn [[k v]] (get (:tweets-map state) k {:id_str (name k)}))
           (->> (order state)
                (drop (* n skip) ,)
                (take n ,))))
#+END_SRC

The =tweets-by-order= function takes the desired =order=, the =state=
snapshot, the page size =n= and the number of items to =skip= (for
pagination). It then uses =map= to apply an anonymous function to every
item in a collection that is derived by taking the specified sort order
from the =state= snapshot, dropping =(* n skip)= items and taking =n=
items. Inside the anonymous function, each item is converted to a tweet
by looking it up in the =:tweets-map= key inside the =state= snapshot.
If the tweet is not found, the map ={:id_str (name k)}= is used instead.
This default value is used for the =missing-tweet= component we met when
we discussed the =tweets-view= component. The =:id-str= of the missing
tweet then allows the =missing-tweet= component to emit a request for
retrieval.

That's it for displaying the tweets. I like that the part of the
application handling the application state does not need to know
anything about how it's rendered or used. This, however, requires
knowledge of the data structure inside the UI layer. I think that's okay
though. For the UI layer, the application state change is an observable
fact that it can then transform into a visual representation. It's a
function that takes the state snapshot and derives the DOM, with no
write access to the application state. I like that more than having the
State component know about data structures required by the UI. However,
I'm curious about your thoughts on this.

By the way, for every thought that you have and you'd like to get
clarification on or discuss, please send me an email:
[[mailto:matthias.nehlsen@gmail.com][matthias.nehlsen@gmail.com]]
*** Pure.css
    :PROPERTIES:
    :CUSTOM_ID: pure.css
    :END:

Earlier versions of this application used
*[[http://getbootstrap.com][Bootstrap]]* as the CSS framework, including
earlier versions of the Clojure / ClojureScript implementation. But
after about a year, I really couldn't stand the Bootstrap look any
longer. Sure, I could have changed stuff to make it look less like
Bootstrap, but then why use Bootstrap in the first place. Here's how
that old version looked like:

#+CAPTION: Screenshot with Bootstrap CSS
[[file:images/screenshot_bootstrap.png]]

Bootstrap has served me alright over the last two years or so, but it
was time for something simpler and cleaner.

So, I looked for newer CSS frameworks and found
*[[http://purecss.io][Pure]]*. Pure is much more lightweight than
Bootstrap, requires a much smaller download and its grid model is also
easier to use than Bootstrap. Here's how the new version looks like:

#+CAPTION: Screenshot with Pure CSS
[[file:images/screenshot.png]]

I think this looks fresher than the old version. At the same time it
also works much better on small mobile screens without much
customization. In the iOS Simulator for the iPhone 6 Plus, for example,
it looks like this:

#+CAPTION: Screenshot iOS Simulator with Pure CSS
[[file:images/screenshot_6plus.png]]

Now it not only looks better, the HTML needed to generate this is also a
lot simpler. Let's have a quick look at the HTML:

{lang="HTML"}

#+BEGIN_SRC html
    <body>
        <div class="header">
            <div class="home-menu pure-menu pure-menu-open pure-menu-horizontal pure-menu-fixed">
                <a class="pure-menu-heading" href="">Birdwatch</a>
                <ul>
                    <li><a href="https://github.com/matthiasn/Birdwatch" target="_blank">GitHub</a></li>
                    <li><a href="https://leanpub.com/building-a-system-in-clojure" target="_blank">About</a></li>
                </ul>
            </div>
        </div>

        <div class="content-wrapper">
            <div class="l-box">
                <div id="count">Tweets: <span id="tweet-count"></span></div>
                <div id="search"></div>
                <div id="pagination"></div>
                <div id="sort-buttons"></div>
            </div>
            <div class="pure-g">
                <div class="pure-u-1 pure-u-sm-1-2 pure-u-lg-5-12 l-box">
                    <div id="tweet-frame"></div>
                </div>
                <div class="pure-u-1 pure-u-sm-1-2 pure-u-lg-7-12 l-box">
                    <div id="timeseries1" class="timeseries"></div>
                    <hr />
                    <div id="wordCloud" class="cloud" ></div>
                    <hr />
                    <h5>word frequency</h5>
                    <div id="wordcount-barchart" class="barchart" ></div>
                    <hr />
                    <div id="users-count"></div>
                    <div id="total-tweet-count"></div>
                </div>
            </div>
        </div>
        <!-- Scripts omitted -->
    </body>
#+END_SRC

I like **[[http://purecss.io][Pure]]* for the simplicity of its grid
model. Although this is not a book about HTML and CSS, let's still walk
through the HTML as it comes in handy when you want to design a web
application.

In the /header/ =div=, we create another =div=. We assign it a couple of
classes for styling and place a few elements inside, like an unordered
list for links we want to have in the menu bar.

Next comes the actual content of the page, which we find inside a =div=
assigned the /content-wrappper/-class. In there, we first have a =div=
with class /l-box/, which gives us a little bit of padding:

{lang="CSS"}

#+BEGIN_SRC css
    .l-box {
      padding: 1em 1em 0 1em;
    }
#+END_SRC

Inside, we place =div=s with the IDs /tweet-count/, /search/,
/pagination/ and /sort-buttons/. These are the IDs we render the
respective components into using Reagent, remember?

Next, we have a =div= with class /pure-g/. This contains two =div=s. One
of them contains the list of tweets whereas the other one contains all
the charts. Pure now gives us a straightforward way of defining a
responsive grid, where the width of each is a fraction of the whole
depending on the size of the screen.

On very small screens, both of them will have =pure-u-1= applied, where
both have the full width of the screen and are thus stacked on top of
each other.

On slightly larger screens (e.g. an iPhone 6 in landscape orientation),
they will each occupy half of the width by having /pure-u-sm-1-2/
applied.

On even larger screens, such as desktops or tablets, the tweets will
claim 5/12 of the space /pure-u-lg-5-12/ and the charts will claim 7/12
of the space /pure-u-lg-7-12/. That's all there really is to know about
the containers provided by Pure. Inside, we can render whatever, for
example Reagent components or an SVG generated by D3.js as we will see
later when we look at the word cloud.
** Charts
   :PROPERTIES:
   :CUSTOM_ID: charts
   :END:

In this chapter, we will have a look at the charts displayed on the
right side in the UI, namely the *time series chart*, the *word count
chart*, and the *word cloud*. Before we do that, we will have a look at
the namespaces that are responsible for the *count statistics* and *data
aggregation*. The charts receive their data just like the UI elements,
i.e. by subscribing to the application state snapshots, only that the
data is reasoned about less frequently as it wouldn't make sense to run
the computations 50 times a second. Once per second or once every few
seconds is enough.

In fact, two of the three charts are implemented using
*[[https://github.com/reagent-project/reagent][Reagent]]* as well, with
the difference that we are not constructing HTML but *SVG*, which is
then mounted in the DOM. Only the word cloud uses
*[[http://d3js.org][D3.js]]*. The word count bar chart does some local
*linear regression* as well, but let's start from the top in the UI,
with the time series chart.
*** Timeseries Data
    :PROPERTIES:
    :CUSTOM_ID: timeseries-data
    :END:

The =birdwatch.timeseries=
*[[https://github.com/matthiasn/BirdWatch/blob/a9ef80998222e2f01853687da010f3be7af0c82c/Clojure-Websockets/MainApp/src/cljs/birdwatch/stats/timeseries.cljs][namespace]]*
is responsible for aggregating tweet counts per time interval in order
to see how a search has developed over time.

#+BEGIN_SRC clojure
    (ns birdwatch.stats.timeseries
      (:require [birdwatch.util :as util]))

    (defn date-round
      "Returns function that rounds the provided seconds since epoch down to the
       nearest time interval; for example (date-round 60) creates a function that
       takes seconds t and rounds them to the nearest minute."
      [interval]
      (fn [t] (* interval (Math/floor (/ t interval)))))

    (def m 60)
    (def qhr (* 15 m))
    (def hr (* 60 m))
    (def qday (* 6 hr))
    (def day (* 24 hr))

    (defn grouping-interval
      "Determines duration of individual intervals (bars) depending on duration of
       timespan between newest and oldest."
      [newest oldest]
      (cond
       (> (- newest oldest) (* 20 day)) day  ;round by nearest day
       (> (- newest oldest) (* 5 day))  qday ;round by nearest quarter day
       (> (- newest oldest) (* 20 hr))  hr   ;round by nearest hour
       (> (- newest oldest) (* 4 hr))   qhr  ;round by nearest quarter hour
       :else                            m))  ;round by nearest minute

    (defn empty-ts-map
      "Generates map with all rounded intervals between oldest and newest,
       initialized to a count of 0."
      [newest oldest interval]
      (let [rounder (date-round interval)
            values (range (rounder oldest) (rounder newest) interval)]
        (apply sorted-map-by < (flatten [(interpose 0 values) 0]))))

    (defn count-into-map
      "Increments count for time interval."
      [ts-map k]
      (update-in ts-map [k] inc))

    (defn tweet-ts
      "Retrieves seconds since epoch from tweet using moment.js."
      [t]
      (.unix (js/moment. (:created_at t))))

    (defn ts-data
      "Performs timeseries analysis by counting tweets in even intervals."
      [state]
      (let [tweets-by-id ((util/tweets-by-order :tweets-map :by-id) state 100000)]
        (let [oldest (tweet-ts (last tweets-by-id))
              newest (tweet-ts (first tweets-by-id))
              interval (grouping-interval newest oldest)
              rounder (date-round interval)]
          (reduce count-into-map
                  (empty-ts-map newest oldest interval)
                  (map #(rounder (tweet-ts %)) tweets-by-id)))))
#+END_SRC

The data generated here is used in the =birdwatch.charts.ts-chart=
timeseries chart.

#+CAPTION: Timeseries Chart
[[file:images/ts_chart.png]]

In order to do that, tweets will have to be grouped into time intervals
and then counted to see how many have occurred during each time
interval.

First in the namespace, we have the =date-round= function, which is a
helper for rounding dates to the nearest interval. Next, we define the
possible time intervals /1m/, /15m/, /1h/, /6h/, /24h/:

#+BEGIN_SRC clojure
    (defn date-round
      "Returns function that rounds the provided seconds since epoch down to the
       nearest time interval; for example (date-round 60) creates a function that
       takes seconds t and rounds them to the nearest minute."
      [interval]
      (fn [t] (* interval (Math/floor (/ t interval)))))

    (def m 60)
    (def qhr (* 15 m))
    (def hr (* 60 m))
    (def qday (* 6 hr))
    (def day (* 24 hr))
#+END_SRC

Pretty straightforward, nothing more than a higher-order function that
returns another function with the =interval= argument baked into the
returned function. This returned function then multiplies =interval=
with the =Math/floor= of dividing the argument =t= of the returned
function by the =interval= provided when creating the function.

Then, we have the =grouping-interval= function:

#+BEGIN_SRC clojure
    (defn grouping-interval
      "Determines duration of individual intervals (bars) depending on duration of
       timespan between newest and oldest."
      [newest oldest]
      (cond
       (> (- newest oldest) (* 20 day)) day  ;round by nearest day
       (> (- newest oldest) (* 5 day))  qday ;round by nearest quarter day
       (> (- newest oldest) (* 20 hr))  hr   ;round by nearest hour
       (> (- newest oldest) (* 4 hr))   qhr  ;round by nearest quarter hour
       :else                            m))  ;round by nearest minute
#+END_SRC

Here, we figure out how long the duration of one bar will be, depending
on the total time span covered by the tweets loaded. Next, there's the
=empty-ts-map= function:

#+BEGIN_SRC clojure
    (defn empty-ts-map
      "Generates map with all rounded intervals between oldest and newest,
       initialized to a count of 0."
      [newest oldest interval]
      (let [rounder (date-round interval)
            values (range (rounder oldest) (rounder newest) interval)]
        (apply sorted-map-by < (flatten [(interpose 0 values) 0]))))
#+END_SRC

The function above provides us with a map to count tweets into. Here's
an example of how that looks like as a =pprint= output, (shortened to
not take up a whole page):

#+BEGIN_SRC clojure
    {1420505580 0,
     1420505340 0,
     1420505100 0,
     1420506000 0,
     1420505400 0,
     1420505880 0,
     1420505520 0,
     1420506120 0,
     1420505460 0,
     1420506180 0,
     1420505760 0,
     1420504980 0}
#+END_SRC

Before we can do the actual timeseries mapping, we will need two helper
functions:

#+BEGIN_SRC clojure
    (defn count-into-map
      "Increments count for time interval."
      [ts-map k]
      (update-in ts-map [k] inc))

    (defn tweet-ts
      "Retrieves seconds since epoch from tweet using moment.js."
      [t]
      (.unix (js/moment. (:created_at t))))
#+END_SRC

The =count-into-map= function simply takes a map =ts-map= and increments
the counter at the key =k=. The =tweet-ts= function is nothing more than
a lightweight wrapper around *[[http://momentjs.com][moment.js]]* for
retrieving the milliseconds since
*[[http://en.wikipedia.org/wiki/Unix_time][epoch]]*.

With these in place we can now look at the =ts-data= function, which is
the main workhorse in this namespace:

#+BEGIN_SRC clojure
    (defn ts-data
      "Performs timeseries analysis by counting tweets in even intervals."
      [state]
      (let [tweets-by-id ((util/tweets-by-order :tweets-map :by-id) state 100000)]
        (let [oldest (tweet-ts (last tweets-by-id))
              newest (tweet-ts (first tweets-by-id))
              interval (grouping-interval newest oldest)
              rounder (date-round interval)]
          (reduce count-into-map
                  (empty-ts-map newest oldest interval)
                  (map #(rounder (tweet-ts %)) tweets-by-id)))))
#+END_SRC

This function takes the =state= snapshot, gets =tweets-by-id= which, as
the name implies, gets the tweets sorted by ID, which is equivalent to
them being sorted by time. From these, we determine the =oldest= and
=newest= tweets, from which we determine the appropriate interval and
construct the =rounder= function. With these, we can run =reduce= with
=count-into-map= as the reducing function, the
=(empty-ts-map newest oldest interval)= as the accumulator and
=(map #(rounder (tweet-ts %)) tweets-by-id)= as the data structure to
run over, which rounds each tweet in there to the correct interval so
that it can be counted.

Here's a truncated output of this function as an example, after running
the =reduce= over actual tweets:

#+BEGIN_SRC clojure
    {1420501500 66,
     1420501620 68,
     1420501680 72,
     1420501980 59,
     1420502820 58,
     1420502940 63,
     1420503360 93,
     1420505100 64,
     1420505340 73,
     1420505580 43,
     1420506000 38,
     1420506300 23}
#+END_SRC

Let's take it one step further and use this truncated sample data as the
actual output of the =ts-data= instead of the =reduce= over data to see
how this translates into a bar chart:

#+CAPTION: Timeseries Chart with Example Data
[[file:images/ts-example.png]]

Okay, with this, we are well equipped to explore the code for the
timeseries chart.
*** Timeseries Chart
    :PROPERTIES:
    :CUSTOM_ID: timeseries-chart
    :END:

We've already looked at the timeseries chart in the last chapter to get
an idea what the data represents. Let's have a look at the
*[[https://github.com/matthiasn/BirdWatch/blob/83ff6bfc4b930e877f8f8414b53fc381bf5b4366/Clojure-Websockets/MainApp/src/cljs/birdwatch/charts/ts_chart.cljs][code]]*:

#+BEGIN_SRC clojure
    (ns birdwatch.charts.ts-chart
      (:require-macros [cljs.core.async.macros :refer [go-loop]])
      (:require [birdwatch.util :as util]
                [birdwatch.stats.timeseries :as ts]
                [reagent.core :as r :refer [atom]]
                [cljs.core.async :as async :refer [chan sub timeout sliding-buffer]]))

    (def ts-elem (util/by-id "timeseries1"))
    (def ts-w (aget ts-elem "offsetWidth"))
    (def ts-h 100)

    (defn bar
      "Renders a vertical bar. Enables showing a label when the mouse is
       positioned above the bar."
      [x y h w idx label]
      [:rect {:x x :y (- y h) :fill "steelblue" :width w :height h
              :on-mouse-enter #(reset! label {:idx idx})
              :on-mouse-leave #(reset! label {})}])

    (defn barchart
      "Renders a bar chart, making use of the bar function above. Returns
       entire SVG element."
      [indexed mx cnt w label]
      (let [gap (/ (/ ts-w 20) cnt)]
        [:svg {:width ts-w :height ts-h}
         [:g
          (for [[idx [k v]] indexed]
            ^{:key k} [bar (* idx w) ts-h (* (/ v mx) ts-h) (- w gap) idx label])]]))

    (defn labels
      "Renders a label for a bar chart. Makes use of Rickshaws CSS."
      [bars mx cnt w label]
      (when-not (empty? @label)
        (let [idx (:idx @label)
              [k v] (get bars idx)
              top (- ts-h (* (/ v mx) ts-h))
              lr (if (< (/ idx cnt) 0.6) "left" "right")]
          [:div.detail {:style {:left (* idx w)}}
           [:div.x_label {:class lr} (.toString (.unix js/moment k))]
           [:div.item.active {:class lr :style {:top top}} "Tweets: " v]
           [:div.dot.active {:style {:top top :border-color "steelblue"}}]])))

    (defn ts-chart
      "Renders timeseries chart consisting of SVG for the bars and a label.
       Appearance is similar to the Rickshaw timeseries chart, which this
       component has replaced, except for the CSS."
      [bars-atom label]
      (let [bars @bars-atom
            indexed (vec (map-indexed vector bars))
            mx (apply max (map (fn [[k v]] v) bars))
            cnt (count bars)
            w (/ ts-w cnt)]
        [:div.rickshaw_graph
         [barchart indexed mx cnt w label]
         [labels bars mx cnt w label]]))

    (defn mount-ts-chart
      "Mount timeseries chart and subscribe to specified pub for state changes.
       The wait time until re-render is specified in the configuration map."
      [state-pub {:keys [every-ms]}]
      (let [state-chan (chan (sliding-buffer 1))
            bars (atom [])
            label (atom {})]
        (go-loop []
                 (let [[_ state] (<! state-chan)]
                   (reset! bars (ts/ts-data state))
                   (<! (timeout every-ms))
                   (recur)))
        (r/render-component [ts-chart bars label] ts-elem)
        (sub state-pub :app-state state-chan)))
#+END_SRC

First, we have a couple of =def=s:

#+BEGIN_SRC clojure
    (def ts-elem (util/by-id "timeseries1"))
    (def ts-w (aget ts-elem "offsetWidth"))
    (def ts-h 100)
#+END_SRC

=ts-elem= is the DOM element where the chart is rendered. =ts-w= and
=ts-h= are simply the width and height of the chart. The width is
dependent on the responsive layout managed by the CSS. The height =ts-h=
is 100 pixels.

Next, we have the =bar= function:

#+BEGIN_SRC clojure
    (defn bar
      "Renders a vertical bar. Enables showing a label when the mouse is
       positioned above the bar."
      [x y h w idx label]
      [:rect {:x x :y (- y h) :fill "steelblue" :width w :height h
              :on-mouse-enter #(reset! label {:idx idx})
              :on-mouse-leave #(reset! label {})}])
#+END_SRC

This renders a single bar of height =h= and width =w= at the =x= and =y=
coordinates. Note the =:y (- y h)=. This is because in SVG's coordinate
system, x=0 and y=0 is in the upper left corner, which is not that
useful for charts. Then, we also have the =idx=, which is the index of
each bar. This is used for rendering a label. When the mouse enters the
bar, the label is shown by setting the =label= atom:
=:on-mouse-enter #(reset! label {:idx idx})=, which is cleared again
when the mouse leaves =:on-mouse-leave #(reset! label {})=. We will look
at the label below.

The =bar= component can now be used inside the =barchart= component:

#+BEGIN_SRC clojure
    (defn barchart
      "Renders a bar chart, making use of the bar function above. Returns
       entire SVG element."
      [indexed mx cnt w label]
      (let [gap (/ (/ ts-w 20) cnt)]
        [:svg {:width ts-w :height ts-h}
         [:g
          (for [[idx [k v]] indexed]
            ^{:key k} [bar (* idx w) ts-h (* (/ v mx) ts-h) (- w gap) idx label])]]))
#+END_SRC

This function first of all determines the =gap= between the bars. It
then renders the =:svg= with all bars inside a group =:g=. Once again,
we are setting the key so that React can reuse elements and be more
efficient. The =label= atom is passed on to the individual bars for the
mouse-in/mouse-out behavior, showing the data for a specific bar in the
label.

Then, we have the =labels= component. Let's first see how that looks
like with the sample data from when we discussed the
=birdwatch.timeseries= namespace:

[[file:images/ts-example-label.png]]

#+BEGIN_SRC clojure
    (defn labels
      "Renders a label for a bar chart. Makes use of Rickshaws CSS."
      [bars mx cnt w label]
      (when-not (empty? @label)
        (let [idx (:idx @label)
              [k v] (get bars idx)
              top (- ts-h (* (/ v mx) ts-h))
              lr (if (< (/ idx cnt) 0.6) "left" "right")]
          [:div.detail {:style {:left (* idx w)}}
           [:div.x_label {:class lr} (.toString (.unix js/moment k))]
           [:div.item.active {:class lr :style {:top top}} "Tweets: " v]
           [:div.dot.active {:style {:top top :border-color "steelblue"}}]])))
#+END_SRC

As you can see above, the =labels= component consists of two parts. On
top it shows how many tweets were encountered in the interval, and at
the bottom it shows us the start of the interval.

Now we have all components together, and we can combine them into the
=ts-chart= component holding the entire bar chart including labels:

#+BEGIN_SRC clojure
    (defn ts-chart
      "Renders timeseries chart consisting of SVG for the bars and a label.
       Appearance is similar to the Rickshaw timeseries chart, which this
       component has replaced, except for the CSS."
      [bars-atom label]
      (let [bars @bars-atom
            indexed (vec (map-indexed vector bars))
            mx (apply max (map (fn [[k v]] v) bars))
            cnt (count bars)
            w (/ ts-w cnt)]
        [:div.rickshaw_graph
         [barchart indexed mx cnt w label]
         [labels bars mx cnt w label]]))
#+END_SRC

This component creates the =:div= that holds both the =barchart= and
=labels= components. Note that I've removed the Rickshaw library from
the project, but for now I'm still using some of its CSS, e.g. the
=rickshaw_graph= class, or the classes used in the =labels= component.

Finally, the =ts-chart= needs to be mounted into the DOM. Also, the
mechanism for subscribing to application state changes needs to be fired
up. This happens in the =mount-ts-chart= function:

#+BEGIN_SRC clojure
    (defn mount-ts-chart
      "Mount timeseries chart and subscribe to specified pub for state changes.
       The wait time until re-render is specified in the configuration map."
      [state-pub {:keys [every-ms]}]
      (let [state-chan (chan (sliding-buffer 1))
            bars (atom [])
            label (atom {})]
        (go-loop []
                 (let [[_ state] (<! state-chan)]
                   (reset! bars (ts/ts-data state))
                   (<! (timeout every-ms))
                   (recur)))
        (r/render-component [ts-chart bars label] ts-elem)
        (sub state-pub :app-state state-chan)))
#+END_SRC

The mechanism here is similar to other Reagent components we've seen.
The function receives the =state-pub= and a time interval as arguments.
Inside a let-binding, the bars and the label info are held in atoms in
addition to the local =state-chan=. Then, inside a =go-loop=, =state=
snapshots are taken off =state-chan=. This =state= snapshot is then used
to derive the timeseries data by calling =ts-data=, a pure function
inside =birdwatch.stats.timeseries=. The timeout here should be longer
as it would be a waste of CPU cycles to call the =ts-data= function
every 10 milliseconds. Every second is fine. Also, the component is
rendered into the DOM element =ts-elem=, and =state-chan= subscribes to
the =state-pub= for the =:app-state= topic. This is exactly the same for
all UI components in this application.
*** Word Cloud Chart
    :PROPERTIES:
    :CUSTOM_ID: word-cloud-chart
    :END:

#+CAPTION: Word Cloud Chart
[[file:images/wordcloud.png]]

The word cloud is generated using *[[http://d3js.org][D3.js]]* and Jason
Davies' *[[https://github.com/jasondavies/d3-cloud][d3-cloud]]* on top
of it. I then wrote some JavaScript code to interact with with
*d3-cloud*. There's not much of a point in going through the *d3* code
here, but if you're interested, you can check it out on GitHub:
*[[https://github.com/matthiasn/BirdWatch/blob/83ff6bfc4b930e877f8f8414b53fc381bf5b4366/Clojure-Websockets/MainApp/resources/public/js/wordcloud.js][wordcloud.js]]*.

Here's the ClojureScript code to interact with =wordcloud.js= in the
=birdwatch.charts.cloud-chart=
*[[https://github.com/matthiasn/BirdWatch/blob/83ff6bfc4b930e877f8f8414b53fc381bf5b4366/Clojure-Websockets/MainApp/src/cljs/birdwatch/charts/cloud_chart.cljs][namespace]]*:

#+BEGIN_SRC clojure
    (ns birdwatch.charts.cloud-chart
      (:require-macros [cljs.core.async.macros :refer [go-loop]])
      (:require [birdwatch.util :as util]
                [birdwatch.stats.wordcount :as wc]
                [cljs.core.async :as async :refer [put! chan sub sliding-buffer timeout]]))

    ;;; WordCloud element (implemented externally in JavaScript)
    (def cloud-elem (util/by-id "wordCloud"))
    (def w (util/elem-width cloud-elem))

    (defn mount-wordcloud
      "Mount word cloud and wire channels for incoming data and outgoing commands."
      [state-pub cmd-chan {:keys [n every-ms]}]
      (let [on-click #(put! cmd-chan [:append-search-text %])
            word-cloud (.WordCloud js/BirdWatch w (* w 0.7) 250 on-click cloud-elem)
            state-chan (chan (sliding-buffer 1))]
        (go-loop []
                 (let [[_ state] (<! state-chan)]
                   (.redraw word-cloud (clj->js (wc/get-words state n)))
                   (<! (timeout every-ms))
                   (recur)))
        (sub state-pub :app-state state-chan)))
#+END_SRC

By now, there should be any surprises in here at all any more. We have
the =go-loop= listening to state changes and the timeout for control
over how often a value is taken off the channel. This is particularly
important for the word cloud as this is by far the most CPU-intensive
operation in the entire BirdWatch application. It would be interesting
to implement the word cloud in pure ClojureScript. Maybe one day.

Inside the =mount-wordcloud= function, we create the =word-cloud=
through JavaScript interop and then inside the =go-loop=, we call the
=.redraw= function with =(clj->js (wc/get-words state n))=, which is the
data structure returned from =wc/get-words= and then converted to a
JavaScript data structure.
*** Word Count Statistics
    :PROPERTIES:
    :CUSTOM_ID: word-count-statistics
    :END:

The =birdwatch.wordcount=
*[[https://github.com/matthiasn/BirdWatch/blob/8a469ff1493816dbedc6cbca9b51fe915aec487f/Clojure-Websockets/MainApp/src/cljs/birdwatch/stats/wordcount.cljs][namespace]]*
is responsible for running word count statistics over tweets received
from the server for both live tweets and chunks of previous tweets.

#+BEGIN_SRC clojure
    (ns birdwatch.wordcount
      (:require [clojure.string :as s]
                [birdwatch.util :as util]))
                
    ;; shortened to fit the page better, see link for full set
    (def stop-words
      #{"use" "good" "want" "amp" "just" "now" "like" "til" "new" "get" "one" "i" 
        "us" "our" "ours" "ourselves" "you" "your" "yours" "yourself" "yourselves"
        "she" "her" "hers" "herself" "it" "its" "itself" "they" "them" "their" 
        "which" "who" "whom" "whose" "this" "that" "these" "those" "am" "is" 
        "being" "have" "has" "had" "having" "do" "does" "did" "doing" "will"})

    (defn get-words
      "get vector of maps with word as :key and count as :value"
      [state n]
      (vec (map
            (fn [w] (let [[k v] w] {:key k :value v}))
            (take n (:words-sorted-by-count state)))))

    (defn get-words2
      "get vector of maps with word as :key and count as :value"
      [state n]
      (vec (take n (:words-sorted-by-count state))))

    (defn words-in-tweet
      "process tweet: split, filter, lower case, replace punctuation, add word"
      [text]
      (->> (s/split text #"[\s—\u3031-\u3035\u0027\u309b\u309c\u30a0\u30fc\uff70]+")
           (filter #(not (re-find #"(@|https?:)" %)) ,)
           (filter #(> (count %) 3) ,)
           (filter #(< (count %) 25) ,)
           (map s/lower-case ,)
           (map #(s/replace % #"[;:,/‘’…~\-!?\[\]\"<>()\"@.]+" "" ) ,)
           (filter (fn [item] (not (contains? stop-words item))) ,)))
#+END_SRC

First, we define a set named =stop-words=. It actually has many more
entries but is shortened here so that it fits the page format better.
These words are not counted towards the result as they aren't very
interesting to look at in the word cloud and the bar chart.

Next, there is the =get-words= function which formats the word count
data from the application state snapshot as required by the word cloud
library by using a mapping function.

For the word count bar chart, which I was lucky enough to implement
myself, I don't need to reformat the data; here =get-words2= retrieves
the data from the application state as is.

Finally, the =words-in-tweet= function takes the text of a tweet, splits
it, removes words that are too short or too long, converts them to
lowercase, replaces a few characters, filters out words contained in the
=stop-words= set, and finally returns a sequence of the relevant words
it found.
*** Wordcount Trends Chart (with Linear Regression)
    :PROPERTIES:
    :CUSTOM_ID: wordcount-trends-chart-with-linear-regression
    :END:

The word count trends chart shows the top 25 words within the body of
tweets loaded in the application, as determined in the
=birdwatch.wordcount= namespace we have discussed previously. The
ranking is in descending order, with a bar and a count number allowing
for comparison between different words. In addition, there are trend
arrows that show how a word has developed recently and over time. Each
bar is also clickable, which adds the word to the search in the input
field below the menu bar. Here's how it looks like:

[[file:images/wordcount-chart.png]]

Let's start with the simplest part, the =birdwatch.charts.shapes=
*[[https://github.com/matthiasn/BirdWatch/blob/83ff6bfc4b930e877f8f8414b53fc381bf5b4366/Clojure-Websockets/MainApp/src/cljs/birdwatch/charts/shapes.cljs][namespace]]*:

#+BEGIN_SRC clojure
    (ns birdwatch.charts.shapes)

    (def arrows
      {:RIGHT      ["#428bca" "-600,100 200,100 -200,500 100,500 600,0 100,-500 -200,-500 200,-100 -600,-100 "]
       :UP         ["#45cc40" "100,600 100,-200 500,200 500,-100 0,-600 -500,-100 -500,200 -100,-200 -100,600"]
       :DOWN       ["#dc322f" "100,-600 100,200 500,-200 500,100 0,600 -500,100 -500,-200 -100,200 -100,-600"]
       :RIGHT-UP   ["#45cc40" "400,-400 -200,-400 -350,-250 125,-250 -400,275 -275,400 250,-125 250,350 400,200"]
       :RIGHT-DOWN ["#dc322f" "400,400 -200,400 -350,250 125,250 -400,-275 -275,-400 250,125 250,-350 400,-200"]})

    (defn arrow [x y dir]
      (let [[color points] (dir arrows)
            arrowTrans (str "translate(" x ", " (+ y 7) ") scale(0.01) ")]
        [:polygon {:transform arrowTrans :stroke "none" :fill color :points points}]))
#+END_SRC

Above, we first have a map named =arrows=, which contains a vector with
the color and the points for each arrow polygon. Then, we have a Reagent
component that takes =x= and =y= coordinates and the direction =dir= and
that returns a =:polygon= in the matching shape and color for the
specified orientation of the arrow, positioned at the specified
coordinates.

The =arrow= component is used in the =birdwatch.charts.wordcount-chart=
*[[https://github.com/matthiasn/BirdWatch/blob/83ff6bfc4b930e877f8f8414b53fc381bf5b4366/Clojure-Websockets/MainApp/src/cljs/birdwatch/charts/wordcount_chart.cljs][namespace]]*,
which we'll look at next:

#+BEGIN_SRC clojure
    (ns birdwatch.charts.wordcount-chart
      (:require-macros [cljs.core.async.macros :refer [go-loop]])
      (:require [birdwatch.util :as util]
                [birdwatch.stats.wordcount :as wc]
                [birdwatch.stats.regression :as reg]
                [birdwatch.charts.shapes :as s]
                [reagent.core :as r :refer [atom]]
                [cljs.core.async :as async :refer [put! chan sub timeout sliding-buffer]]))

    (def items (atom []))
    (def pos-trends (atom {}))
    (def pos-items (atom {}))
    (def ratio-trends (atom {}))
    (def ratio-items (atom {}))
    (def wc-elem (util/by-id "wordcount-barchart"))
    (def wc-w (util/elem-width wc-elem))
    (def text-defaults {:stroke "none" :fill "#DDD" :fontWeight 500 :fontSize "0.8em" :dy ".35em" :textAnchor "end"})
    (def opts [[10 "10 tweets"][100 "100 tweets"][500 "500 tweets"][1000 "1000 tweets"]])

    (defn- bar [text cnt y h w idx cmd-chan]
      (let [pos-slope (get @pos-trends text)
            ratio-slope (get @ratio-trends text)]
        [:g {:on-click #(put! cmd-chan [:append-search-text text])}
         [:text {:y (+ y 8) :x 138 :stroke "none" :fill "black" :dy ".35em" :textAnchor "end"} text]
         [s/arrow 146 y (cond (pos? pos-slope)   :UP       (neg? pos-slope )   :DOWN       :else :RIGHT)]
         [s/arrow 160 y (cond (pos? ratio-slope) :RIGHT-UP (neg? ratio-slope ) :RIGHT-DOWN :else :RIGHT)]
         [:rect {:y y :x 168 :height 15 :width w :stroke "white" :fill "#428bca"}]
         (if (> w 50)
           [:text (merge text-defaults {:y (+ y 8) :x (+ w 160)}) cnt]
           [:text (merge text-defaults {:y (+ y 8) :x (+ w 171) :fill "#666" :textAnchor "start"}) cnt])]))

    (defn- wordcount-barchart [cmd-chan]
      (let [indexed @items
            mx (apply max (map (fn [[idx [k v]]] v) indexed))
            cnt (count indexed)]
        [:div
         [:svg {:width wc-w :height (+ (* cnt 15) 5)}
          [:g
           (for [[idx [text cnt]] indexed]
             ^{:key text} [bar text cnt (* idx 15) 15 (* (- wc-w 190) (/ cnt mx)) idx cmd-chan])
           [:line {:transform "translate(168, 0)" :y 0 :y2 (* cnt 15) :stroke "black"}]]]
         [:p.legend [:strong "1st trend indicator:"]
          " recent position changes"]
         [:p.legend [:strong "2nd trend indicator:"]
          " ratio change termCount / totalTermsCounted over last "
          [:select {:defaultValue 100}
           (for [[v t] opts] ^{:key v} [:option {:value v} t])]]]))

    (defn- update-words
      "update wordcount chart"
      [words]
      (reset! items (vec (map-indexed vector words)))
      (let [items @items
            total-cnt (apply + (map (fn [[_[_ cnt]]] cnt) items))]
        (doseq [[idx [text cnt]] items]
          (swap! pos-items update-in [text] conj idx)
          (swap! ratio-items update-in [text] conj (/ total-cnt cnt))
          (swap! pos-trends assoc-in [text]
                 (get (reg/linear-regression (take 3 (get @pos-items text))) 1))
          (swap! ratio-trends assoc-in [text]
                 (get (reg/linear-regression (take 1000 (get @ratio-items text))) 1)))))

    (defn mount-wc-chart
      "Mount wordcount bar chart and wire channels for incoming data and outgoing commands.
       The number of bars and the wait time until re-render is specified in the configuration map."
      [state-pub cmd-chan {:keys [bars every-ms]}]
      (r/render-component [wordcount-barchart cmd-chan] wc-elem)
      (let [state-chan (chan (sliding-buffer 1))]
        (go-loop []
                 (let [[_ state] (<! state-chan)]
                   (update-words (wc/get-words2 state bars))
                   (<! (timeout every-ms))
                   (recur)))
        (sub state-pub :app-state state-chan)))
#+END_SRC

Okay, there is quite a bit to go through here, and the code also takes
care of the linear regression for the trend arrows. Before discussing
each function, let's have a look at the =birdwatch.stats.regression=
*[[https://github.com/matthiasn/BirdWatch/blob/83ff6bfc4b930e877f8f8414b53fc381bf5b4366/Clojure-Websockets/MainApp/src/cljs/birdwatch/stats/regression.cljs][namespace]]*
first:

#+BEGIN_SRC clojure
    (ns birdwatch.stats.regression)

    (defn square [x] (* x x))
    (defn mean [xs]
      (let [cnt (count xs)]
        (when (pos? cnt) (/ (apply + xs) cnt))))

    (defn linear-regression
      "Computes linear regression. Adapted from
       http://compbio.ucdenver.edu/Hunter_lab/Hunter/cl-statistics.lisp"
      [ys]
      (let [n (count ys)]
        (when (pos? n)
          (let [xs (range n)
                x-bar (mean xs)
                y-bar (mean ys)
                Lxx (reduce + (map (fn [xi] (square (- xi x-bar))) xs))
                Lyy (reduce + (map (fn [yi] (square (- yi y-bar))) ys))
                Lxy (reduce + (map (fn [xi yi] (* (- xi x-bar) (- yi y-bar))) xs ys))
                slope (/ Lxy Lxx)
                intercept (- y-bar (* slope x-bar))
                reg-ss (* slope Lxy)
                res-ms (/ (- Lyy reg-ss) (- n 2))]
            [intercept slope]))))
#+END_SRC

I've adapted the code from
*[[http://compbio.ucdenver.edu/Hunter_lab/Hunter/cl-statistics.lisp][Statistical
functions in Common Lisp. Version 1.04]]* and just removed the stuff I
didn't need. I also created the functions =square= and =mean= for use in
the =linear-regression= function below.

Why linear regression, you may ask? Linear regression allows us to fit a
predictive model to individual data points, where in this simple case
the model is a linear equation represented by a slope and the intercept
with the y-axis. Here's an example from the
*[[http://en.wikipedia.org/wiki/Linear_regression][Wikipedia-article]]*:

[[file:images/linear-regression.png]]

In this particular case, we're not using the model for specific
predictions; instead, we're simply looking at the slope to determine if
there's an upward or a downward trend overall for a specific word.

#+BEGIN_SRC clojure
    (def pos-trends (atom {}))
    (def pos-items (atom {}))
    (def ratio-trends (atom {}))
    (def ratio-items (atom {}))
#+END_SRC

We need a couple of =atom=s in order to store data related to the
intended regression analysis, as you can see above. These are then used
in the =update-words= function:

#+BEGIN_SRC clojure
    (defn- update-words
      "update wordcount chart"
      [words]
      (reset! items (vec (map-indexed vector words)))
      (let [items @items
            total-cnt (apply + (map (fn [[_[_ cnt]]] cnt) items))]
        (doseq [[idx [text cnt]] items]
          (swap! pos-items update-in [text] conj idx)
          (swap! ratio-items update-in [text] conj (/ total-cnt cnt))
          (swap! pos-trends assoc-in [text]
                 (get (reg/linear-regression (take 3 (get @pos-items text))) 1))
          (swap! ratio-trends assoc-in [text]
                 (get (reg/linear-regression (take 1000 (get @ratio-items text))) 1)))))
#+END_SRC

First of all, the function takes the parameter =words=, which is the
current top-n list from the application state. We use that to =reset!=
the =items= atom as a vector of indexed vectors, in which the index is
in first position and a vector with =text= and =count= in the second
position, as you can see in the =do-seq= below: =[idx [text cnt]]=.

Next, we dereference =items= and get =total-cnt=, which is simply the
total count of words within =items=. Then, we do a couple of things with
each item within =items=, destructured as seen above. Within
=pos-items=, we add / =conj= the latest position to the sequence we keep
for each word. We do the same for =ratio-items=, only that here we use a
ratio. With those updated, we determine the slope for each by running
=reg/linear-regression= and store the result in the =pos-trends= and
=ratio-trends= map for the particular word. These will later be
dereferenced when determining the direction of the arrow.

Now let's have a look at the =bar= component:

#+BEGIN_SRC clojure
    (defn- bar [text cnt y h w idx cmd-chan]
      (let [pos-slope (get @pos-trends text)
            ratio-slope (get @ratio-trends text)]
        [:g {:on-click #(put! cmd-chan [:append-search-text text])}
         [:text {:y (+ y 8) :x 138 :stroke "none" :fill "black" :dy ".35em" :textAnchor "end"} text]
         [s/arrow 146 y (cond (pos? pos-slope)   :UP       (neg? pos-slope )   :DOWN       :else :RIGHT)]
         [s/arrow 160 y (cond (pos? ratio-slope) :RIGHT-UP (neg? ratio-slope ) :RIGHT-DOWN :else :RIGHT)]
         [:rect {:y y :x 168 :height 15 :width w :stroke "white" :fill "#428bca"}]
         (if (> w 50)
           [:text (merge text-defaults {:y (+ y 8) :x (+ w 160)}) cnt]
           [:text (merge text-defaults {:y (+ y 8) :x (+ w 171) :fill "#666" :textAnchor "start"}) cnt])]))
#+END_SRC

For every bar, we dereference =pos-slope= and =ratio-slope=. With that,
we create a =:g= element, which is a group in SVG. Within it, we
position text, the arrows and the bar rectangle =:rect=. Finally,
depending on the width of the bar, we position the counter either inside
the bar when it's wide enough or outside when it's too narrow.

To put things together, we then have the =wordcount-barchart= component:

#+BEGIN_SRC clojure
    (defn- wordcount-barchart [cmd-chan]
      (let [indexed @items
            mx (apply max (map (fn [[idx [k v]]] v) indexed))
            cnt (count indexed)]
        [:div
         [:svg {:width wc-w :height (+ (* cnt 15) 5)}
          [:g
           (for [[idx [text cnt]] indexed]
             ^{:key text} [bar text cnt (* idx 15) 15 (* (- wc-w 190) (/ cnt mx)) idx cmd-chan])
           [:line {:transform "translate(168, 0)" :y 0 :y2 (* cnt 15) :stroke "black"}]]]
         [:p.legend [:strong "1st trend indicator:"]
          " recent position changes"]
         [:p.legend [:strong "2nd trend indicator:"]
          " ratio change termCount / totalTermsCounted over last "
          [:select {:defaultValue 100}
           (for [[v t] opts] ^{:key v} [:option {:value v} t])]]]))
#+END_SRC

The =wordcount-barchart= renders a =:div= with the =:svg= inside, with
one =bar= component for each item in =indexed=, which is the
dereferenced =items= atom. In addition, there's some text plus a
=:select=, which is intended for choosing the number of recent items to
include in the regression analysis over the ratios. That's not actually
implemented yet, though. Pull request, anyone?

Finally, the chart needs to be mounted, which follows the pattern we've
seen a few times already:

#+BEGIN_SRC clojure
    (defn mount-wc-chart
      "Mount wordcount bar chart and wire channels for incoming data and outgoing commands.
       The number of bars and the wait time until re-render is specified in the configuration map."
      [state-pub cmd-chan {:keys [bars every-ms]}]
      (r/render-component [wordcount-barchart cmd-chan] wc-elem)
      (let [state-chan (chan (sliding-buffer 1))]
        (go-loop []
                 (let [[_ state] (<! state-chan)]
                   (update-words (wc/get-words2 state bars))
                   (<! (timeout every-ms))
                   (recur)))
        (sub state-pub :app-state state-chan)))
#+END_SRC

Other than in the time series chart, I'm not storing the atoms inside
the let-binding of the =mount-wc-chart= function. There's not specific
reason for that, one could as well keep the atoms contained inside the
function.
** Summary
   :PROPERTIES:
   :CUSTOM_ID: summary
   :END:

While working on this chapter, I rewrote the client-side architecture in
a way that I believe will be much easier to reason about than before.
*Core.async* really is a great way to decouple different parts of an
application, and I am more convinced about that than ever.

Now, me finding this architecture sane and easy to reason about is one
thing, but how about you? Do you actually find the new architecture easy
to follow and generally sane? After making it this far in the book, you
should be in a great position to give me some feedback. Can you please
send me an email answering one or more of the following questions?

- Does the architecture make sense to you?
- Were you able to follow the code and explanations?
- What would you do differently?
- Is there anything that annoys you about this book?

Any additional feedback is welcome as well. Much appreciated, thank you!
Here's my address:
[[mailto:matthias.nehlsen@gmail.com][matthias.nehlsen@gmail.com]]

As the server-side and client-side chapters are written and ready for
review and comments, I can now take the architecture for a spin. I want
to do load tests and also implement a couple of additional features.
Let's see if the application performs well under load and if it is easy
to add features.

Thanks for reading this book and thank you for your feedback! Matthias

#+Latex:\pagebreak
* The systems-toolbox library
  :PROPERTIES:
  :CUSTOM_ID: the-systems-toolbox-library
  :END:

** Introduction
   :PROPERTIES:
   :CUSTOM_ID: introduction
   :END:

Maybe you have read the previous chapters carefully, or maybe you just
skimmed through. Either is fine as long as you noticed the
*repetitiveness* in the code. If not, maybe it helps to squint when
looking at the code. Don't get me wrong, I'm not saying the code is
entirely bad or anything, and I believe one could write an application
this way and get along okay. The
*[[https://github.com/matthiasn/BirdWatch][BirdWatch]]* application, for
example, was running like this for many months without a glitch, much to
my satisfaction, and processing tens of millions of tweets. I just
didn't like it too much.

Writing about the architecture made the abundance of boilerplate
painfully evident as I noticed that I was describing the same things
over and again. Writing repetitive code is one thing, but writing ABOUT
repetitive code is much worse. It's a good exercise, however. Try
writing about some project and its architecture. If something annoys
you, you may well be onto something.

So when going through this exercise, I made up my mind that I didn't
want to repeat myself as much when building somewhat complex systems.
Not in any of my toy projects and for sure not in commercial projects,
either. But how could one extract the commonality between different
parts of the system?

At the same time when I started looking at refactoring my applications,
I had started looking at the world through the lens of
*[[https://en.wikipedia.org/wiki/Systems_thinking][Systems Thinking]]*.
There is something very compelling about seeing the world as a mesh of
systems that potentially interact in one way or another. Coming from
that perspective, I was wondering if I could apply that kind of thinking
to software architecture where an application forms a system that
consists of subsystems.

Such a subsystem could, for example, be the persistence layer that
handles saving data to some storage. Or it could be the HTTP server. Or
a UI component. Whatever, any entity that has definable borders and that
serves an explicit purpose can be such a subsystem.

So what is the commonality of such subsystems or components? By the way,
I will use the terms /subsystem/ and /component/ interchangeably. Let me
start with a brief rant about
*[[https://en.wikipedia.org/wiki/Object-oriented_programming][Object-Oriented
Programming]]*. There's one thing I never got, and that's the fanfare
about encapsulation. We typically argue that encapsulation is essential
for protecting the mutable state of an object from accidental
mutilation. Fair enough, if you buy into the idea of uncontained
mutability. But coming from functional programming and wearing
Clojure-colored glasses, I don't think application state should ever
live inside any entity that allows direct and uncontrolled mutation from
anywhere. Instead, immutable data structures are ALWAYS the better
choice when trying to relay information in any way. But as long as those
data structures are immutable, why should you and I not see every detail
there is to see? If there's no harm in doing so, why not, right? Plus,
additional information never hurt anyone when trying to reason about a
system.

So with the above in mind, I'd like each subsystem to be fully
observable. To be able to do useful stuff, such a subsystem would need
to be able to retain some state, which I want to be able to inspect at
any point during runtime. Such subsystem would also need the means to
communicate with the rest of the world, and, in particular, other parts
of the overall system via message passing, but, at the edges of the
system as a whole, also with the outside world.

When it comes to relaying information, I found
*[[https://en.wikipedia.org/wiki/Communicating_sequential_processes][Communicating
Sequential Processes (CSP)]]* to be a very useful abstraction. However,
directly modeling an application by utilizing
*[[https://github.com/clojure/core.async][core.async]]*, Clojure's
incarnation of CSP, always seemed a little tedious to me. Say you had a
few different gadgets in a home automation system, such as the central
heating, flow meters, thermometers, and remotely controlled thermostats,
how do you map their interaction mentally? Do you think along the lines
of, this connects to that in some way to achieve a meaningful purpose,
or do you mentally lay out the actual plumbing or the network devices,
wires or airwaves? I didn't think so, other than that you may want to
know about the general properties of the connections involved.

I felt the same way about
*[[https://github.com/clojure/core.async][core.async]]*. It's a very
useful library, but the previous architecture of BirdWatch forced me to
look at the actual plumbing where I only wanted to think about different
subsystems and their actions and connections.

Now let's look at *subsystems* one more time. Any given component
interacts with the outside world in two different ways. First, there's
direct communication, where there's the expectation that the recipient
of a message acts the way it wants to a given message. You know, like
when you're sending your tax declaration to the appropriate authorities,
such as the IRS. You expect a response. You better don't have specific
expectations about how long it'll take, but at some point, you will get
a response, and you will then (hopefully) know how to handle the
message. In essence, that's asynchronous message passing. With this kind
of message passing, there's a general expectation that the message
enacts something, whatever that something is. Or, if no other subsystem
is wired to react to such a message, we can expect nothing to happen,
other than that message leaving some observable trace.

And then there's another kind of information passing altogether. Here,
it's all about observability. When the thermometer on my balcony
measures the temperature and displays it, it has no notion of wanting to
enact anything in the real world. The only reason for the display of the
temperature data lies in the observability of the reading. I as the
observer then usually only care about the latest reading. The remaining
readings will disappear as the reflected photons collide with a brick
wall or whatever. Heisenberg's uncertainty principle aside, I don't want
to worry conceptually about the effects of my observation on the
reading. At the same time, my brain will only take into account as many
readings as it can or wants to process.

Let's see what this means for a piece of software. In the BirdWatch
application, there is a client side component or subsystem that holds
the application state inside an
*[[http://clojure.org/reference/atoms][atom]]*. This component knows how
to handle incoming messages, such as new tweets, and how to alter its
internal state after applying some business logic to the previous state
while taking the incoming messages into consideration. And then, there
are multiple UI components that render the current application state.
They don't require write-access to the application state; instead, they
only render what they can observe. At the same time, only the latest
instance of such an immutable state snapshot ever needs to be taken into
account, as all previous ones are stale information by the time there's
a newer snapshot.

Looking at the BirdWatch application again, the =state component=
receives new messages, including chunks with the last 5000 tweets or
whatever you choose. The state component, which handles such chunk
messages, mutates its internal state atom like 50-60,000 within less
than 5 seconds after application startup. There's no reason to drain the
battery by rendering every single one of the emitted snapshots into a
virtual DOM representation and then have
*[[https://facebook.github.io/react/][React]]* detect the changes by
diffing every such representation. Instead, all that needs to happen is
rendering the newest snapshot 60 times per second to achieve a
satisfactory user experience that appears to be running smoothly.

More broadly speaking, any component will have some internal state. This
component will broadcast any mutation of its state atom by emitting an
immutable snapshot of the latest state. Any consumer of such snapshots
then only subscribes to as many as it can process, with the guarantee to
always get the latest version whenever it is ready to consume a new
snapshot. Core.async's
*[[https://clojure.github.io/core.async/#clojure.core.async/sliding-buffer][sliding
buffer]]* is the building block that enables this behavior. It is a
buffer of a defined size that will always make room for new messages by
discarding the oldest unconsumed messages.

When dealing with state snapshots, we can even create one such buffer of
/size one/ that only holds the latest snapshot message. Components then
emit snapshots of their internal state, without blocking unnecessarily
when unknown recipients aren't ready for consumption. Such a mechanism
is not something I should have to rewrite every single time; rather, the
library should come with an abstraction for building such components,
without writing repetitive boilerplate.

Potential observers can then subscribe to such state snapshots, all
while again being guarded by another such sliding buffer against
becoming overly busy with processing outdated snapshots.

Let's look at a possible design of a subsystem. Each component can,
first of all, keep its state in an =atom=. The specifics of the initial
state differ, so this is something we will have to pass to a
component/subsystem "factory" function. The component will then
automatically publish changes to this atom on a channel in the form of
snapshots. Then, there's another outgoing channel for messages that we
intend another component to process. Components do not have to interact
with this channel directly. Instead, we can pass the component a
function named =put-fn= that it can then call whenever it has a message
to emit.

#+CAPTION: Subsystem/Component
[[file:images/system.png]]

On the input side of a component, we once again have two different
channels. One of them is for handling messages that require processing
every time. The other is for observing messages such as state snapshots,
where only ever the last version is of interest. In either case, the
existence of such channels as a means of taking information in is common
to all components, whatever their purpose. For the differences in
behavior, we only need to specify handler functions for the different
message types. These handlers take a map with the state =atom= and the
=put-fn= (among others) so they can change the component state and emit
messages when required. Giving those handlers access to the application
state is safe thanks to *[[http://clojure.org/refs][Software
Transactional Memory]]*, in case you worried about concurrency just now.

On the output side, there are the channels mentioned above, one for
sending messages with some intent, and another one for emitting state
snapshots. Publishing such snapshots is not something you have to worry
about, it is taken care of by the library whenever any of your handlers
updates the component state atom.

One important thing to note here is that the provided mechanisms for
creating components work equally well on the Clojure/JVM and the
ClojureScript/Browser side. In fact, the code is the same, it is written
in =.cljc= files making use of
*[[http://dev.clojure.org/display/design/Reader+Conditionals][reader
conditionals]]* that come with Clojure 1.7. In short, this feature
allows maintaining a single code base for all platforms, where only the
differences between platforms have to be implemented differently. I
recommend reading the announcement linked above if you'd like to find
out more about this new language feature.

The sweet thing about exploring and writing the
*[[https://github.com/matthiasn/systems-toolbox][systems-toolbox]]*
library is that it's not a mere thought experiment but also something
that we're building a commercial system upon at my current gig. There,
such subsystems are communicating with each other, connected over fast
WebSockets, should messages need to traverse platform boundaries between
client and server. Also, the latest version of the
*[[https://github.com/matthiasn/BirdWatch][BirdWatch]]* application uses
this library both on client and server, providing a unified way of
writing code on both sides. Also, all the UI components are built on top
of this library, as we shall see.

Okay, so much about the motivation behind the library. Let's look at a
simple example next.

#+Latex:\pagebreak
* The systems-toolbox-ui library
  :PROPERTIES:
  :CUSTOM_ID: the-systems-toolbox-ui-library
  :END:

** Introduction
   :PROPERTIES:
   :CUSTOM_ID: introduction
   :END:

Pretty much any application out there has some a user facing aspect.
Even those that don't have one would usually greatly benefit from having
a user interface that tells you at a glance if your services are
healthy. Also, I just generally find it more rewarding to work on
something that has some presentation layer, no matter how sparse. So
let's make it easy to add a presentation layer to an arbitrary piece of
backend code, shall we?

** React
   :PROPERTIES:
   :CUSTOM_ID: react
   :END:

*[[https://facebook.github.io/react/][React]]* is a UI renderer by
Facebook. It *only* does the rendering and is not a Framework for
JavaScript applications. However, it does the rendering a) quite well
and b) in a way that is particularly useful when coming from a
functional programming approach.

Let me explain. What happens is that we define a function that turns
some data into a DOM (sub)-tree. There is no notion of manipulating that
tree, as you'd tediously have to do with the likes of jQuery. Rather,
every time the data changes, the entire thing is rendered. So far, that
sounds conceptually pure but at the same time very expensive, right?
Well, it would be, only that this rendering does not happen in the
actual, heavy-weight DOM but into a lightweight JavaScript data
structure called virtual DOM. Then, there's a diffing process that
compares the previous version of that virtual DOM (which corresponds to
what is on the page) and the latest version, determines the changes, and
only then puts those changes into effect on the page. This mechanism
happens to be fast.

Why should you care? In Clojure and ClojureScript, we strongly favor
working with immutable data structures. Thus, it conceptually fits very
well to think of DOM tree as something immutable, instead of something
that you have to modify in place. If there are state changes, we just
pass the new state to that function that creates our UI, and then let it
figure out under the hood how to get there. For all we need to care
about, this UI renderer recreates our UI on every single change.

** Redux
   :PROPERTIES:
   :CUSTOM_ID: redux
   :END:

*[[https://github.com/reactjs/redux][Redux]]* is one possible approach
to creating a larger application that makes use of React as its
renderer. Redux is not tied to React but in reality, those libraries are
probably most often used together. The general idea here is that there
is some protected state container. Mutations of that managed application
state then cannot happen from random places in your program. Instead,
you can only dispatch actions to that managed state container, which
will act on that action (or not, if no such action is defined). This
model defines clear borders of where state mutation can happen, and thus
makes the application easier to maintain.

I have not worked with Redux extensively, but the approach is the same
with the
*[[https://github.com/matthiasn/systems-toolbox-ui][systems-toolbox-ui]]*
library, and it works well there. Let's have a look at a simple example
next.

** Counter example
   :PROPERTIES:
   :CUSTOM_ID: counter-example
   :END:

When you go through the examples for Redux, you'll see one with some
counters. Let's do the same thing with *systems-toolbox-ui* library. You
can also find the code this example
*[[https://github.com/matthiasn/systems-toolbox-ui/tree/master/examples/redux-counter01][here]]*.
This is how it is going to look like:

[[file:images/counter.png]]

As you can see in the screenshot above, we have a very simple UI that
first of all shows us the application state, and then initially three
counters, each of which with a button to increment and decrement the
counter, plus buttons to add and remove another counter at the end.

Now remember from Redux that we can only interact with the state using
actions. Let's have a look at the namespace implementing the store
first.

#+BEGIN_SRC clojure
    (ns example.store)

    (defn inc-handler
      "Handler for incrementing specific counter"
      [{:keys [current-state msg-payload]}]
        {:new-state (update-in current-state [:counters msg-payload] inc)})

    (defn dec-handler
      "Handler for decrementing specific counter"
      [{:keys [current-state msg-payload]}]
        {:new-state (update-in current-state [:counters msg-payload] dec)})

    (defn remove-handler
      "Handler for removing last counter"
      [{:keys [current-state]}]
      {:new-state (update-in current-state [:counters] #(into [] (butlast %)))})

    (defn add-handler
      "Handler for adding counter at the end"
      [{:keys [current-state]}]
        {:new-state (update-in current-state [:counters] conj 0)})

    (defn state-fn
      "Returns clean initial component state atom"
      [_put-fn]
      {:state (atom {:counters [2 0 1]})})

    (defn cmp-map
      [cmp-id]
      {:cmp-id      cmp-id
       :state-fn    state-fn
       :handler-map {:cnt/inc inc-handler
                     :cnt/dec dec-handler
                     :cnt/remove remove-handler
                     :cnt/add add-handler}})
#+END_SRC

Okay, let's go through this namespace from the bottom up. The =cmp-map=
generates a map which the =systems-toolbox= library needs to
create/instantiate a component. The =cmp-id= is straight-forward, this
is required when later wiring the component with other components. Then,
there is the =:state-fn= key. Here, a function is expected that takes
the =put-fn=, which is the function that allows a component to emit
messages at any time, irrespective of incoming messages, and that
returns a map with the initial component state as an atom.

Then, there's the handler map. It's a map with the different message
types that the component handles as keys, and the respective handler
functions as values.

Then, there are the handler functions. Handler functions take a single
argument, a map, which among other things contains the =current-state=
and =msg-payload=. There are other keys on the argument map, such as
=msg= for the entire message (vector with msg-type plus msg-payload),
=msg-type=, which is a namespaced keyword, =msg-meta= for more
information on about the message and so on. For now, it's only important
that the message payloads here need to be integers that correspond to
indices of existing counter entries. Then, the handler functions can
return the new component state after processing the message in the
=new-state= key on the return map. Handlers can also emit messages
themselves, but we'll look at that later. What those handlers do should
be relatively straight-forward. Those take the current component state
and modify it by either increasing/decreasing the value at a particular
index or by adding or removing a value at the end.

That's it for the state component. Now we can let other components
observe its state, for example, our UI component:

#+BEGIN_SRC clojure
  (ns example.counter-ui
    (:require [matthiasn.systems-toolbox-ui.reagent :as r]
              [matthiasn.systems-toolbox-ui.helpers :as h]))

  (defn counter-view
    "Renders individual counter view, with buttons for increasing or
    decreasing the value."
    [idx v put-fn]
    [:div
     [:h1 v]
     [:button {:on-click #(put-fn [:cnt/dec idx])} "dec"]
     [:button {:on-click #(put-fn [:cnt/inc idx])} "inc"]])

  (defn counters-view
    "Renders counters view which observes the state held by the state
    component. Contains two buttons for adding or removing counters, plus
    a counter-view for every element in the observed state."
    [{:keys [current-state put-fn]}]
    (let [indexed (map-indexed vector (:counters current-state))]
      [:div.counters
       [h/pp-div current-state]
       [:button {:on-click #(put-fn [:cnt/remove])} "remove"]
       [:button {:on-click #(put-fn [:cnt/add])} "add"]
       (for [[idx v] indexed]
              ^{:key idx} [counter-view idx v put-fn])]))

  (defn cmp-map
    [cmp-id]
    (r/cmp-map {:cmp-id  cmp-id
                :view-fn counters-view
                :dom-id  "counter"}))
#+END_SRC

Here, we have two different functions that each generates a piece of the
UI. =counter-view= renders an individual counter, together with buttons
for either increasing or decreasing the value of the counter. Note that
the buttons do not interact with the state component directly. Rather,
when clicking a button, a message is sent, which is then handled by the
state component. Thus, we have a clear separation of concerns, rather
than state mutation from anywhere.

Next, there is the =counters-view= function, which renders the
application state in a pretty-printed format, two buttons for adding or
removing counters, plus a =counter-view= for every counter in the
counters vector of the application state.

Now, we finally need to wire everything together. This happens in the
=core= namespace of our example:

#+BEGIN_SRC clojure
    (ns example.core
      (:require [example.store :as store]
                [example.counter-ui :as cnt]
                [matthiasn.systems-toolbox.switchboard :as sb]))

    (defonce switchboard (sb/component :client/switchboard))

    (defn init
      []
      (sb/send-mult-cmd
        switchboard
        [[:cmd/init-comp (cnt/cmp-map :client/cnt-cmp)]
         [:cmd/init-comp (store/cmp-map :client/store-cmp)]
         [:cmd/route {:from :client/cnt-cmp :to :client/store-cmp}]
         [:cmd/observe-state {:from :client/store-cmp :to :client/cnt-cmp}]]))

    (init)
#+END_SRC

Here, we declare a switchboard in a =defonce=, so that it survives
application reloads. This is necessary for use with
*[[https://github.com/bhauman/lein-figwheel][figwheel]]*, but more about
that later. Then, there's an init function, in which we send multiple
commands to that switchboard. The =:cmd/init-comp= tells the switchboard
to instantiate both the UI and the state components for us. The order
here does not matter, because, at this point, they don't need to
exchange messages yet. Then, we route all messages from the UI component
to the store component. These are the command messages for incrementing
and decrementing counters. In Redux, these are called actions. Then
finally, we tell the switchboard that the UI component is supposed to
observe the state of the store component. Thus every time our
application state changes, the UI is re-rendered automatically.

*** Better UI development with Figwheel
    :PROPERTIES:
    :CUSTOM_ID: better-ui-development-with-figwheel
    :END:

*[[https://github.com/bhauman/lein-figwheel][Figwheel]]* is a game
changer for UI development in ClojureScript. It is so much better to
have your UI automatically (and almost instantly) reload after a code
change that I can't imagine working without it any longer. Of course,
the *systems-toolbox* and *systems-toolbox-ui* also had to support it to
be of any use. So how do you use figwheel? Instead of compiling the
ClojureScript with =lein cljsbuild auto release=, you instead run
=lein figwheel=. This command will first compile your ClojureScript code
and then watch the code for changes, recompile it and reload the
application. The *systems-toolbox* supports this by preserving the state
of your components upon reload.

You can, for example, try change to the text of the buttons after
clicking them a few times and adding a few counters, so that your
application state is different from the initial state. Now, for example,
change the "inc" text to "+" and save the file. Within about a second,
you will see that your page reloads while retaining the previous state.
This feature can make your development much faster.

Also, you can change the handlers on the fly. Try to change the
=inc-handler= so that it resembles the following:

#+BEGIN_SRC clojure
  (defn inc-handler
    "Handler for incrementing specific counter"
    [{:keys [current-state msg-payload]}]
    {:new-state
     (update-in
      current-state
      [:counters msg-payload]
      #(+ % 10))})
#+END_SRC

Now, after reload, every click on the =inc= button of a counter will
increase its value by 10, all while still retaining the previous state
upon reload. Just note that reloading may not work as expected if you
change the structure of the application state map. Obviously, the reload
mechanism will only have the previous state at its disposal, and if that
doesn't match expectations any longer, your application may not work
after a reload triggered by figwheel. In that case, just do a
"traditional" page reload.

By the way, the automatic reload also works for CSS changes. This is a
huge time saver when you tweak the CSS of some page of the application
where a =cmd-r= reload of the page will not get you to the same page
yet, maybe because the routing or session persistence isn't completely
implemented yet.

#+Latex:\pagebreak
* Monitoring
  :PROPERTIES:
  :CUSTOM_ID: monitoring
  :END:

There is only one way to get to know a system: observation. We will want
to observe how a system responds under different circumstances. For
that, we will need data from instrumenting the system and then process
the data and make it more digestible for human consumption. For example,
what kind of load can my system handle until the response times become
unacceptable? Will the system recover after short bursts or will it just
die, e.g. with an *Out of Memory Error*? Is there a network bottle neck?
Is the processing inside the application IO-bound or CPU-bound?

All these insights will make us more comfortable when the system is
deployed. The monitoring should be in place all the time, both in
production and when doing load tests. Then, we could for example detect
unhealthy patterns and proactively fire up addition instances on *AWS*
or whatever before things get ugly. Or we could monitor the behavior of
the JVM (e.g. garbage collection pauses) and optimize the settings to
make the system hosted on it run as smoothly as possible. The JVM is
really only another system that interacts with the systems running on it
and that can be observed and optimized.

I recently discovered the
*[[https://github.com/dropwizard/metrics][metrics library]]* from
*[@coda](https://twitter.com/coda)* by watching his
*[[http://pivotallabs.com/139-metrics-metrics-everywhere/][talk]]* about
the library. It contains a lot of the functionality that we could want
for observing a system, such as *Meters*, *Gauges*, *Counters* and
*Histograms*. We will look at all these in detail and see how we can
possibly use them in the context of our architecture that relies heavily
on *core.async* for separating different parts of the system.

Let's get started.

** Inspect
   :PROPERTIES:
   :CUSTOM_ID: inspect
   :END:

#+Latex:\pagebreak
* Testing
  :PROPERTIES:
  :CUSTOM_ID: testing
  :END:

In this chapter, I will discuss testing strategies for both the server
and the client parts of a system. Let me start with a confession. I have
to admit that I am not an adamant disciple of *TDD*. In theory, that all
sounds great, but I just haven't seen many real world examples of
convincing test suites in the last couple of years.

If you do have a setup that gives you confidence in making changes, that
is awesome. I don't buy that the confidence comes from the test suite
alone, though. Rather, trust in changing an existing codebase comes from
the feeling that you understand the codebase. Sure, green tests assure
you that you did not break anything *for which there are tests*.
Depending on how well thought-through a test suite is, that may mean a
lot or absolutely nothing. But if your codebase is an unintelligible
mess, then no amount of tests will give me any confidence in anything,
especially since bad coding practices that make code hard to reason
about usually extend to the tests as well. I have just been in the
situation while there were tests for some area of the codebase, the
tests made little sense and did not keep anyone from introducing
breaking changes that only later came back as bugs to fix. Such
inadequate tests are more harmful than anything, as they give you false
confidence.

Proper reasoning and having an overall strategy of what you want to
achieve is far more important IMHO. Let's have a look what Rich Hickey
has to say about testing in
*[[https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/SimpleMadeEasy.md][Simple
Made Easy]]*:

#+BEGIN_QUOTE
  And I like to ask this question: What's true of every bug found in the
  field?
#+END_QUOTE

[Audience reply: Someone wrote it?] [Audience reply: It got written.]

#+BEGIN_QUOTE
  It got written. Yes. What's a more interesting fact about it? It
  passed the type checker.
#+END_QUOTE

[Audience laughter]

#+BEGIN_QUOTE
  What else did it do?
#+END_QUOTE

[Audience reply: (Indiscernible)]

#+BEGIN_QUOTE
  It passed all the tests. Okay. So now what do you do? Right? I think
  we're in this world I'd like to call guardrail programming. Right?
  It's really sad. We're like: I can make change because I have tests.
  Who does that? Who drives their car around banging against the
  guardrail saying, "Whoa! I'm glad I've got these guardrails because
  I'd never make it to the show on time."
#+END_QUOTE

[Audience laughter]

#+BEGIN_QUOTE
  Right? And - and do the guardrails help you get to where you want to
  go? Like, do guardrails guide you places? No. There are guardrails
  everywhere. They don't point your car in any particular direction. So
  again, we're going to need to be able to think about our program. It's
  going to be critical. All of our guardrails will have failed us. We're
  going to have this problem. We're going to need to be able to reason
  about our program. Say, "Well, you know what? I think," because maybe
  if it's not too complex, I'll be able to say, "I know, through
  ordinary logic, it couldn't be in this part of the program. It must be
  in that part, and let me go look there first," things like that.
#+END_QUOTE

#+BEGIN_QUOTE
  -- /Rich Hickey, 2011/
#+END_QUOTE

If you haven't seen this talk, please do that now. Or read the
transcript or both. It's worth it.

Of course, tests aren't useless either. There can be value in them, but
you do need to think about testing the right stuff. Just having 2,000
(poorly conceived) tests means little for the amount of confidence your
software deserves.

** Unit Tests
   :PROPERTIES:
   :CUSTOM_ID: unit-tests
   :END:

In general, I find unit tests to be overused. How deeply do we want to
test implementation details? I find this particularly bothersome when
testability guides how you write the code in the first place. I have
just seen it too often that a particular part of a codebase became way
too rigid and difficult to change for no reason other than testing some
rather unimportant implementation detail. YMMV.

** Integration Tests
   :PROPERTIES:
   :CUSTOM_ID: integration-tests
   :END:

Integration tests, on the other hand, can be very helpful, particularly
when working on the same codebase with multiple teams. I found that to
be the case even more so with Clojure. I don't miss a type system
generally, but there is something nice about, say, defining a class for
an individual exchange of information in your program. Sure, a map is
more flexible, but with flexibility comes greater responsibility. With a
class, you, at least, know what's supposed to be in it. When what you
pass is a map, you should honor some conventions and not arbitrarily
change stuff just because it's a full moon, and when the moon is full,
you prefer date format y over date format x or whatnot. Even if you
change the tests for your web service over to your idiotic date format
y, you still break downstream consumers of your API. By the way, having
modified your unit tests with the new date format would not have helped
this at all.

However, this is where the integration tests for the downstream users
come in handy. You should not be able to make such a change that breaks
the API users *and* merge it to a common branch. Rather, there should be
a set of high-level integration or acceptance tests that need to pass
before you can merge any change back to the master branch.

Such integration tests need to meet a few criteria:

1) The integration tests need to be reliable so we can trust them. That
   means that if they are not, your team has to *stop everything* else
   they are doing until the tests are fixed--even if management finds
   other matters more important. Ultimately, us developers are
   responsible for a broken environment, not management.

2) All integration tests need to run all the time. There needs to be a
   continuous integration environment that runs tests on all commits in
   all branches. In situations where tests aren't reliable, I have found
   it helpful to set up the CI environment to run all tests every 15 or
   30 minutes and then have a look which tests fail most often. By
   running all tests like an extra hundred times a day will very soon
   give you the data you need to figure out which of those tests are the
   most unreliable. Then, you can start fixing them in that order. Sure,
   it'll increase your electricity bill for a while, but fixing the
   broken tests will also increase your level of sanity.

3) For the above to be feasible, the test suite needs to be quick to
   execute. Tests that take an hour to run and are therefore never
   executed are utterly useless. There's also little justification for
   that kind of situation. Some people believe that every test should
   start with a clean slate, but that's particularly harmful in Clojure.
   Yes, the time required to start anything Clojure on the JVM sucks.
   But why then would anyone want to start a fresh instance of your
   backend for each test??? That's probably okay when you start
   something written in C that fires up in a fraction of a second, but
   starting a JVM with a Clojure service can easily take ten seconds or
   more. How can it be a good idea to do this over and again, hundreds
   of times? Also, my expectation against a backend is that it can deal
   with all conceivable testing scenarios in any order. Rather than fire
   up some service over and again, I'm strongly for firing up the
   artifact that will be deployed just once and observe if it does what
   it is expected to do. Also, make sure you test the artifact that is
   supposed to be deployed. If it's anything other than that, then you
   can't have confidence in the deployable artifact.

4) Merges to the master branch that break tests must be forbidden, even
   when it's the test suite of another team that happens to depend on
   your code. For that, it's best to have your CI server automatically
   vote against your change when not all tests pass.

** Continuous Integration
   :PROPERTIES:
   :CUSTOM_ID: continuous-integration
   :END:

One important part of building a software system is creating the
environment that allows us to be confident that it works. For this,
continuous integration is essential. There are many options out there.
When you want to host the CI environment yourself, I have good
experiences with *[[https://jenkins-ci.org/][Jenkins]]*, which is open
source and free. If you use
*[[https://www.atlassian.com/software/jira][Jira]]*, you may want to
have a look into
*[[https://www.atlassian.com/software/bamboo][Bamboo]]*, which
integrates nicely. I'm just not so sure I like Jira, but that's an
entirely different story.

** Hosted CI
   :PROPERTIES:
   :CUSTOM_ID: hosted-ci
   :END:

After wasting an incredible amount of precious lifetime on the
internally hosted CI environment in my last consulting gig, I thought I
should have a look at some hosted options for continuous integration.
Luckily, the better ones host open source projects for free, so I set up
two with GitHub integration for the systems-toolbox library. So far,
both seem to do the job, and both support open source projects for free.

Unless you're in the business of building CI servers, I can only
recommend you spend your time and resources on the problems you want to
solve, rather than wasting time on tweaking your own, poor CI
environment. Otherwise, you're not only blocking the guys trying to set
up your CI nodes, but also everyone else who's waiting for them.

*DISCLAIMER*: I don't receive money from either, nor do I know anyone in
either company.

*** TravisCI
    :PROPERTIES:
    :CUSTOM_ID: travisci
    :END:

[[file:images/testing/travis-ci.png]]

*[[https://travis-ci.org/matthiasn/systems-toolbox][TravisCI]]* is quite
easy to use. Once you've signed up, all you need to do is add a YAML
file named =.travis.yml= to your repository. In the case of the
systems-toolbox, it looks as follows:

#+BEGIN_SRC
    language: clojure
    lein: lein2
    script: lein2 test
    jdk:
      - oraclejdk8
#+END_SRC

This file defines that the project is written in Clojure, that we want
Leiningen 2 to run the test, and that we want the test to run on an
Oracle JDK 8. Once this file exists, TravisCI will happily test your
Clojure repository on every commit ever after. Oddly, as of this
writing, surprisingly there was no =openjdk8= available.

Note that it will take longer for the tests to run on a hosted CI server
because first, Leiningen will have to resolve the dependencies by
talking to Clojars. Currently, running the tests locally take about 10
seconds whereas running them on TravisCI take a little under a minute.

I'm missing an easy way to have JUnit reports available in TravisCI. The
=lein test2junit= task can create JUnit XML files, which we can then
turn into an HTML report using the =ant= command from the root of the
project. However, with TravisCI you need to set up Amazon's S3 to upload
artifacts, as outlined
*[[https://docs.travis-ci.com/user/uploading-artifacts/][here]]*.

*** CircleCI
    :PROPERTIES:
    :CUSTOM_ID: circleci
    :END:

[[file:images/testing/circle-ci.png]]

*[[https://circleci.com/gh/matthiasn/systems-toolbox/tree/master][CircleCI]]*
feels quite similar to TravisCI. It is also configured with a YAML file
in the root of your project, only that here it is called =circle.yml=.
For the systems-toolbox, it looks as follows:

=~ test:   override:     - lein test2junit   post:     - ant=~

Here, I'm using the =lein test2junit= task to generate JUnit-style test
reports. Then, once the test has completed, I run =ant= to create an
HTML report, which will then be available with the artifacts of the
particular build. For that, a small modification of the =project.clj=
file is also required:

#+BEGIN_SRC clojure
  :test2junit-output-dir
  ~(or (System/getenv "CIRCLE_TEST_REPORTS")
       "target/test2junit")
#+END_SRC

With these modifications, we can now keep the JUnit reports without
having to set up S3.

[[file:images/testing/circle-ci-artifacts.png]]

[[file:images/testing/circle-ci-junit.png]]

*** Conclusion
    :PROPERTIES:
    :CUSTOM_ID: conclusion
    :END:

If you want JUnit reports, you probably want CircleCI. If not, TravisCI
seems to be an equally fine option, and the choice is up to your taste.
However, and that is the most important takeaway here, if you enjoy
writing Clojure, then don't waste your time on maintaining a flaky CI
environment yourself. For open source projects, this is a complete
no-brainer, but even if you have to pay for one of the plans because
you're working on a closed-source solution, the engineers on your team
cost money, too. Plus the hardware, electricity and all.

** Testing the systems-toolbox library
   :PROPERTIES:
   :CUSTOM_ID: testing-the-systems-toolbox-library
   :END:

Okay, I admit that I'm not necessarily doing things in the right order
here. I started writing this library a little over a year ago, and this
didn't happen in a *TDD* way. I don't even necessarily feel too bad
about it, as there is a fairly comprehensive test suite for the first
"real" application using it and that ever growing test suite has been
run thousands of times. Thus, I am fairly confident that the library
does what it suggests it does. However, that test suite just takes too
long, with a lot of browser-based tests, which makes me crave an
independent test suite that gives me confidences in changes in less time
than it takes to go to the kitchen and grab a cup of black coffee. On
the other hand, the good thing about not having all the tests in place
is that I can write about it.

As of this writing, there are some tests for the component and the
scheduler namespaces. Before completing the functionality, I'd like to
take a step back and look at what I'm testing. Here we have a library
that is written entirely in *cljc*, yet the tests so far are written in
*clj* and thus only run on the JVM. *That's not right.* I only want to
invest the effort in more comprehensive testing because I expect to reap
the benefit of restoring confidence after a potentially breaking change.
But, and this I find crucial when writing any of your valuable code in
*cljc* so that you can use it on either platform, you absolutely must
test it on both platforms. Everything else is half-baked and probably
more harmful than anything. Or can you imagine the disappointment when
you get handed some logic in =.cljc= that is "tested" so you'd expect it
to work in the browser, too, only to find out that that promise has been
complete balone? Rather than being able to use the code and meet your
deadline, you start hating your colleague who now, only after your
discovery, tells you, "well, we've not actually tested it in the
browser". Yeah seriously, that's not cool.

So, before adding tests that potentially only run on the JVM, I'd rather
fix the situation by rewriting the existing tests to run on either
platform and only then make the test suite more comprehensive.

*** Porting existing tests to cljc, running tests with doo
    :PROPERTIES:
    :CUSTOM_ID: porting-existing-tests-to-cljc-running-tests-with-doo
    :END:

I've established above why I want to test code written in *cljc* on both
the *JVM* and, at least, one *JavaScript Engine*, and probably all the
ones that are relevant to my use case. Then I looked around and luckily
found *[[https://github.com/bensu/doo][doo]]*, which makes testing on a
JS engine much easier than last time I checked (and shied away).

Adding doo is easy, you add it to the plugins section in =project.clj=:

#+BEGIN_SRC clojure
      :plugins [[lein-codox "0.9.4"]
                [test2junit "1.2.1"]
                [lein-doo "0.1.6"]
                [lein-cljsbuild "1.1.2"]]
#+END_SRC

And then you add a build config for it:

#+BEGIN_SRC clojure
  :cljsbuild
  {:builds [{:id           "cljs-test"
             :source-paths ["src" "test/cljs"]
             :compiler     {:output-to     "out/testable.js"
                            :main          matthiasn.systems-toolbox.runner
                            :optimizations :whitespace}}]}
#+END_SRC

Here, I've added an initial test in the =test/cljs= path. Then, there's
a runner namespace, in which we define the tests to call:

#+BEGIN_SRC clojure
    (ns matthiasn.systems-toolbox.runner
      (:require [doo.runner :refer-macros [doo-tests]]
                [matthiasn.systems-toolbox.test]))

    (doo-tests 'matthiasn.systems-toolbox.test)
#+END_SRC

Before converting tests, let's try something simple.

#+BEGIN_SRC clojure
    (ns matthiasn.systems-toolbox.test
      (:require [cljs.test :refer-macros [deftest is]]))

    (deftest do-i-work
      (is (= 2 2)))
#+END_SRC

With these namespaces in place, we can now call test tests, for example
=$ lein doo firefox cljs-test once=. Oops, I'm writing this on a machine
that didn't have the *karma* test runner installed. If you can't run
=$ karma --version=, you want to install it with
=$ npm install -g karma=, plus check the further error output that tells
you clearly which additional *npm* modules you want to have installed.
Or, obviously, if you don't have *npm* available, you want to get it
from *[[https://nodejs.org/en/][Node.js]]* first. With the dependencies
met, my initial test runs fine.

Now I should just be able to rename my existing tests to =.cljc= and be
off to the pub, right? Not so fast. While the library is written in
=.cljc= pretty much from the get-go, that means nothing for the existing
tests. And, there we have it, the tests as of the
*[[https://github.com/matthiasn/systems-toolbox/blob/994ff8d698d1fa3f4b1d32d706f63de72bb283a4/test/matthiasn/systems_toolbox/scheduler_test.clj][current
commit]]* at the time of writing use *promises*. Such a shame those are
platform-specific and only exist on the JVM. Hmm, let's see, can we
replace them *core.async*? Probably.

*** Promises for testing in ClojureScript?
    :PROPERTIES:
    :CUSTOM_ID: promises-for-testing-in-clojurescript
    :END:

Using *promises* for determining when the assertions should be made was
not a bad idea, were it not for the lack of them on the ClojureScript
side. But, *core.async* to the rescue, we can model the behavior of
promises ourselves. In core.async, there's a *promise-chan*, which can
only be delivered on once. 'put!' then gives us the =deliver=
functionality for promises. For finally waiting for either a result or a
timeout, which is done by =deref= with promises, we can use =alts!=.
Let's look at a super simple
*[[https://github.com/matthiasn/systems-toolbox/blob/af1cb5368628d158141808dfbe2f409effd13511/test/matthiasn/systems_toolbox/component_test.cljc#L15][example]]*
first:

#+BEGIN_SRC clojure
  (deftest cmp-all-msgs-handler
    "Tests that a very simple component that only has a handler for all
    messages regardless of type receives all messages sent to the
    component. State management of the component is not used here, instead
    we keep track of the messages in an atom that's external to the
    component and that the handler function has access to. A promise is
    used here which is delivered on when the message count received
    matches those sent. This does not tell us anything about the order
    yet, but it is still very useful when waiting for all messages to be
    delivered. In the subsequent assertion, we then check if the received
    messages are complete and in the expected order."
    (let [msgs-recvd (atom [])
          cnt 1000
          msgs-to-send (vec (range cnt))
          all-recvd (promise-chan)
          cmp (component/make-component
               {:all-msgs-handler (fn [{:keys [msg-payload]}]
                                    (swap! msgs-recvd conj msg-payload)
                                    (when (= cnt (count @msgs-recvd))
                                      (put! all-recvd true)))})]

      (component/send-msgs cmp (map (fn [m] [:some/type m]) msgs-to-send))

      (tp/w-timeout 5000 (go
                           (testing "all messages received"
                             (is (true? (<! all-recvd))))
                           (testing "sent messages equal received messages"
                             (is (= msgs-to-send @msgs-recvd)))))))
#+END_SRC

As you can see above, there's the *promise-chan* =all-recvd=, onto which
we =put!= a message (=true= in this case) when done. Then, in the =go=
block inside the call to =tp/w-timeout=, we can wait for the
promise-chan to be delivered on first, before proceding with other
assertions that only make sense when the promise is delivered.

This =w-timeout= function implements behavior differently, depending on
the target platform. Let's have a look at the whole
*[[https://github.com/matthiasn/systems-toolbox/blob/9286c070f8be8684cf69676adc9bbaa393832201/test/matthiasn/systems_toolbox/test_promise.cljc][namespace]]*.
However, this is optional, it requires some understanding of =go= blocks
and channels, which the systems-toolbox tries to hide from you. So feel
free to skip the next code block and only use this promise-like behavior
as a recipe, if you so desire.

#+BEGIN_SRC clojure
  (ns matthiasn.systems-toolbox.test-promise

    "Provide a promise-like experience for testing."

    #?(:cljs (:require-macros [cljs.core.async.macros :refer [go]]))
    (:require
     #?(:clj  [clojure.test :refer [is]]
        :cljs [cljs.test :refer-macros [async is]])
     #?(:clj  [clojure.core.async :refer [go alts! <!! timeout]]
        :cljs [cljs.core.async :refer [alts! take! timeout]])))

  (defn test-async
    "Asynchronous test awaiting ch to produce a value or close.
    Makes use of cljs.test's facility for async testing.
    Borrowed from http://stackoverflow.com/questions/30766215/how-do-i-unit-test-clojure-core-async-go-macros"
    [ch]
    #?(:clj (<!! ch)
       :cljs (async done (take! ch (fn [_] (done))))))

  (defn test-within
    "Asserts that ch does not close or produce a value within ms. Returns
    a channel from which the value can be taken. Also borrowed from
    stackoverflow comment above."
    [ms ch]
    (go (let [t (timeout ms)
              [v ch] (alts! [ch t])]
          (is (not= ch t)
              (str "Test should have finished within " ms "ms."))
          v)))

  (defn w-timeout
    "Combines tes-async and test-within to provide the deref functionality
    we expect from a promise. The first argument is the timeout in
    milliseconds, the second argument should be a go-block (which returns
    a channel with the return value of the block once completed). Then, in
    that go block, we can await the promise-chan to be delivered first
    before making any further assertions."
    [ms ch]
    (test-async
      (test-within ms ch)))
#+END_SRC

First, the =test-async= function implements the wait differently. On the
JVM, we have the blocking =<!!= which simply blocks until there's value
on the channel. On the ClojureScript side, we can make use of =async= to
achieve the same thing. Note that the channel here, when composed in
=w-timeout=, is the =go= block inside =test-within=. As mentioned, =go=
blocks return a channel, onto which their return value will be put on
completion.

Then, inside =test-within=, =alts!= is used, which will return either
the value on the promise-chan or the timeout, whatever happens first.
Then, there is an assertion that the channel which returned first was
not the timeout. This gives us a nice way to wait for as long as
necessary, up to the timeout, with having to use dumb waiters like
=Thread/sleep= that always wait for the entirety of its duration and
thus hold up test runs. Also, =Thread/sleep= does not work in the
browser, while this mechanism presented here does.

In =w-timeout=, these two functions are then combined into one that
takes both the timeout and a go-block, in which we should wait for the
promise-chan.

*** Running tests in the browser / PhantomJS
    :PROPERTIES:
    :CUSTOM_ID: running-tests-in-the-browser-phantomjs
    :END:

*** Performance considerations
    :PROPERTIES:
    :CUSTOM_ID: performance-considerations
    :END:

The other day, I wanted to know how many messages the systems-toolbox
could process per second, for a single component. So I wrote an initial
test for that and got like 70K messages per second. Now, this is
probably not terrible, especially in the browser where I currently
cannot think of any application that would need anything near this
number. Here's the
*[[https://github.com/matthiasn/systems-toolbox/blob/cbeeb951d34f65da60e8772f194c7e609b71eae1/test/matthiasn/systems_toolbox/component_test.cljc#L40][test]]*:

#+BEGIN_SRC clojure
  (defn cmp-all-msgs-handler-cmp-state-fn
    "Like cmp-all-msgs-handler test, except that the handler function here
    acts on the component state provided in the map that the
    :all-msgs-handler function is called with. [...]"
    []
    (let [cnt (* 100 1000)
          state (atom 0)
          vals-to-send (vec (range cnt))
          msgs-to-send (map (fn [m] [:some/type m]) vals-to-send)
          all-recvd (promise-chan)
          res (reduce + (range cnt))
          cmp (component/make-component
               {:state-fn         (fn [_put-fn] {:state state})
                :all-msgs-handler (fn [{:keys [msg-payload cmp-state]}]
                                    (let [new-state (+ @cmp-state msg-payload)]
                                      (reset! state new-state)
                                      (when (= res new-state)
                                        (put! all-recvd true))))})
          start-ts (component/now)]

      (component/send-msgs cmp msgs-to-send)

      (tp/w-timeout
       cnt
       (go
         (testing "all messages received"
           (is (true? (<! all-recvd))))
         (testing "processes more than 1K messages per second"
           (let [msgs-per-sec (int (* (/ 1000 (- (component/now) start-ts)) cnt))]
             (log/debug "Msgs/s:" msgs-per-sec)
             (is (> msgs-per-sec 1000))))
         (testing "sent messages equal received messages"
           (is (= res @state)))))))

  (deftest cmp-all-msgs-handler-cmp-state1
    (cmp-all-msgs-handler-cmp-state-fn))

  (deftest cmp-all-msgs-handler-cmp-state2
    (cmp-all-msgs-handler-cmp-state-fn))

  (deftest cmp-all-msgs-handler-cmp-state3
    (cmp-all-msgs-handler-cmp-state-fn))

  (deftest cmp-all-msgs-handler-cmp-state4
    (cmp-all-msgs-handler-cmp-state-fn))

  (deftest cmp-all-msgs-handler-cmp-state5
    (cmp-all-msgs-handler-cmp-state-fn))

  (deftest cmp-all-msgs-handler-cmp-state6
    (cmp-all-msgs-handler-cmp-state-fn))
#+END_SRC

What happens here is that I take an atom with the number zero in it, and
the range from zero to 100,000 (exclusive) and send each number in that
range to the component =cmp=, which adds each to its component state.
Then, in the assertions section, I calculate how many messages per
second the processing time corresponds to, print that value for
reference, assert that it's large enough, and finally check that all
numbers were processed by comparing the number in the component state
with the result of =(reduce + (range cnt)=. I also make an assertion
about the number of messages per second being high enough here, but
that's probably not terribly useful as this number has to be pretty
conservative anyway to take into account less powerful nodes, such as
the ones used by TravisCI or CircleCI. Also note that the test code is
in a function that I then call multiple times to see how much of an
effect JIT compilation has on the result. Apparently, some optimizations
do kick in on subsequent runs:

#+BEGIN_SRC
    lein test matthiasn.systems-toolbox.component-test
    DEBUG m.systems-toolbox.component-test - Msgs/s: 62814
    DEBUG m.systems-toolbox.component-test - Msgs/s: 71479
    DEBUG m.systems-toolbox.component-test - Msgs/s: 91575
    DEBUG m.systems-toolbox.component-test - Msgs/s: 88731
    DEBUG m.systems-toolbox.component-test - Msgs/s: 78616
    DEBUG m.systems-toolbox.component-test - Msgs/s: 89928
#+END_SRC

Okay, roughly 60K messages per second on the first run and then towards
90K messages per second on subsequent runs. Doesn't sound that terrible.

Then on the next day, I went for breakfast with my friend Peter. I told
him what I was working on and about the numbers I achieved. Then he
mentioned that he was working on an implementation of the
*[[https://en.wikipedia.org/wiki/Actor_model][actor model]]* in
*[[https://www.rust-lang.org/][Rust]]* and that there, his latest
benchmark gave him numbers well north of 2 million messages per second,
without much optimization effort yet. That was a bit of a downer. Sure,
I wouldn't be too bothered to learn that Rust was faster than Clojure,
that's kind of to be expected, but well above an order of magnitude for
the simple task of delivering a message to some entity is more than I'd
be willing to accept, especially since those numbers for his Rust
project were pre-optimization.

That made me wonder where time was spent in my library, so I set out to
check what the JVM is capable of. I started with looking at atoms and
how often I can reset or swap them per second. Here's the test for
resetting an atom:

#+BEGIN_SRC clojure
  (defn reset-atom-repeatedly-fn
    "This test aims at getting some perspective how expensive resetting an
    atom is in Clojure/ClojureScript. Answer: not terribly expensive. On
    the JVM, this can be performed around 90 million times per second,
    whereas in ClojureScript, this can be done 15 million times per second
    on PhantomJS and over 60 million times per second in Firefox (2015
    Retina MacBook)."
    []
    (let [start-ts (component/now)
          cnt (* 1000 1000)
          state (atom 0)]
      (dotimes [n cnt] (reset! state n))
      (let [ops-per-sec (int (* (/ 1000 (- (component/now) start-ts)) cnt))]
        (log/debug "Atom resets/s:" ops-per-sec)
        (is (> ops-per-sec 1000)))))

  (deftest reset-atom-repeatedly
    (dotimes [_ test-runs]
      (reset-atom-repeatedly-fn)))
#+END_SRC

Okay, so even when I run this test alone in a cold JVM with
=$ lein test :only matthiasn.systems-toolbox.runtime-perf-test/reset-atom-repeatedly=
and only a single run, I get anywhere between 29 and 43 *million*
ops/sec. When I set =test-runs= to 10, I even get up to *90 million*
ops/sec on the JVM. On phantom, there's no noticeable effect of JIT on
subsequent runs, by the way. But there I also don't know how to isolate
test runs, so likely the JIT optimizations will already have kicked in
by the time the tests run. Still, I get a solid 15 million ops/sec in
phantom at the time of writing. On Chrome, I got 38 million ops/sec and
on Firefox, I got a whopping *66 million* ops/sec. Interesting, last
time I checked, Chrome was faster than any other browser, but that does
not seem to be the case any longer. Anyway, in either case, resetting an
atom is quite obviously not a bottleneck on any of those platforms.

Hmm, maybe the atom watching, which leads to publishing a new state
snapshot when a change is detected, could be the culprit? Let's check:

#+BEGIN_SRC clojure
  (defn swap-watched-atom-repeatedly-fn
    "This test aims at getting some perspective how expensive swapping an atom
    is in Clojure/ClojureScript.
    Answer: not terribly expensive. On the JVM, this can be performed around
    70 million times per second, whereas in ClojureScript,this can be done
    15 million times per second (2015 Retina MacBook)."
    []
    (let [start-ts (component/now)
          cnt (* 1000 1000)
          state (atom 0)]
      (add-watch state :watcher (fn [_ _ _ _new-state] #()))
      (dotimes [_ cnt] (swap! state inc))
      (let [ops-per-sec (int (* (/ 1000 (- (component/now) start-ts)) cnt))]
        (log/debug "Watched atom swaps/s:" ops-per-sec)
        (is (> ops-per-sec 1000)))))

  (deftest swap-watched-atom-repeatedly
    (dotimes [_ test-runs]
      (swap-watched-atom-repeatedly-fn)))
#+END_SRC

Nope. Almost 70 million ops/sec on Firefox and 40 million ops/sec on the
JVM (on repeated runs) suggest differently. Hmm, could it be core.async?
Let's see:

#+BEGIN_SRC clojure
  (defn put-on-chan-repeatedly-fn
    "Channel with attached mult and no other channels tapping into mult:
    messages silently dropped."
    []
    (let [start-ts (component/now)
          cnt (* 100 1000)
          ch (chan)
          m (mult ch)
          done (promise-chan)]
      (go
        (dotimes [n cnt] (>! ch n))
        (put! done true))

      (tp/w-timeout 
       cnt 
       (go
         (testing "all messages received"
           (is (true? (<! done))))
         (let [ops-per-sec (int (* (/ 1000 (- (component/now) start-ts)) cnt))]
           (log/debug "Channel puts/s:" ops-per-sec)
           (is (> ops-per-sec 1000)))))))

  (deftest put-on-chan-repeatedly1
    (put-on-chan-repeatedly-fn))
  (deftest put-on-chan-repeatedly2
    (put-on-chan-repeatedly-fn))
  (deftest put-on-chan-repeatedly3
    (put-on-chan-repeatedly-fn))
  (deftest put-on-chan-repeatedly4
    (put-on-chan-repeatedly-fn))
  (deftest put-on-chan-repeatedly5
    (put-on-chan-repeatedly-fn))
  (deftest put-on-chan-repeatedly6
    (put-on-chan-repeatedly-fn))
#+END_SRC

Okay, around 1 million ops/sec on Firefox and a little under 250K
ops/sec on the JVM (on repeated runs). Now this is substantially slower
than the atom operations. We might be onto something here, since the
library does multiple core.async operations for each message. Let's
emulate the (basic) behavior of the library using core.async directly:

#+BEGIN_SRC clojure
  (defn put-consume-mult-w-pub-repeatedly-fn
    "Channel with attached go-loop, simple calculation using messages from
    channel, publication of state change. This imitates the basic use case of the
    systems-toolbox: there's a go-loop, some processing and publication of
    component state. Running this test gives some perspective of the amount of
    overhead that the systems-toolbox introduces, such as adding metadata to
    messages."
    []
    (let [start-ts (component/now)
          cnt (* 100 1000)
          ch (chan (buffer 1))
          m (mult ch)
          ch2 (chan)
          state-pub-chan (chan (sliding-buffer 1))
          state-mult (mult state-pub-chan)
          state (atom 0)
          done (promise-chan)]

      (go-loop []
        (let [n (<! ch2)
              res (+ @state n)]
          (reset! state res)
          (>! state-pub-chan res)
          (when (= (dec cnt) n)
            (put! done true)))
        (recur))

      (tap m ch2)
      (go (dotimes [n cnt] (>! ch n)))

      (tp/w-timeout
       cnt
       (go
         (testing "promise delivered"
           (is (true? (<! done))))
         (let [ops-per-sec (int (* (/ 1000 (- (component/now) start-ts)) cnt))]
           (log/debug "Channel puts and consume from mult/s (w/pub):" ops-per-sec)
           (is (> ops-per-sec 1000)))
         (testing "all messages received (sum of all number sent matches)"
           (is (= @state (reduce + (range cnt)))))
         :done))))

  (deftest put-consume-mult-w-pub-repeatedly
    (put-consume-mult-w-pub-repeatedly-fn))
  (deftest put-consume-mult-w-pub-repeatedly2
    (put-consume-mult-w-pub-repeatedly-fn))
  (deftest put-consume-mult-w-pub-repeatedly3
    (put-consume-mult-w-pub-repeatedly-fn))
  (deftest put-consume-mult-w-pub-repeatedly4
    (put-consume-mult-w-pub-repeatedly-fn))
  (deftest put-consume-mult-w-pub-repeatedly5
    (put-consume-mult-w-pub-repeatedly-fn))
  (deftest put-consume-mult-w-pub-repeatedly6
    (put-consume-mult-w-pub-repeatedly-fn))
#+END_SRC

Here, we do roughly the same a component in the systems-toolbox does,
which receives messages on a channel, process them in a =go-loop= (which
is hidden from the user in the case of the systems-toolbox), and publish
state changes onto the =state-pub-chan=. Et voilà, the results are
pretty much the same as we see when processing messages with the
systems-toolbox, with around 90K msgs/sec on the JVM.

Okay, so I'm fully aware of my tendency to shave yaks when it comes to
looking at performance. However, I think this little excursion was
useful, at least for me, as it provides some context where time is spent
and where future optimizations could go. For example, you've probably
heard that atoms are slower than their =volatile!= counterpart. However,
when looking at the data that surfaced here, interacting with atoms is
not where substantial amounts time are wasted. Thus, looking at
replacing atoms with =volatile!= is likely not going to help much. If
anything, it might be worth looking into core.async, which does seem to
add a considerable amount of overhead. Considering that we are talking
about in-process conveyance here and that Kafka is capable of handling
*[[https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines][millions
of messages]]* a second, the numbers here are a little lame, especially
since in the case of Kafka, this involves round trips to the filesystem
and network. But then again, this is not a real problem until it is. So
far, the applications I have written with the systems-toolbox have not
hit a brick wall when it comes to performance. 90K msgs/sec is still
plenty and probably more than you could expect to get from REST-based
microservices.

However, the results confirm my hunch that it's probably a good idea to
make the message conveyance in the systems-toolbox pluggable, and then
offer a choice to handle it with either *core.async* or *Kafka* on the
JVM, as that would offer attractive properties for observability out of
the box. But that's a different story and not within the scope of this
chapter. In the browser, I cannot think of a use case right now where
tens of thousands of messages per second would not suffice.

#+Latex:\pagebreak
* Operational Insight
  :PROPERTIES:
  :CUSTOM_ID: operational-insight
  :END:

Before we can start optimizing just about anything, we will need
operational insight. We will need a dashboard that shows
(near-)real-time data about how all processes participating in the
system run. Luckily, the basic infrastructure we would need for such an
effort is already in place in the main application. We are already
dealing with a web interface that receives live data over WebSockets and
that draws charts. On the server side, we have Redis, which could just
as well collect metrics from all JVMs in the system and distribute the
data to a service that processes this data for consumption by a
dashboard web application.

My idea is to build this dashboard without relying on any external
services such as StatsD/Graphite, Riemann and such. This is not to say
that these tools wouldn't help, but it is an interesting problem that I
believe can be solved without having to learn about additional tools.

#+Latex:\pagebreak
* Load Testing and Optimization
  :PROPERTIES:
  :CUSTOM_ID: load-testing-and-optimization
  :END:

In this part of the book, we will determine performance baselines,
optimize obvious performance bottlenecks and implement a load testing
strategy so that we obtain a good understanding about how the system
performs under load. Once we are able to generate load, we can also have
a look at optimizing the environment, for example for reasonable garbage
collection behavior where the system does not become unnecessarily
unresponsive.

** Performance and Load Characteristics
   :PROPERTIES:
   :CUSTOM_ID: performance-and-load-characteristics
   :END:

Of course, it would be interesting to have actual user load. But with or
without actual load, we want to find a way of how to generate / simulate
load and then observe the system, identify the bottlenecks and remove
them. For example, the clients could be simulated by connecting a load
generator via Redis and deliver matches back to that application and
check if they are as expected (correct, complete, timely). The Twitter
stream could also be simulated, for example by connecting to a load
generator that either replays recorded tweets, with full control over
the rate or with artificial test cases, for which we could accurately
specify the expectations on the output side.

** Optimization and Environment
   :PROPERTIES:
   :CUSTOM_ID: optimization-and-environment
   :END:

#+Latex:\pagebreak
* Deployment
  :PROPERTIES:
  :CUSTOM_ID: deployment
  :END:

In this chapter, we will have a look at potential deployment strategies,
for example by running the individual parts in separate Docker
containers on one or more host machines, or by deploying through an
application server.

** Docker Containers
   :PROPERTIES:
   :CUSTOM_ID: docker-containers
   :END:

My initial excitement for Docker has somewhat cooled down -- it is
certainly not the cure for all as I had erroneously assumed some time
ago, and it has caused me some anger in the past few months. But Docker
still has some positive sides, and there are ways to make your
experience when running your application inside a Docker container
smoother.

*If you think this chapter should be prioritized, send me an eMail.*

** Wildfly / Deploying a WAR file
   :PROPERTIES:
   :CUSTOM_ID: wildfly-deploying-a-war-file
   :END:

I've recently experimented with running the BirdWatch application in a
WildFly application server, with great success. There's something quite
nice about using functionality from such an application server, such as
content compression or TLS, with no more than simply adding some
configuration, rather than having to implement all that yourself.

*If you think this chapter should be prioritized, send me an eMail.*

#+Latex:\pagebreak
* Appendix
  :PROPERTIES:
  :CUSTOM_ID: appendix
  :END:

All the material from here on out was written before the reboot in June
2016. While it may still be helpful, it's probably outdated by now, and
all of it will be revisited.
