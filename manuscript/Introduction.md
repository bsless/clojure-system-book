# Introduction

Back in 2014, I had this cute little side project on GitHub called BirdWatch for observing a live stream of Tweets. I had started writing it in Scala on the server side and using AngularJS on the client side. The project had gained a fair amount interest on GitHub -- however, at that point I had unfortunately fallen out of love with both. At the same time, I had developed a curiosity for Clojure and LISP. So I thought, I might as well rewrite the project using Clojure and ClojureScript and see where that would take me. What I had then found was a beautiful, beautiful language but very little shared knowledge on how to build complex systems with it. Some time ago, I had read books about Communicating Sequential Processes (CSP) so core.async was a natural candidate for building decoupled systems. A first version of the rewritten application relied only on core.async for moving messages around, but I was missing enough structure for building an application with it. I found Stuart Sierra's component library and refactored the server-side application using components. He's right in his talk that that can be tough at times, but it can be done. I will present this approach in the first chapter. You want to read the subsequent chapters after that, as I just describe the approach there and don't criticize it. Later chapters will deal with that.

Then I found some major issues with the approach of building applications with the combination of the component library and core.async:

1) The component library is Clojure-only. That alone should be a deal breaker. While the client side deals with some exclusive problems such as presentation, it shares a lot with the server side. Once I start thinking about CSP style message passing and bi-directional communication with a web application, I'd have to be a fool not to bring this style of communication all the way to the frontend. Think of a store component on the client in the sense of stores in Facebook's Flux architecture. This component has some observable state that React turns into an always up-to-date visual representation. But with the rest of a larger system, it communicates in just the same way as any component on the backend does. Why then should I want to build this with code that differs substantially? I just could not convince myself to settle with this. 

2) The combination of core.async and the component library as I imagined it involved more tedious plumbing than I was happy with, as you will have the chance to convince yourself of in the aforementioned first chapter. This issue alone I likely could have improved -- were it not for the previous issue.

3) Building components from scratch also meant rewriting logging for every component to gain any insight. But how awful is logging for following asynchronous messages through a system? Do you like inserting log statements everywhere when writing software, and then removing them when you clean up the code? Sure, you could have all these only log in DEBUG mode for a particular component. But then when trying to find an issue in production, do you have the luxury to restart the application every time you reconsider what you want to be logged, always considering performance and your sanity? I think that's not right. We're dealing with immutable data structures here. Once they exist, they are cheap to pass around, including to some runtime-configurable way of following messages through the system you're building and hopefully running. For that purpose, I built the inspect library, which you can find on GitHub. That seemed like a good idea for a moment, but it was still lacking. First of all, I still had to insert the inspect statements manually, just like I had to with log statements. But why? Observing component input and output is such a universal thing that any component I built should automatically have it, with zero extra lines. Also, messages alone don't suffice when trying to observe any running systems. Let's say such a system consists of components that take messages from conveyor belts, process them and potentially output other messages on yet other conveyor belts. Then there are four distinct things I want to know when observing such systems:
 
a) what does any input to a component look like, 
b) how does the component state look like before and after receiving the message, 
c) what's the output from a component, and 
d) what's the structure of the running system. 

I would find it very helpful to be able to answer these questions for any given component in the system within a handful of minutes. It should not matter if it's the production system or a local development version of the same. That be useful when revisiting code written a long time ago, like say a couple of weeks, and also when coming into a new project and mentally mapping the system at hand for the first time.

The inspect library only addressed a) and c), and I realized that more drastic steps were necessary for solving b) and d).

Then a new gig came along, with Aviso in Ireland. I am lucky with this gig as they allow me to focus on all these issues while migrating an existing AngularJS application with a Clojure backend to an all-Clojure and ClojureScript application. I can say that I'm getting paid well for finding solutions to problems that have annoyed me at least since the day I started writing software for a living, and likely much longer. You can follow this ongoing process by observing how the systems-toolbox develops. There's not enough time in the day to write blog posts about every interesting aspect at this point, but I'll be happy to answer any question you may have about the code you discover there.

All this is happening while contributing to the migration of system that's supposed to go in production within a matter of weeks instead of months.

While this chance is great, all this work has also kept me away from continuing to write this book as I would have liked. I can assure you though that the work on the systems-toolbox library will be directly relevant to the book you are holding in your hands right now -- likely embodied in a screen with a backlight of some kind.

Without further ado, I now invite you to have a look at my initial component and core.async approach. You may find the code tedious and repetitive, but that's okay, I feel the same way. On a tech radar, I would place this approach on hold.

Hopefully, by the time this book is complete, I will be able to present a much better approach. So far, I'm happy with how things have developed, but there's still a lot to do to get closer to the vision of a system that's observable in a meaningful way during runtime. After all, I firmly believe that the map is not the territory and that the behavior of any complex system is not predictable from looking at a blueprint alone. The code is just that, a blueprint. Issues with any construction will come out when using it; tests only help so much as they can only reveal what we already know to look for in the first place. My thinking there has been influenced by a Sytems Thinking approach, which keeps informing many decisions in the development of the systems-toolbox library. You'll find the concepts throughout the book, and there's also a gentle introduction to Systems Thinking the opening part of the book.
